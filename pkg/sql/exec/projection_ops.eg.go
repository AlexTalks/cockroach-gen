// Code generated by execgen; DO NOT EDIT.

package exec

import (
	"bytes"
	"context"
	"math"

	"github.com/cockroachdb/apd"
	"github.com/cockroachdb/cockroach/pkg/col/coldata"
	"github.com/cockroachdb/cockroach/pkg/col/coltypes"
	"github.com/cockroachdb/cockroach/pkg/sql/exec/execerror"
	"github.com/cockroachdb/cockroach/pkg/sql/exec/typeconv"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/types"
	"github.com/pkg/errors"
)

type projEQBoolBoolConstOp struct {
	OneInputNode

	colIdx   int
	constArg bool

	outputIdx int
}

func (p projEQBoolBoolConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQBoolBoolConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Bool()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				if !arg && p.constArg {
					cmpResult = -1
				} else if arg && !p.constArg {
					cmpResult = 1
				} else {
					cmpResult = 0
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				if !arg && p.constArg {
					cmpResult = -1
				} else if arg && !p.constArg {
					cmpResult = 1
				} else {
					cmpResult = 0
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQBoolBoolConstOp) Init() {
	p.input.Init()
}

type projEQBoolConstBoolOp struct {
	OneInputNode

	colIdx   int
	constArg bool

	outputIdx int
}

func (p projEQBoolConstBoolOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQBoolConstBoolOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Bool()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				if !p.constArg && arg {
					cmpResult = -1
				} else if p.constArg && !arg {
					cmpResult = 1
				} else {
					cmpResult = 0
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				if !p.constArg && arg {
					cmpResult = -1
				} else if p.constArg && !arg {
					cmpResult = 1
				} else {
					cmpResult = 0
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQBoolConstBoolOp) Init() {
	p.input.Init()
}

type projEQBoolBoolOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQBoolBoolOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQBoolBoolOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Bool()
	col2 := vec2.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				if !arg1 && arg2 {
					cmpResult = -1
				} else if arg1 && !arg2 {
					cmpResult = 1
				} else {
					cmpResult = 0
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				if !arg1 && arg2 {
					cmpResult = -1
				} else if arg1 && !arg2 {
					cmpResult = 1
				} else {
					cmpResult = 0
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQBoolBoolOp) Init() {
	p.input.Init()
}

type projNEBoolBoolConstOp struct {
	OneInputNode

	colIdx   int
	constArg bool

	outputIdx int
}

func (p projNEBoolBoolConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEBoolBoolConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Bool()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				if !arg && p.constArg {
					cmpResult = -1
				} else if arg && !p.constArg {
					cmpResult = 1
				} else {
					cmpResult = 0
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				if !arg && p.constArg {
					cmpResult = -1
				} else if arg && !p.constArg {
					cmpResult = 1
				} else {
					cmpResult = 0
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEBoolBoolConstOp) Init() {
	p.input.Init()
}

type projNEBoolConstBoolOp struct {
	OneInputNode

	colIdx   int
	constArg bool

	outputIdx int
}

func (p projNEBoolConstBoolOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEBoolConstBoolOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Bool()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				if !p.constArg && arg {
					cmpResult = -1
				} else if p.constArg && !arg {
					cmpResult = 1
				} else {
					cmpResult = 0
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				if !p.constArg && arg {
					cmpResult = -1
				} else if p.constArg && !arg {
					cmpResult = 1
				} else {
					cmpResult = 0
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEBoolConstBoolOp) Init() {
	p.input.Init()
}

type projNEBoolBoolOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEBoolBoolOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEBoolBoolOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Bool()
	col2 := vec2.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				if !arg1 && arg2 {
					cmpResult = -1
				} else if arg1 && !arg2 {
					cmpResult = 1
				} else {
					cmpResult = 0
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				if !arg1 && arg2 {
					cmpResult = -1
				} else if arg1 && !arg2 {
					cmpResult = 1
				} else {
					cmpResult = 0
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEBoolBoolOp) Init() {
	p.input.Init()
}

type projLTBoolBoolConstOp struct {
	OneInputNode

	colIdx   int
	constArg bool

	outputIdx int
}

func (p projLTBoolBoolConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTBoolBoolConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Bool()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				if !arg && p.constArg {
					cmpResult = -1
				} else if arg && !p.constArg {
					cmpResult = 1
				} else {
					cmpResult = 0
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				if !arg && p.constArg {
					cmpResult = -1
				} else if arg && !p.constArg {
					cmpResult = 1
				} else {
					cmpResult = 0
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTBoolBoolConstOp) Init() {
	p.input.Init()
}

type projLTBoolConstBoolOp struct {
	OneInputNode

	colIdx   int
	constArg bool

	outputIdx int
}

func (p projLTBoolConstBoolOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTBoolConstBoolOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Bool()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				if !p.constArg && arg {
					cmpResult = -1
				} else if p.constArg && !arg {
					cmpResult = 1
				} else {
					cmpResult = 0
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				if !p.constArg && arg {
					cmpResult = -1
				} else if p.constArg && !arg {
					cmpResult = 1
				} else {
					cmpResult = 0
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTBoolConstBoolOp) Init() {
	p.input.Init()
}

type projLTBoolBoolOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTBoolBoolOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTBoolBoolOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Bool()
	col2 := vec2.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				if !arg1 && arg2 {
					cmpResult = -1
				} else if arg1 && !arg2 {
					cmpResult = 1
				} else {
					cmpResult = 0
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				if !arg1 && arg2 {
					cmpResult = -1
				} else if arg1 && !arg2 {
					cmpResult = 1
				} else {
					cmpResult = 0
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTBoolBoolOp) Init() {
	p.input.Init()
}

type projLEBoolBoolConstOp struct {
	OneInputNode

	colIdx   int
	constArg bool

	outputIdx int
}

func (p projLEBoolBoolConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEBoolBoolConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Bool()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				if !arg && p.constArg {
					cmpResult = -1
				} else if arg && !p.constArg {
					cmpResult = 1
				} else {
					cmpResult = 0
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				if !arg && p.constArg {
					cmpResult = -1
				} else if arg && !p.constArg {
					cmpResult = 1
				} else {
					cmpResult = 0
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEBoolBoolConstOp) Init() {
	p.input.Init()
}

type projLEBoolConstBoolOp struct {
	OneInputNode

	colIdx   int
	constArg bool

	outputIdx int
}

func (p projLEBoolConstBoolOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEBoolConstBoolOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Bool()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				if !p.constArg && arg {
					cmpResult = -1
				} else if p.constArg && !arg {
					cmpResult = 1
				} else {
					cmpResult = 0
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				if !p.constArg && arg {
					cmpResult = -1
				} else if p.constArg && !arg {
					cmpResult = 1
				} else {
					cmpResult = 0
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEBoolConstBoolOp) Init() {
	p.input.Init()
}

type projLEBoolBoolOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEBoolBoolOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEBoolBoolOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Bool()
	col2 := vec2.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				if !arg1 && arg2 {
					cmpResult = -1
				} else if arg1 && !arg2 {
					cmpResult = 1
				} else {
					cmpResult = 0
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				if !arg1 && arg2 {
					cmpResult = -1
				} else if arg1 && !arg2 {
					cmpResult = 1
				} else {
					cmpResult = 0
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEBoolBoolOp) Init() {
	p.input.Init()
}

type projGTBoolBoolConstOp struct {
	OneInputNode

	colIdx   int
	constArg bool

	outputIdx int
}

func (p projGTBoolBoolConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTBoolBoolConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Bool()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				if !arg && p.constArg {
					cmpResult = -1
				} else if arg && !p.constArg {
					cmpResult = 1
				} else {
					cmpResult = 0
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				if !arg && p.constArg {
					cmpResult = -1
				} else if arg && !p.constArg {
					cmpResult = 1
				} else {
					cmpResult = 0
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTBoolBoolConstOp) Init() {
	p.input.Init()
}

type projGTBoolConstBoolOp struct {
	OneInputNode

	colIdx   int
	constArg bool

	outputIdx int
}

func (p projGTBoolConstBoolOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTBoolConstBoolOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Bool()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				if !p.constArg && arg {
					cmpResult = -1
				} else if p.constArg && !arg {
					cmpResult = 1
				} else {
					cmpResult = 0
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				if !p.constArg && arg {
					cmpResult = -1
				} else if p.constArg && !arg {
					cmpResult = 1
				} else {
					cmpResult = 0
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTBoolConstBoolOp) Init() {
	p.input.Init()
}

type projGTBoolBoolOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTBoolBoolOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTBoolBoolOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Bool()
	col2 := vec2.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				if !arg1 && arg2 {
					cmpResult = -1
				} else if arg1 && !arg2 {
					cmpResult = 1
				} else {
					cmpResult = 0
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				if !arg1 && arg2 {
					cmpResult = -1
				} else if arg1 && !arg2 {
					cmpResult = 1
				} else {
					cmpResult = 0
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTBoolBoolOp) Init() {
	p.input.Init()
}

type projGEBoolBoolConstOp struct {
	OneInputNode

	colIdx   int
	constArg bool

	outputIdx int
}

func (p projGEBoolBoolConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEBoolBoolConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Bool()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				if !arg && p.constArg {
					cmpResult = -1
				} else if arg && !p.constArg {
					cmpResult = 1
				} else {
					cmpResult = 0
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				if !arg && p.constArg {
					cmpResult = -1
				} else if arg && !p.constArg {
					cmpResult = 1
				} else {
					cmpResult = 0
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEBoolBoolConstOp) Init() {
	p.input.Init()
}

type projGEBoolConstBoolOp struct {
	OneInputNode

	colIdx   int
	constArg bool

	outputIdx int
}

func (p projGEBoolConstBoolOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEBoolConstBoolOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Bool()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				if !p.constArg && arg {
					cmpResult = -1
				} else if p.constArg && !arg {
					cmpResult = 1
				} else {
					cmpResult = 0
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				if !p.constArg && arg {
					cmpResult = -1
				} else if p.constArg && !arg {
					cmpResult = 1
				} else {
					cmpResult = 0
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEBoolConstBoolOp) Init() {
	p.input.Init()
}

type projGEBoolBoolOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEBoolBoolOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEBoolBoolOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Bool()
	col2 := vec2.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				if !arg1 && arg2 {
					cmpResult = -1
				} else if arg1 && !arg2 {
					cmpResult = 1
				} else {
					cmpResult = 0
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				if !arg1 && arg2 {
					cmpResult = -1
				} else if arg1 && !arg2 {
					cmpResult = 1
				} else {
					cmpResult = 0
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEBoolBoolOp) Init() {
	p.input.Init()
}

type projEQBytesBytesConstOp struct {
	OneInputNode

	colIdx   int
	constArg []byte

	outputIdx int
}

func (p projEQBytesBytesConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQBytesBytesConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Bytes()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col.Get(int(i))

			{
				var cmpResult int
				cmpResult = bytes.Compare(arg, p.constArg)
				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col.Slice(0, int(n))
		colLen := col.Len()
		_ = projCol[colLen-1]
		for i := 0; i < col.Len(); i++ {
			arg := col.Get(i)

			{
				var cmpResult int
				cmpResult = bytes.Compare(arg, p.constArg)
				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQBytesBytesConstOp) Init() {
	p.input.Init()
}

type projEQBytesConstBytesOp struct {
	OneInputNode

	colIdx   int
	constArg []byte

	outputIdx int
}

func (p projEQBytesConstBytesOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQBytesConstBytesOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Bytes()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col.Get(int(i))

			{
				var cmpResult int
				cmpResult = bytes.Compare(p.constArg, arg)
				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col.Slice(0, int(n))
		colLen := col.Len()
		_ = projCol[colLen-1]
		for i := 0; i < col.Len(); i++ {
			arg := col.Get(i)

			{
				var cmpResult int
				cmpResult = bytes.Compare(p.constArg, arg)
				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQBytesConstBytesOp) Init() {
	p.input.Init()
}

type projEQBytesBytesOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQBytesBytesOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQBytesBytesOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Bytes()
	col2 := vec2.Bytes()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1.Get(int(i))
			arg2 := col2.Get(int(i))

			{
				var cmpResult int
				cmpResult = bytes.Compare(arg1, arg2)
				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1.Slice(0, int(n))
		colLen := col1.Len()
		_ = projCol[colLen-1]
		_ = col2.Slice(0, colLen-1)
		for i := 0; i < col1.Len(); i++ {
			arg1 := col1.Get(i)
			arg2 := col2.Get(i)

			{
				var cmpResult int
				cmpResult = bytes.Compare(arg1, arg2)
				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQBytesBytesOp) Init() {
	p.input.Init()
}

type projNEBytesBytesConstOp struct {
	OneInputNode

	colIdx   int
	constArg []byte

	outputIdx int
}

func (p projNEBytesBytesConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEBytesBytesConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Bytes()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col.Get(int(i))

			{
				var cmpResult int
				cmpResult = bytes.Compare(arg, p.constArg)
				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col.Slice(0, int(n))
		colLen := col.Len()
		_ = projCol[colLen-1]
		for i := 0; i < col.Len(); i++ {
			arg := col.Get(i)

			{
				var cmpResult int
				cmpResult = bytes.Compare(arg, p.constArg)
				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEBytesBytesConstOp) Init() {
	p.input.Init()
}

type projNEBytesConstBytesOp struct {
	OneInputNode

	colIdx   int
	constArg []byte

	outputIdx int
}

func (p projNEBytesConstBytesOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEBytesConstBytesOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Bytes()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col.Get(int(i))

			{
				var cmpResult int
				cmpResult = bytes.Compare(p.constArg, arg)
				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col.Slice(0, int(n))
		colLen := col.Len()
		_ = projCol[colLen-1]
		for i := 0; i < col.Len(); i++ {
			arg := col.Get(i)

			{
				var cmpResult int
				cmpResult = bytes.Compare(p.constArg, arg)
				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEBytesConstBytesOp) Init() {
	p.input.Init()
}

type projNEBytesBytesOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEBytesBytesOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEBytesBytesOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Bytes()
	col2 := vec2.Bytes()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1.Get(int(i))
			arg2 := col2.Get(int(i))

			{
				var cmpResult int
				cmpResult = bytes.Compare(arg1, arg2)
				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1.Slice(0, int(n))
		colLen := col1.Len()
		_ = projCol[colLen-1]
		_ = col2.Slice(0, colLen-1)
		for i := 0; i < col1.Len(); i++ {
			arg1 := col1.Get(i)
			arg2 := col2.Get(i)

			{
				var cmpResult int
				cmpResult = bytes.Compare(arg1, arg2)
				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEBytesBytesOp) Init() {
	p.input.Init()
}

type projLTBytesBytesConstOp struct {
	OneInputNode

	colIdx   int
	constArg []byte

	outputIdx int
}

func (p projLTBytesBytesConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTBytesBytesConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Bytes()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col.Get(int(i))

			{
				var cmpResult int
				cmpResult = bytes.Compare(arg, p.constArg)
				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col.Slice(0, int(n))
		colLen := col.Len()
		_ = projCol[colLen-1]
		for i := 0; i < col.Len(); i++ {
			arg := col.Get(i)

			{
				var cmpResult int
				cmpResult = bytes.Compare(arg, p.constArg)
				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTBytesBytesConstOp) Init() {
	p.input.Init()
}

type projLTBytesConstBytesOp struct {
	OneInputNode

	colIdx   int
	constArg []byte

	outputIdx int
}

func (p projLTBytesConstBytesOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTBytesConstBytesOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Bytes()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col.Get(int(i))

			{
				var cmpResult int
				cmpResult = bytes.Compare(p.constArg, arg)
				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col.Slice(0, int(n))
		colLen := col.Len()
		_ = projCol[colLen-1]
		for i := 0; i < col.Len(); i++ {
			arg := col.Get(i)

			{
				var cmpResult int
				cmpResult = bytes.Compare(p.constArg, arg)
				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTBytesConstBytesOp) Init() {
	p.input.Init()
}

type projLTBytesBytesOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTBytesBytesOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTBytesBytesOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Bytes()
	col2 := vec2.Bytes()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1.Get(int(i))
			arg2 := col2.Get(int(i))

			{
				var cmpResult int
				cmpResult = bytes.Compare(arg1, arg2)
				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1.Slice(0, int(n))
		colLen := col1.Len()
		_ = projCol[colLen-1]
		_ = col2.Slice(0, colLen-1)
		for i := 0; i < col1.Len(); i++ {
			arg1 := col1.Get(i)
			arg2 := col2.Get(i)

			{
				var cmpResult int
				cmpResult = bytes.Compare(arg1, arg2)
				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTBytesBytesOp) Init() {
	p.input.Init()
}

type projLEBytesBytesConstOp struct {
	OneInputNode

	colIdx   int
	constArg []byte

	outputIdx int
}

func (p projLEBytesBytesConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEBytesBytesConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Bytes()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col.Get(int(i))

			{
				var cmpResult int
				cmpResult = bytes.Compare(arg, p.constArg)
				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col.Slice(0, int(n))
		colLen := col.Len()
		_ = projCol[colLen-1]
		for i := 0; i < col.Len(); i++ {
			arg := col.Get(i)

			{
				var cmpResult int
				cmpResult = bytes.Compare(arg, p.constArg)
				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEBytesBytesConstOp) Init() {
	p.input.Init()
}

type projLEBytesConstBytesOp struct {
	OneInputNode

	colIdx   int
	constArg []byte

	outputIdx int
}

func (p projLEBytesConstBytesOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEBytesConstBytesOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Bytes()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col.Get(int(i))

			{
				var cmpResult int
				cmpResult = bytes.Compare(p.constArg, arg)
				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col.Slice(0, int(n))
		colLen := col.Len()
		_ = projCol[colLen-1]
		for i := 0; i < col.Len(); i++ {
			arg := col.Get(i)

			{
				var cmpResult int
				cmpResult = bytes.Compare(p.constArg, arg)
				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEBytesConstBytesOp) Init() {
	p.input.Init()
}

type projLEBytesBytesOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEBytesBytesOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEBytesBytesOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Bytes()
	col2 := vec2.Bytes()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1.Get(int(i))
			arg2 := col2.Get(int(i))

			{
				var cmpResult int
				cmpResult = bytes.Compare(arg1, arg2)
				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1.Slice(0, int(n))
		colLen := col1.Len()
		_ = projCol[colLen-1]
		_ = col2.Slice(0, colLen-1)
		for i := 0; i < col1.Len(); i++ {
			arg1 := col1.Get(i)
			arg2 := col2.Get(i)

			{
				var cmpResult int
				cmpResult = bytes.Compare(arg1, arg2)
				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEBytesBytesOp) Init() {
	p.input.Init()
}

type projGTBytesBytesConstOp struct {
	OneInputNode

	colIdx   int
	constArg []byte

	outputIdx int
}

func (p projGTBytesBytesConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTBytesBytesConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Bytes()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col.Get(int(i))

			{
				var cmpResult int
				cmpResult = bytes.Compare(arg, p.constArg)
				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col.Slice(0, int(n))
		colLen := col.Len()
		_ = projCol[colLen-1]
		for i := 0; i < col.Len(); i++ {
			arg := col.Get(i)

			{
				var cmpResult int
				cmpResult = bytes.Compare(arg, p.constArg)
				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTBytesBytesConstOp) Init() {
	p.input.Init()
}

type projGTBytesConstBytesOp struct {
	OneInputNode

	colIdx   int
	constArg []byte

	outputIdx int
}

func (p projGTBytesConstBytesOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTBytesConstBytesOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Bytes()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col.Get(int(i))

			{
				var cmpResult int
				cmpResult = bytes.Compare(p.constArg, arg)
				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col.Slice(0, int(n))
		colLen := col.Len()
		_ = projCol[colLen-1]
		for i := 0; i < col.Len(); i++ {
			arg := col.Get(i)

			{
				var cmpResult int
				cmpResult = bytes.Compare(p.constArg, arg)
				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTBytesConstBytesOp) Init() {
	p.input.Init()
}

type projGTBytesBytesOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTBytesBytesOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTBytesBytesOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Bytes()
	col2 := vec2.Bytes()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1.Get(int(i))
			arg2 := col2.Get(int(i))

			{
				var cmpResult int
				cmpResult = bytes.Compare(arg1, arg2)
				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1.Slice(0, int(n))
		colLen := col1.Len()
		_ = projCol[colLen-1]
		_ = col2.Slice(0, colLen-1)
		for i := 0; i < col1.Len(); i++ {
			arg1 := col1.Get(i)
			arg2 := col2.Get(i)

			{
				var cmpResult int
				cmpResult = bytes.Compare(arg1, arg2)
				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTBytesBytesOp) Init() {
	p.input.Init()
}

type projGEBytesBytesConstOp struct {
	OneInputNode

	colIdx   int
	constArg []byte

	outputIdx int
}

func (p projGEBytesBytesConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEBytesBytesConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Bytes()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col.Get(int(i))

			{
				var cmpResult int
				cmpResult = bytes.Compare(arg, p.constArg)
				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col.Slice(0, int(n))
		colLen := col.Len()
		_ = projCol[colLen-1]
		for i := 0; i < col.Len(); i++ {
			arg := col.Get(i)

			{
				var cmpResult int
				cmpResult = bytes.Compare(arg, p.constArg)
				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEBytesBytesConstOp) Init() {
	p.input.Init()
}

type projGEBytesConstBytesOp struct {
	OneInputNode

	colIdx   int
	constArg []byte

	outputIdx int
}

func (p projGEBytesConstBytesOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEBytesConstBytesOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Bytes()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col.Get(int(i))

			{
				var cmpResult int
				cmpResult = bytes.Compare(p.constArg, arg)
				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col.Slice(0, int(n))
		colLen := col.Len()
		_ = projCol[colLen-1]
		for i := 0; i < col.Len(); i++ {
			arg := col.Get(i)

			{
				var cmpResult int
				cmpResult = bytes.Compare(p.constArg, arg)
				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEBytesConstBytesOp) Init() {
	p.input.Init()
}

type projGEBytesBytesOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEBytesBytesOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEBytesBytesOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Bytes()
	col2 := vec2.Bytes()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1.Get(int(i))
			arg2 := col2.Get(int(i))

			{
				var cmpResult int
				cmpResult = bytes.Compare(arg1, arg2)
				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1.Slice(0, int(n))
		colLen := col1.Len()
		_ = projCol[colLen-1]
		_ = col2.Slice(0, colLen-1)
		for i := 0; i < col1.Len(); i++ {
			arg1 := col1.Get(i)
			arg2 := col2.Get(i)

			{
				var cmpResult int
				cmpResult = bytes.Compare(arg1, arg2)
				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEBytesBytesOp) Init() {
	p.input.Init()
}

type projPlusDecimalDecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projPlusDecimalDecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Decimal}, coldata.BatchSize)
}

func (p projPlusDecimalDecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]
			if _, err := tree.DecimalCtx.Add(&projCol[i], &arg, &p.constArg); err != nil {
				execerror.NonVectorizedPanic(err)
			}
		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]
			if _, err := tree.DecimalCtx.Add(&projCol[i], &arg, &p.constArg); err != nil {
				execerror.NonVectorizedPanic(err)
			}
		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projPlusDecimalDecimalConstOp) Init() {
	p.input.Init()
}

type projPlusDecimalConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projPlusDecimalConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Decimal}, coldata.BatchSize)
}

func (p projPlusDecimalConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]
			if _, err := tree.DecimalCtx.Add(&projCol[i], &p.constArg, &arg); err != nil {
				execerror.NonVectorizedPanic(err)
			}
		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]
			if _, err := tree.DecimalCtx.Add(&projCol[i], &p.constArg, &arg); err != nil {
				execerror.NonVectorizedPanic(err)
			}
		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projPlusDecimalConstDecimalOp) Init() {
	p.input.Init()
}

type projPlusDecimalDecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projPlusDecimalDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Decimal}, coldata.BatchSize)
}

func (p projPlusDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]
			if _, err := tree.DecimalCtx.Add(&projCol[i], &arg1, &arg2); err != nil {
				execerror.NonVectorizedPanic(err)
			}
		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]
			if _, err := tree.DecimalCtx.Add(&projCol[i], &arg1, &arg2); err != nil {
				execerror.NonVectorizedPanic(err)
			}
		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projPlusDecimalDecimalOp) Init() {
	p.input.Init()
}

type projMinusDecimalDecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projMinusDecimalDecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Decimal}, coldata.BatchSize)
}

func (p projMinusDecimalDecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]
			if _, err := tree.DecimalCtx.Sub(&projCol[i], &arg, &p.constArg); err != nil {
				execerror.NonVectorizedPanic(err)
			}
		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]
			if _, err := tree.DecimalCtx.Sub(&projCol[i], &arg, &p.constArg); err != nil {
				execerror.NonVectorizedPanic(err)
			}
		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projMinusDecimalDecimalConstOp) Init() {
	p.input.Init()
}

type projMinusDecimalConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projMinusDecimalConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Decimal}, coldata.BatchSize)
}

func (p projMinusDecimalConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]
			if _, err := tree.DecimalCtx.Sub(&projCol[i], &p.constArg, &arg); err != nil {
				execerror.NonVectorizedPanic(err)
			}
		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]
			if _, err := tree.DecimalCtx.Sub(&projCol[i], &p.constArg, &arg); err != nil {
				execerror.NonVectorizedPanic(err)
			}
		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projMinusDecimalConstDecimalOp) Init() {
	p.input.Init()
}

type projMinusDecimalDecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projMinusDecimalDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Decimal}, coldata.BatchSize)
}

func (p projMinusDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]
			if _, err := tree.DecimalCtx.Sub(&projCol[i], &arg1, &arg2); err != nil {
				execerror.NonVectorizedPanic(err)
			}
		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]
			if _, err := tree.DecimalCtx.Sub(&projCol[i], &arg1, &arg2); err != nil {
				execerror.NonVectorizedPanic(err)
			}
		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projMinusDecimalDecimalOp) Init() {
	p.input.Init()
}

type projMultDecimalDecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projMultDecimalDecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Decimal}, coldata.BatchSize)
}

func (p projMultDecimalDecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]
			if _, err := tree.DecimalCtx.Mul(&projCol[i], &arg, &p.constArg); err != nil {
				execerror.NonVectorizedPanic(err)
			}
		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]
			if _, err := tree.DecimalCtx.Mul(&projCol[i], &arg, &p.constArg); err != nil {
				execerror.NonVectorizedPanic(err)
			}
		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projMultDecimalDecimalConstOp) Init() {
	p.input.Init()
}

type projMultDecimalConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projMultDecimalConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Decimal}, coldata.BatchSize)
}

func (p projMultDecimalConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]
			if _, err := tree.DecimalCtx.Mul(&projCol[i], &p.constArg, &arg); err != nil {
				execerror.NonVectorizedPanic(err)
			}
		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]
			if _, err := tree.DecimalCtx.Mul(&projCol[i], &p.constArg, &arg); err != nil {
				execerror.NonVectorizedPanic(err)
			}
		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projMultDecimalConstDecimalOp) Init() {
	p.input.Init()
}

type projMultDecimalDecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projMultDecimalDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Decimal}, coldata.BatchSize)
}

func (p projMultDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]
			if _, err := tree.DecimalCtx.Mul(&projCol[i], &arg1, &arg2); err != nil {
				execerror.NonVectorizedPanic(err)
			}
		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]
			if _, err := tree.DecimalCtx.Mul(&projCol[i], &arg1, &arg2); err != nil {
				execerror.NonVectorizedPanic(err)
			}
		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projMultDecimalDecimalOp) Init() {
	p.input.Init()
}

type projDivDecimalDecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projDivDecimalDecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Decimal}, coldata.BatchSize)
}

func (p projDivDecimalDecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]
			if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg, &p.constArg); err != nil {
				execerror.NonVectorizedPanic(err)
			}
		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]
			if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg, &p.constArg); err != nil {
				execerror.NonVectorizedPanic(err)
			}
		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projDivDecimalDecimalConstOp) Init() {
	p.input.Init()
}

type projDivDecimalConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projDivDecimalConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Decimal}, coldata.BatchSize)
}

func (p projDivDecimalConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]
			if _, err := tree.DecimalCtx.Quo(&projCol[i], &p.constArg, &arg); err != nil {
				execerror.NonVectorizedPanic(err)
			}
		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]
			if _, err := tree.DecimalCtx.Quo(&projCol[i], &p.constArg, &arg); err != nil {
				execerror.NonVectorizedPanic(err)
			}
		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projDivDecimalConstDecimalOp) Init() {
	p.input.Init()
}

type projDivDecimalDecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projDivDecimalDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Decimal}, coldata.BatchSize)
}

func (p projDivDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Decimal)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Decimal()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]
			if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, &arg2); err != nil {
				execerror.NonVectorizedPanic(err)
			}
		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]
			if _, err := tree.DecimalCtx.Quo(&projCol[i], &arg1, &arg2); err != nil {
				execerror.NonVectorizedPanic(err)
			}
		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projDivDecimalDecimalOp) Init() {
	p.input.Init()
}

type projEQDecimalDecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projEQDecimalDecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQDecimalDecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int
				cmpResult = tree.CompareDecimals(&arg, &p.constArg)
				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int
				cmpResult = tree.CompareDecimals(&arg, &p.constArg)
				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQDecimalDecimalConstOp) Init() {
	p.input.Init()
}

type projEQDecimalConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projEQDecimalConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQDecimalConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int
				cmpResult = tree.CompareDecimals(&p.constArg, &arg)
				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int
				cmpResult = tree.CompareDecimals(&p.constArg, &arg)
				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQDecimalConstDecimalOp) Init() {
	p.input.Init()
}

type projEQDecimalDecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQDecimalDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int
				cmpResult = tree.CompareDecimals(&arg1, &arg2)
				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int
				cmpResult = tree.CompareDecimals(&arg1, &arg2)
				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQDecimalDecimalOp) Init() {
	p.input.Init()
}

type projNEDecimalDecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projNEDecimalDecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEDecimalDecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int
				cmpResult = tree.CompareDecimals(&arg, &p.constArg)
				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int
				cmpResult = tree.CompareDecimals(&arg, &p.constArg)
				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEDecimalDecimalConstOp) Init() {
	p.input.Init()
}

type projNEDecimalConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projNEDecimalConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEDecimalConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int
				cmpResult = tree.CompareDecimals(&p.constArg, &arg)
				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int
				cmpResult = tree.CompareDecimals(&p.constArg, &arg)
				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEDecimalConstDecimalOp) Init() {
	p.input.Init()
}

type projNEDecimalDecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEDecimalDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int
				cmpResult = tree.CompareDecimals(&arg1, &arg2)
				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int
				cmpResult = tree.CompareDecimals(&arg1, &arg2)
				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEDecimalDecimalOp) Init() {
	p.input.Init()
}

type projLTDecimalDecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projLTDecimalDecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTDecimalDecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int
				cmpResult = tree.CompareDecimals(&arg, &p.constArg)
				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int
				cmpResult = tree.CompareDecimals(&arg, &p.constArg)
				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTDecimalDecimalConstOp) Init() {
	p.input.Init()
}

type projLTDecimalConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projLTDecimalConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTDecimalConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int
				cmpResult = tree.CompareDecimals(&p.constArg, &arg)
				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int
				cmpResult = tree.CompareDecimals(&p.constArg, &arg)
				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTDecimalConstDecimalOp) Init() {
	p.input.Init()
}

type projLTDecimalDecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTDecimalDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int
				cmpResult = tree.CompareDecimals(&arg1, &arg2)
				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int
				cmpResult = tree.CompareDecimals(&arg1, &arg2)
				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTDecimalDecimalOp) Init() {
	p.input.Init()
}

type projLEDecimalDecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projLEDecimalDecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEDecimalDecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int
				cmpResult = tree.CompareDecimals(&arg, &p.constArg)
				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int
				cmpResult = tree.CompareDecimals(&arg, &p.constArg)
				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEDecimalDecimalConstOp) Init() {
	p.input.Init()
}

type projLEDecimalConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projLEDecimalConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEDecimalConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int
				cmpResult = tree.CompareDecimals(&p.constArg, &arg)
				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int
				cmpResult = tree.CompareDecimals(&p.constArg, &arg)
				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEDecimalConstDecimalOp) Init() {
	p.input.Init()
}

type projLEDecimalDecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEDecimalDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int
				cmpResult = tree.CompareDecimals(&arg1, &arg2)
				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int
				cmpResult = tree.CompareDecimals(&arg1, &arg2)
				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEDecimalDecimalOp) Init() {
	p.input.Init()
}

type projGTDecimalDecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projGTDecimalDecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTDecimalDecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int
				cmpResult = tree.CompareDecimals(&arg, &p.constArg)
				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int
				cmpResult = tree.CompareDecimals(&arg, &p.constArg)
				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTDecimalDecimalConstOp) Init() {
	p.input.Init()
}

type projGTDecimalConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projGTDecimalConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTDecimalConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int
				cmpResult = tree.CompareDecimals(&p.constArg, &arg)
				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int
				cmpResult = tree.CompareDecimals(&p.constArg, &arg)
				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTDecimalConstDecimalOp) Init() {
	p.input.Init()
}

type projGTDecimalDecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTDecimalDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int
				cmpResult = tree.CompareDecimals(&arg1, &arg2)
				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int
				cmpResult = tree.CompareDecimals(&arg1, &arg2)
				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTDecimalDecimalOp) Init() {
	p.input.Init()
}

type projGEDecimalDecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projGEDecimalDecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEDecimalDecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int
				cmpResult = tree.CompareDecimals(&arg, &p.constArg)
				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int
				cmpResult = tree.CompareDecimals(&arg, &p.constArg)
				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEDecimalDecimalConstOp) Init() {
	p.input.Init()
}

type projGEDecimalConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projGEDecimalConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEDecimalConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int
				cmpResult = tree.CompareDecimals(&p.constArg, &arg)
				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int
				cmpResult = tree.CompareDecimals(&p.constArg, &arg)
				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEDecimalConstDecimalOp) Init() {
	p.input.Init()
}

type projGEDecimalDecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEDecimalDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int
				cmpResult = tree.CompareDecimals(&arg1, &arg2)
				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int
				cmpResult = tree.CompareDecimals(&arg1, &arg2)
				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEDecimalDecimalOp) Init() {
	p.input.Init()
}

type projEQDecimalInt8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projEQDecimalInt8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQDecimalInt8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQDecimalInt8ConstOp) Init() {
	p.input.Init()
}

type projEQDecimalConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projEQDecimalConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQDecimalConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQDecimalConstInt8Op) Init() {
	p.input.Init()
}

type projEQDecimalInt8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQDecimalInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQDecimalInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQDecimalInt8Op) Init() {
	p.input.Init()
}

type projNEDecimalInt8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projNEDecimalInt8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEDecimalInt8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEDecimalInt8ConstOp) Init() {
	p.input.Init()
}

type projNEDecimalConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projNEDecimalConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEDecimalConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEDecimalConstInt8Op) Init() {
	p.input.Init()
}

type projNEDecimalInt8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEDecimalInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEDecimalInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEDecimalInt8Op) Init() {
	p.input.Init()
}

type projLTDecimalInt8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projLTDecimalInt8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTDecimalInt8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTDecimalInt8ConstOp) Init() {
	p.input.Init()
}

type projLTDecimalConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projLTDecimalConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTDecimalConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTDecimalConstInt8Op) Init() {
	p.input.Init()
}

type projLTDecimalInt8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTDecimalInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTDecimalInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTDecimalInt8Op) Init() {
	p.input.Init()
}

type projLEDecimalInt8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projLEDecimalInt8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEDecimalInt8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEDecimalInt8ConstOp) Init() {
	p.input.Init()
}

type projLEDecimalConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projLEDecimalConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEDecimalConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEDecimalConstInt8Op) Init() {
	p.input.Init()
}

type projLEDecimalInt8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEDecimalInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEDecimalInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEDecimalInt8Op) Init() {
	p.input.Init()
}

type projGTDecimalInt8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projGTDecimalInt8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTDecimalInt8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTDecimalInt8ConstOp) Init() {
	p.input.Init()
}

type projGTDecimalConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projGTDecimalConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTDecimalConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTDecimalConstInt8Op) Init() {
	p.input.Init()
}

type projGTDecimalInt8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTDecimalInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTDecimalInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTDecimalInt8Op) Init() {
	p.input.Init()
}

type projGEDecimalInt8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projGEDecimalInt8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEDecimalInt8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEDecimalInt8ConstOp) Init() {
	p.input.Init()
}

type projGEDecimalConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projGEDecimalConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEDecimalConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEDecimalConstInt8Op) Init() {
	p.input.Init()
}

type projGEDecimalInt8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEDecimalInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEDecimalInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEDecimalInt8Op) Init() {
	p.input.Init()
}

type projEQDecimalInt16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projEQDecimalInt16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQDecimalInt16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQDecimalInt16ConstOp) Init() {
	p.input.Init()
}

type projEQDecimalConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projEQDecimalConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQDecimalConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQDecimalConstInt16Op) Init() {
	p.input.Init()
}

type projEQDecimalInt16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQDecimalInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQDecimalInt16Op) Init() {
	p.input.Init()
}

type projNEDecimalInt16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projNEDecimalInt16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEDecimalInt16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEDecimalInt16ConstOp) Init() {
	p.input.Init()
}

type projNEDecimalConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projNEDecimalConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEDecimalConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEDecimalConstInt16Op) Init() {
	p.input.Init()
}

type projNEDecimalInt16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEDecimalInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEDecimalInt16Op) Init() {
	p.input.Init()
}

type projLTDecimalInt16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projLTDecimalInt16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTDecimalInt16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTDecimalInt16ConstOp) Init() {
	p.input.Init()
}

type projLTDecimalConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projLTDecimalConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTDecimalConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTDecimalConstInt16Op) Init() {
	p.input.Init()
}

type projLTDecimalInt16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTDecimalInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTDecimalInt16Op) Init() {
	p.input.Init()
}

type projLEDecimalInt16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projLEDecimalInt16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEDecimalInt16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEDecimalInt16ConstOp) Init() {
	p.input.Init()
}

type projLEDecimalConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projLEDecimalConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEDecimalConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEDecimalConstInt16Op) Init() {
	p.input.Init()
}

type projLEDecimalInt16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEDecimalInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEDecimalInt16Op) Init() {
	p.input.Init()
}

type projGTDecimalInt16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projGTDecimalInt16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTDecimalInt16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTDecimalInt16ConstOp) Init() {
	p.input.Init()
}

type projGTDecimalConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projGTDecimalConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTDecimalConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTDecimalConstInt16Op) Init() {
	p.input.Init()
}

type projGTDecimalInt16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTDecimalInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTDecimalInt16Op) Init() {
	p.input.Init()
}

type projGEDecimalInt16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projGEDecimalInt16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEDecimalInt16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEDecimalInt16ConstOp) Init() {
	p.input.Init()
}

type projGEDecimalConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projGEDecimalConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEDecimalConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEDecimalConstInt16Op) Init() {
	p.input.Init()
}

type projGEDecimalInt16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEDecimalInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEDecimalInt16Op) Init() {
	p.input.Init()
}

type projEQDecimalInt32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projEQDecimalInt32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQDecimalInt32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQDecimalInt32ConstOp) Init() {
	p.input.Init()
}

type projEQDecimalConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projEQDecimalConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQDecimalConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQDecimalConstInt32Op) Init() {
	p.input.Init()
}

type projEQDecimalInt32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQDecimalInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQDecimalInt32Op) Init() {
	p.input.Init()
}

type projNEDecimalInt32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projNEDecimalInt32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEDecimalInt32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEDecimalInt32ConstOp) Init() {
	p.input.Init()
}

type projNEDecimalConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projNEDecimalConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEDecimalConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEDecimalConstInt32Op) Init() {
	p.input.Init()
}

type projNEDecimalInt32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEDecimalInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEDecimalInt32Op) Init() {
	p.input.Init()
}

type projLTDecimalInt32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projLTDecimalInt32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTDecimalInt32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTDecimalInt32ConstOp) Init() {
	p.input.Init()
}

type projLTDecimalConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projLTDecimalConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTDecimalConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTDecimalConstInt32Op) Init() {
	p.input.Init()
}

type projLTDecimalInt32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTDecimalInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTDecimalInt32Op) Init() {
	p.input.Init()
}

type projLEDecimalInt32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projLEDecimalInt32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEDecimalInt32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEDecimalInt32ConstOp) Init() {
	p.input.Init()
}

type projLEDecimalConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projLEDecimalConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEDecimalConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEDecimalConstInt32Op) Init() {
	p.input.Init()
}

type projLEDecimalInt32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEDecimalInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEDecimalInt32Op) Init() {
	p.input.Init()
}

type projGTDecimalInt32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projGTDecimalInt32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTDecimalInt32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTDecimalInt32ConstOp) Init() {
	p.input.Init()
}

type projGTDecimalConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projGTDecimalConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTDecimalConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTDecimalConstInt32Op) Init() {
	p.input.Init()
}

type projGTDecimalInt32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTDecimalInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTDecimalInt32Op) Init() {
	p.input.Init()
}

type projGEDecimalInt32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projGEDecimalInt32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEDecimalInt32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEDecimalInt32ConstOp) Init() {
	p.input.Init()
}

type projGEDecimalConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projGEDecimalConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEDecimalConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEDecimalConstInt32Op) Init() {
	p.input.Init()
}

type projGEDecimalInt32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEDecimalInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEDecimalInt32Op) Init() {
	p.input.Init()
}

type projEQDecimalInt64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projEQDecimalInt64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQDecimalInt64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQDecimalInt64ConstOp) Init() {
	p.input.Init()
}

type projEQDecimalConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projEQDecimalConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQDecimalConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQDecimalConstInt64Op) Init() {
	p.input.Init()
}

type projEQDecimalInt64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQDecimalInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQDecimalInt64Op) Init() {
	p.input.Init()
}

type projNEDecimalInt64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projNEDecimalInt64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEDecimalInt64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEDecimalInt64ConstOp) Init() {
	p.input.Init()
}

type projNEDecimalConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projNEDecimalConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEDecimalConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEDecimalConstInt64Op) Init() {
	p.input.Init()
}

type projNEDecimalInt64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEDecimalInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEDecimalInt64Op) Init() {
	p.input.Init()
}

type projLTDecimalInt64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projLTDecimalInt64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTDecimalInt64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTDecimalInt64ConstOp) Init() {
	p.input.Init()
}

type projLTDecimalConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projLTDecimalConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTDecimalConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTDecimalConstInt64Op) Init() {
	p.input.Init()
}

type projLTDecimalInt64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTDecimalInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTDecimalInt64Op) Init() {
	p.input.Init()
}

type projLEDecimalInt64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projLEDecimalInt64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEDecimalInt64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEDecimalInt64ConstOp) Init() {
	p.input.Init()
}

type projLEDecimalConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projLEDecimalConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEDecimalConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEDecimalConstInt64Op) Init() {
	p.input.Init()
}

type projLEDecimalInt64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEDecimalInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEDecimalInt64Op) Init() {
	p.input.Init()
}

type projGTDecimalInt64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projGTDecimalInt64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTDecimalInt64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTDecimalInt64ConstOp) Init() {
	p.input.Init()
}

type projGTDecimalConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projGTDecimalConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTDecimalConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTDecimalConstInt64Op) Init() {
	p.input.Init()
}

type projGTDecimalInt64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTDecimalInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTDecimalInt64Op) Init() {
	p.input.Init()
}

type projGEDecimalInt64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projGEDecimalInt64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEDecimalInt64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEDecimalInt64ConstOp) Init() {
	p.input.Init()
}

type projGEDecimalConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projGEDecimalConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEDecimalConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEDecimalConstInt64Op) Init() {
	p.input.Init()
}

type projGEDecimalInt64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEDecimalInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg2), 0)
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEDecimalInt64Op) Init() {
	p.input.Init()
}

type projEQDecimalFloat32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projEQDecimalFloat32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQDecimalFloat32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQDecimalFloat32ConstOp) Init() {
	p.input.Init()
}

type projEQDecimalConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projEQDecimalConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQDecimalConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQDecimalConstFloat32Op) Init() {
	p.input.Init()
}

type projEQDecimalFloat32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQDecimalFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQDecimalFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQDecimalFloat32Op) Init() {
	p.input.Init()
}

type projNEDecimalFloat32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projNEDecimalFloat32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEDecimalFloat32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEDecimalFloat32ConstOp) Init() {
	p.input.Init()
}

type projNEDecimalConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projNEDecimalConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEDecimalConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEDecimalConstFloat32Op) Init() {
	p.input.Init()
}

type projNEDecimalFloat32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEDecimalFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEDecimalFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEDecimalFloat32Op) Init() {
	p.input.Init()
}

type projLTDecimalFloat32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projLTDecimalFloat32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTDecimalFloat32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTDecimalFloat32ConstOp) Init() {
	p.input.Init()
}

type projLTDecimalConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projLTDecimalConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTDecimalConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTDecimalConstFloat32Op) Init() {
	p.input.Init()
}

type projLTDecimalFloat32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTDecimalFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTDecimalFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTDecimalFloat32Op) Init() {
	p.input.Init()
}

type projLEDecimalFloat32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projLEDecimalFloat32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEDecimalFloat32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEDecimalFloat32ConstOp) Init() {
	p.input.Init()
}

type projLEDecimalConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projLEDecimalConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEDecimalConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEDecimalConstFloat32Op) Init() {
	p.input.Init()
}

type projLEDecimalFloat32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEDecimalFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEDecimalFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEDecimalFloat32Op) Init() {
	p.input.Init()
}

type projGTDecimalFloat32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projGTDecimalFloat32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTDecimalFloat32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTDecimalFloat32ConstOp) Init() {
	p.input.Init()
}

type projGTDecimalConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projGTDecimalConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTDecimalConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTDecimalConstFloat32Op) Init() {
	p.input.Init()
}

type projGTDecimalFloat32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTDecimalFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTDecimalFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTDecimalFloat32Op) Init() {
	p.input.Init()
}

type projGEDecimalFloat32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projGEDecimalFloat32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEDecimalFloat32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEDecimalFloat32ConstOp) Init() {
	p.input.Init()
}

type projGEDecimalConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projGEDecimalConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEDecimalConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEDecimalConstFloat32Op) Init() {
	p.input.Init()
}

type projGEDecimalFloat32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEDecimalFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEDecimalFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEDecimalFloat32Op) Init() {
	p.input.Init()
}

type projEQDecimalFloat64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projEQDecimalFloat64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQDecimalFloat64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQDecimalFloat64ConstOp) Init() {
	p.input.Init()
}

type projEQDecimalConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projEQDecimalConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQDecimalConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQDecimalConstFloat64Op) Init() {
	p.input.Init()
}

type projEQDecimalFloat64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQDecimalFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQDecimalFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQDecimalFloat64Op) Init() {
	p.input.Init()
}

type projNEDecimalFloat64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projNEDecimalFloat64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEDecimalFloat64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEDecimalFloat64ConstOp) Init() {
	p.input.Init()
}

type projNEDecimalConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projNEDecimalConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEDecimalConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEDecimalConstFloat64Op) Init() {
	p.input.Init()
}

type projNEDecimalFloat64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEDecimalFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEDecimalFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEDecimalFloat64Op) Init() {
	p.input.Init()
}

type projLTDecimalFloat64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projLTDecimalFloat64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTDecimalFloat64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTDecimalFloat64ConstOp) Init() {
	p.input.Init()
}

type projLTDecimalConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projLTDecimalConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTDecimalConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTDecimalConstFloat64Op) Init() {
	p.input.Init()
}

type projLTDecimalFloat64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTDecimalFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTDecimalFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTDecimalFloat64Op) Init() {
	p.input.Init()
}

type projLEDecimalFloat64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projLEDecimalFloat64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEDecimalFloat64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEDecimalFloat64ConstOp) Init() {
	p.input.Init()
}

type projLEDecimalConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projLEDecimalConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEDecimalConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEDecimalConstFloat64Op) Init() {
	p.input.Init()
}

type projLEDecimalFloat64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEDecimalFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEDecimalFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEDecimalFloat64Op) Init() {
	p.input.Init()
}

type projGTDecimalFloat64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projGTDecimalFloat64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTDecimalFloat64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTDecimalFloat64ConstOp) Init() {
	p.input.Init()
}

type projGTDecimalConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projGTDecimalConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTDecimalConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTDecimalConstFloat64Op) Init() {
	p.input.Init()
}

type projGTDecimalFloat64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTDecimalFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTDecimalFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTDecimalFloat64Op) Init() {
	p.input.Init()
}

type projGEDecimalFloat64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projGEDecimalFloat64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEDecimalFloat64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg, tmpDec)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEDecimalFloat64ConstOp) Init() {
	p.input.Init()
}

type projGEDecimalConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projGEDecimalConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEDecimalConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&p.constArg, tmpDec)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEDecimalConstFloat64Op) Init() {
	p.input.Init()
}

type projGEDecimalFloat64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEDecimalFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEDecimalFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Decimal()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(&arg1, tmpDec)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEDecimalFloat64Op) Init() {
	p.input.Init()
}

type projEQInt8DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projEQInt8DecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt8DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt8DecimalConstOp) Init() {
	p.input.Init()
}

type projEQInt8ConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projEQInt8ConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt8ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt8ConstDecimalOp) Init() {
	p.input.Init()
}

type projEQInt8DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQInt8DecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt8DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQInt8DecimalOp) Init() {
	p.input.Init()
}

type projNEInt8DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projNEInt8DecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt8DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt8DecimalConstOp) Init() {
	p.input.Init()
}

type projNEInt8ConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projNEInt8ConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt8ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt8ConstDecimalOp) Init() {
	p.input.Init()
}

type projNEInt8DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEInt8DecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt8DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEInt8DecimalOp) Init() {
	p.input.Init()
}

type projLTInt8DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projLTInt8DecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt8DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt8DecimalConstOp) Init() {
	p.input.Init()
}

type projLTInt8ConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projLTInt8ConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt8ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt8ConstDecimalOp) Init() {
	p.input.Init()
}

type projLTInt8DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTInt8DecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt8DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTInt8DecimalOp) Init() {
	p.input.Init()
}

type projLEInt8DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projLEInt8DecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt8DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt8DecimalConstOp) Init() {
	p.input.Init()
}

type projLEInt8ConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projLEInt8ConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt8ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt8ConstDecimalOp) Init() {
	p.input.Init()
}

type projLEInt8DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEInt8DecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt8DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEInt8DecimalOp) Init() {
	p.input.Init()
}

type projGTInt8DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projGTInt8DecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt8DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt8DecimalConstOp) Init() {
	p.input.Init()
}

type projGTInt8ConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projGTInt8ConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt8ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt8ConstDecimalOp) Init() {
	p.input.Init()
}

type projGTInt8DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTInt8DecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt8DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTInt8DecimalOp) Init() {
	p.input.Init()
}

type projGEInt8DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projGEInt8DecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt8DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt8DecimalConstOp) Init() {
	p.input.Init()
}

type projGEInt8ConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projGEInt8ConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt8ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt8ConstDecimalOp) Init() {
	p.input.Init()
}

type projGEInt8DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEInt8DecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt8DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEInt8DecimalOp) Init() {
	p.input.Init()
}

type projPlusInt8Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projPlusInt8Int8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int8}, coldata.BatchSize)
}

func (p projPlusInt8Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int8)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				result := arg + p.constArg
				if (result < arg) != (p.constArg < 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				result := arg + p.constArg
				if (result < arg) != (p.constArg < 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projPlusInt8Int8ConstOp) Init() {
	p.input.Init()
}

type projPlusInt8ConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projPlusInt8ConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int8}, coldata.BatchSize)
}

func (p projPlusInt8ConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int8)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				result := p.constArg + arg
				if (result < p.constArg) != (arg < 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				result := p.constArg + arg
				if (result < p.constArg) != (arg < 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projPlusInt8ConstInt8Op) Init() {
	p.input.Init()
}

type projPlusInt8Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projPlusInt8Int8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int8}, coldata.BatchSize)
}

func (p projPlusInt8Int8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int8)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int8()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				result := arg1 + arg2
				if (result < arg1) != (arg2 < 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				result := arg1 + arg2
				if (result < arg1) != (arg2 < 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projPlusInt8Int8Op) Init() {
	p.input.Init()
}

type projMinusInt8Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projMinusInt8Int8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int8}, coldata.BatchSize)
}

func (p projMinusInt8Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int8)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				result := arg - p.constArg
				if (result < arg) != (p.constArg > 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				result := arg - p.constArg
				if (result < arg) != (p.constArg > 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projMinusInt8Int8ConstOp) Init() {
	p.input.Init()
}

type projMinusInt8ConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projMinusInt8ConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int8}, coldata.BatchSize)
}

func (p projMinusInt8ConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int8)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				result := p.constArg - arg
				if (result < p.constArg) != (arg > 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				result := p.constArg - arg
				if (result < p.constArg) != (arg > 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projMinusInt8ConstInt8Op) Init() {
	p.input.Init()
}

type projMinusInt8Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projMinusInt8Int8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int8}, coldata.BatchSize)
}

func (p projMinusInt8Int8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int8)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int8()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				result := arg1 - arg2
				if (result < arg1) != (arg2 > 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				result := arg1 - arg2
				if (result < arg1) != (arg2 > 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projMinusInt8Int8Op) Init() {
	p.input.Init()
}

type projMultInt8Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projMultInt8Int8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int8}, coldata.BatchSize)
}

func (p projMultInt8Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int8)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				result := arg * p.constArg
				if arg > 10 || arg < -10 || p.constArg > 10 || p.constArg < -10 {
					if arg != 0 && p.constArg != 0 {
						sameSign := (arg < 0) == (p.constArg < 0)
						if (result < 0) == sameSign {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						} else if result/p.constArg != arg {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
					}
				}
				projCol[i] = result
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				result := arg * p.constArg
				if arg > 10 || arg < -10 || p.constArg > 10 || p.constArg < -10 {
					if arg != 0 && p.constArg != 0 {
						sameSign := (arg < 0) == (p.constArg < 0)
						if (result < 0) == sameSign {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						} else if result/p.constArg != arg {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
					}
				}
				projCol[i] = result
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projMultInt8Int8ConstOp) Init() {
	p.input.Init()
}

type projMultInt8ConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projMultInt8ConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int8}, coldata.BatchSize)
}

func (p projMultInt8ConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int8)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				result := p.constArg * arg
				if p.constArg > 10 || p.constArg < -10 || arg > 10 || arg < -10 {
					if p.constArg != 0 && arg != 0 {
						sameSign := (p.constArg < 0) == (arg < 0)
						if (result < 0) == sameSign {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						} else if result/arg != p.constArg {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
					}
				}
				projCol[i] = result
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				result := p.constArg * arg
				if p.constArg > 10 || p.constArg < -10 || arg > 10 || arg < -10 {
					if p.constArg != 0 && arg != 0 {
						sameSign := (p.constArg < 0) == (arg < 0)
						if (result < 0) == sameSign {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						} else if result/arg != p.constArg {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
					}
				}
				projCol[i] = result
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projMultInt8ConstInt8Op) Init() {
	p.input.Init()
}

type projMultInt8Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projMultInt8Int8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int8}, coldata.BatchSize)
}

func (p projMultInt8Int8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int8)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int8()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				result := arg1 * arg2
				if arg1 > 10 || arg1 < -10 || arg2 > 10 || arg2 < -10 {
					if arg1 != 0 && arg2 != 0 {
						sameSign := (arg1 < 0) == (arg2 < 0)
						if (result < 0) == sameSign {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						} else if result/arg2 != arg1 {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
					}
				}
				projCol[i] = result
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				result := arg1 * arg2
				if arg1 > 10 || arg1 < -10 || arg2 > 10 || arg2 < -10 {
					if arg1 != 0 && arg2 != 0 {
						sameSign := (arg1 < 0) == (arg2 < 0)
						if (result < 0) == sameSign {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						} else if result/arg2 != arg1 {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
					}
				}
				projCol[i] = result
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projMultInt8Int8Op) Init() {
	p.input.Init()
}

type projDivInt8Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projDivInt8Int8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int8}, coldata.BatchSize)
}

func (p projDivInt8Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int8)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				if p.constArg == 0 {
					execerror.NonVectorizedPanic(tree.ErrDivByZero)
				}
				result := arg / p.constArg
				if arg == math.MinInt8 && p.constArg == -1 {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				if p.constArg == 0 {
					execerror.NonVectorizedPanic(tree.ErrDivByZero)
				}
				result := arg / p.constArg
				if arg == math.MinInt8 && p.constArg == -1 {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projDivInt8Int8ConstOp) Init() {
	p.input.Init()
}

type projDivInt8ConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projDivInt8ConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int8}, coldata.BatchSize)
}

func (p projDivInt8ConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int8)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				if arg == 0 {
					execerror.NonVectorizedPanic(tree.ErrDivByZero)
				}
				result := p.constArg / arg
				if p.constArg == math.MinInt8 && arg == -1 {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				if arg == 0 {
					execerror.NonVectorizedPanic(tree.ErrDivByZero)
				}
				result := p.constArg / arg
				if p.constArg == math.MinInt8 && arg == -1 {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projDivInt8ConstInt8Op) Init() {
	p.input.Init()
}

type projDivInt8Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projDivInt8Int8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int8}, coldata.BatchSize)
}

func (p projDivInt8Int8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int8)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int8()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				if arg2 == 0 {
					execerror.NonVectorizedPanic(tree.ErrDivByZero)
				}
				result := arg1 / arg2
				if arg1 == math.MinInt8 && arg2 == -1 {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				if arg2 == 0 {
					execerror.NonVectorizedPanic(tree.ErrDivByZero)
				}
				result := arg1 / arg2
				if arg1 == math.MinInt8 && arg2 == -1 {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projDivInt8Int8Op) Init() {
	p.input.Init()
}

type projEQInt8Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projEQInt8Int8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt8Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt8Int8ConstOp) Init() {
	p.input.Init()
}

type projEQInt8ConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projEQInt8ConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt8ConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt8ConstInt8Op) Init() {
	p.input.Init()
}

type projEQInt8Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQInt8Int8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt8Int8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQInt8Int8Op) Init() {
	p.input.Init()
}

type projNEInt8Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projNEInt8Int8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt8Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt8Int8ConstOp) Init() {
	p.input.Init()
}

type projNEInt8ConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projNEInt8ConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt8ConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt8ConstInt8Op) Init() {
	p.input.Init()
}

type projNEInt8Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEInt8Int8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt8Int8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEInt8Int8Op) Init() {
	p.input.Init()
}

type projLTInt8Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projLTInt8Int8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt8Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt8Int8ConstOp) Init() {
	p.input.Init()
}

type projLTInt8ConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projLTInt8ConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt8ConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt8ConstInt8Op) Init() {
	p.input.Init()
}

type projLTInt8Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTInt8Int8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt8Int8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTInt8Int8Op) Init() {
	p.input.Init()
}

type projLEInt8Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projLEInt8Int8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt8Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt8Int8ConstOp) Init() {
	p.input.Init()
}

type projLEInt8ConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projLEInt8ConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt8ConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt8ConstInt8Op) Init() {
	p.input.Init()
}

type projLEInt8Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEInt8Int8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt8Int8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEInt8Int8Op) Init() {
	p.input.Init()
}

type projGTInt8Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projGTInt8Int8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt8Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt8Int8ConstOp) Init() {
	p.input.Init()
}

type projGTInt8ConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projGTInt8ConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt8ConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt8ConstInt8Op) Init() {
	p.input.Init()
}

type projGTInt8Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTInt8Int8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt8Int8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTInt8Int8Op) Init() {
	p.input.Init()
}

type projGEInt8Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projGEInt8Int8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt8Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt8Int8ConstOp) Init() {
	p.input.Init()
}

type projGEInt8ConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projGEInt8ConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt8ConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt8ConstInt8Op) Init() {
	p.input.Init()
}

type projGEInt8Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEInt8Int8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt8Int8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEInt8Int8Op) Init() {
	p.input.Init()
}

type projEQInt8Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projEQInt8Int16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt8Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt8Int16ConstOp) Init() {
	p.input.Init()
}

type projEQInt8ConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projEQInt8ConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt8ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt8ConstInt16Op) Init() {
	p.input.Init()
}

type projEQInt8Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQInt8Int16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt8Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQInt8Int16Op) Init() {
	p.input.Init()
}

type projNEInt8Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projNEInt8Int16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt8Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt8Int16ConstOp) Init() {
	p.input.Init()
}

type projNEInt8ConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projNEInt8ConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt8ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt8ConstInt16Op) Init() {
	p.input.Init()
}

type projNEInt8Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEInt8Int16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt8Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEInt8Int16Op) Init() {
	p.input.Init()
}

type projLTInt8Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projLTInt8Int16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt8Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt8Int16ConstOp) Init() {
	p.input.Init()
}

type projLTInt8ConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projLTInt8ConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt8ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt8ConstInt16Op) Init() {
	p.input.Init()
}

type projLTInt8Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTInt8Int16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt8Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTInt8Int16Op) Init() {
	p.input.Init()
}

type projLEInt8Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projLEInt8Int16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt8Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt8Int16ConstOp) Init() {
	p.input.Init()
}

type projLEInt8ConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projLEInt8ConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt8ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt8ConstInt16Op) Init() {
	p.input.Init()
}

type projLEInt8Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEInt8Int16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt8Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEInt8Int16Op) Init() {
	p.input.Init()
}

type projGTInt8Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projGTInt8Int16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt8Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt8Int16ConstOp) Init() {
	p.input.Init()
}

type projGTInt8ConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projGTInt8ConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt8ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt8ConstInt16Op) Init() {
	p.input.Init()
}

type projGTInt8Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTInt8Int16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt8Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTInt8Int16Op) Init() {
	p.input.Init()
}

type projGEInt8Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projGEInt8Int16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt8Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt8Int16ConstOp) Init() {
	p.input.Init()
}

type projGEInt8ConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projGEInt8ConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt8ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt8ConstInt16Op) Init() {
	p.input.Init()
}

type projGEInt8Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEInt8Int16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt8Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEInt8Int16Op) Init() {
	p.input.Init()
}

type projEQInt8Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projEQInt8Int32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt8Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt8Int32ConstOp) Init() {
	p.input.Init()
}

type projEQInt8ConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projEQInt8ConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt8ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt8ConstInt32Op) Init() {
	p.input.Init()
}

type projEQInt8Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQInt8Int32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt8Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQInt8Int32Op) Init() {
	p.input.Init()
}

type projNEInt8Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projNEInt8Int32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt8Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt8Int32ConstOp) Init() {
	p.input.Init()
}

type projNEInt8ConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projNEInt8ConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt8ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt8ConstInt32Op) Init() {
	p.input.Init()
}

type projNEInt8Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEInt8Int32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt8Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEInt8Int32Op) Init() {
	p.input.Init()
}

type projLTInt8Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projLTInt8Int32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt8Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt8Int32ConstOp) Init() {
	p.input.Init()
}

type projLTInt8ConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projLTInt8ConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt8ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt8ConstInt32Op) Init() {
	p.input.Init()
}

type projLTInt8Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTInt8Int32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt8Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTInt8Int32Op) Init() {
	p.input.Init()
}

type projLEInt8Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projLEInt8Int32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt8Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt8Int32ConstOp) Init() {
	p.input.Init()
}

type projLEInt8ConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projLEInt8ConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt8ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt8ConstInt32Op) Init() {
	p.input.Init()
}

type projLEInt8Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEInt8Int32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt8Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEInt8Int32Op) Init() {
	p.input.Init()
}

type projGTInt8Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projGTInt8Int32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt8Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt8Int32ConstOp) Init() {
	p.input.Init()
}

type projGTInt8ConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projGTInt8ConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt8ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt8ConstInt32Op) Init() {
	p.input.Init()
}

type projGTInt8Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTInt8Int32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt8Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTInt8Int32Op) Init() {
	p.input.Init()
}

type projGEInt8Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projGEInt8Int32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt8Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt8Int32ConstOp) Init() {
	p.input.Init()
}

type projGEInt8ConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projGEInt8ConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt8ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt8ConstInt32Op) Init() {
	p.input.Init()
}

type projGEInt8Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEInt8Int32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt8Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEInt8Int32Op) Init() {
	p.input.Init()
}

type projEQInt8Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projEQInt8Int64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt8Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt8Int64ConstOp) Init() {
	p.input.Init()
}

type projEQInt8ConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projEQInt8ConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt8ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt8ConstInt64Op) Init() {
	p.input.Init()
}

type projEQInt8Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQInt8Int64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt8Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQInt8Int64Op) Init() {
	p.input.Init()
}

type projNEInt8Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projNEInt8Int64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt8Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt8Int64ConstOp) Init() {
	p.input.Init()
}

type projNEInt8ConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projNEInt8ConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt8ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt8ConstInt64Op) Init() {
	p.input.Init()
}

type projNEInt8Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEInt8Int64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt8Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEInt8Int64Op) Init() {
	p.input.Init()
}

type projLTInt8Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projLTInt8Int64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt8Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt8Int64ConstOp) Init() {
	p.input.Init()
}

type projLTInt8ConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projLTInt8ConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt8ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt8ConstInt64Op) Init() {
	p.input.Init()
}

type projLTInt8Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTInt8Int64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt8Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTInt8Int64Op) Init() {
	p.input.Init()
}

type projLEInt8Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projLEInt8Int64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt8Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt8Int64ConstOp) Init() {
	p.input.Init()
}

type projLEInt8ConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projLEInt8ConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt8ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt8ConstInt64Op) Init() {
	p.input.Init()
}

type projLEInt8Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEInt8Int64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt8Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEInt8Int64Op) Init() {
	p.input.Init()
}

type projGTInt8Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projGTInt8Int64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt8Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt8Int64ConstOp) Init() {
	p.input.Init()
}

type projGTInt8ConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projGTInt8ConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt8ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt8ConstInt64Op) Init() {
	p.input.Init()
}

type projGTInt8Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTInt8Int64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt8Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTInt8Int64Op) Init() {
	p.input.Init()
}

type projGEInt8Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projGEInt8Int64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt8Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt8Int64ConstOp) Init() {
	p.input.Init()
}

type projGEInt8ConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projGEInt8ConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt8ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt8ConstInt64Op) Init() {
	p.input.Init()
}

type projGEInt8Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEInt8Int64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt8Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEInt8Int64Op) Init() {
	p.input.Init()
}

type projEQInt8Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projEQInt8Float32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt8Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt8Float32ConstOp) Init() {
	p.input.Init()
}

type projEQInt8ConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projEQInt8ConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt8ConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt8ConstFloat32Op) Init() {
	p.input.Init()
}

type projEQInt8Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQInt8Float32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt8Float32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQInt8Float32Op) Init() {
	p.input.Init()
}

type projNEInt8Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projNEInt8Float32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt8Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt8Float32ConstOp) Init() {
	p.input.Init()
}

type projNEInt8ConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projNEInt8ConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt8ConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt8ConstFloat32Op) Init() {
	p.input.Init()
}

type projNEInt8Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEInt8Float32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt8Float32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEInt8Float32Op) Init() {
	p.input.Init()
}

type projLTInt8Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projLTInt8Float32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt8Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt8Float32ConstOp) Init() {
	p.input.Init()
}

type projLTInt8ConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projLTInt8ConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt8ConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt8ConstFloat32Op) Init() {
	p.input.Init()
}

type projLTInt8Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTInt8Float32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt8Float32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTInt8Float32Op) Init() {
	p.input.Init()
}

type projLEInt8Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projLEInt8Float32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt8Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt8Float32ConstOp) Init() {
	p.input.Init()
}

type projLEInt8ConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projLEInt8ConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt8ConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt8ConstFloat32Op) Init() {
	p.input.Init()
}

type projLEInt8Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEInt8Float32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt8Float32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEInt8Float32Op) Init() {
	p.input.Init()
}

type projGTInt8Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projGTInt8Float32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt8Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt8Float32ConstOp) Init() {
	p.input.Init()
}

type projGTInt8ConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projGTInt8ConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt8ConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt8ConstFloat32Op) Init() {
	p.input.Init()
}

type projGTInt8Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTInt8Float32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt8Float32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTInt8Float32Op) Init() {
	p.input.Init()
}

type projGEInt8Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projGEInt8Float32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt8Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt8Float32ConstOp) Init() {
	p.input.Init()
}

type projGEInt8ConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projGEInt8ConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt8ConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt8ConstFloat32Op) Init() {
	p.input.Init()
}

type projGEInt8Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEInt8Float32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt8Float32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEInt8Float32Op) Init() {
	p.input.Init()
}

type projEQInt8Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projEQInt8Float64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt8Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt8Float64ConstOp) Init() {
	p.input.Init()
}

type projEQInt8ConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projEQInt8ConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt8ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt8ConstFloat64Op) Init() {
	p.input.Init()
}

type projEQInt8Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQInt8Float64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt8Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQInt8Float64Op) Init() {
	p.input.Init()
}

type projNEInt8Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projNEInt8Float64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt8Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt8Float64ConstOp) Init() {
	p.input.Init()
}

type projNEInt8ConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projNEInt8ConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt8ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt8ConstFloat64Op) Init() {
	p.input.Init()
}

type projNEInt8Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEInt8Float64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt8Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEInt8Float64Op) Init() {
	p.input.Init()
}

type projLTInt8Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projLTInt8Float64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt8Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt8Float64ConstOp) Init() {
	p.input.Init()
}

type projLTInt8ConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projLTInt8ConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt8ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt8ConstFloat64Op) Init() {
	p.input.Init()
}

type projLTInt8Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTInt8Float64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt8Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTInt8Float64Op) Init() {
	p.input.Init()
}

type projLEInt8Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projLEInt8Float64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt8Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt8Float64ConstOp) Init() {
	p.input.Init()
}

type projLEInt8ConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projLEInt8ConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt8ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt8ConstFloat64Op) Init() {
	p.input.Init()
}

type projLEInt8Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEInt8Float64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt8Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEInt8Float64Op) Init() {
	p.input.Init()
}

type projGTInt8Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projGTInt8Float64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt8Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt8Float64ConstOp) Init() {
	p.input.Init()
}

type projGTInt8ConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projGTInt8ConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt8ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt8ConstFloat64Op) Init() {
	p.input.Init()
}

type projGTInt8Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTInt8Float64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt8Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTInt8Float64Op) Init() {
	p.input.Init()
}

type projGEInt8Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projGEInt8Float64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt8Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt8Float64ConstOp) Init() {
	p.input.Init()
}

type projGEInt8ConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projGEInt8ConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt8ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt8ConstFloat64Op) Init() {
	p.input.Init()
}

type projGEInt8Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEInt8Float64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt8Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int8()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEInt8Float64Op) Init() {
	p.input.Init()
}

type projEQInt16DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projEQInt16DecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt16DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt16DecimalConstOp) Init() {
	p.input.Init()
}

type projEQInt16ConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projEQInt16ConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt16ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt16ConstDecimalOp) Init() {
	p.input.Init()
}

type projEQInt16DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQInt16DecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQInt16DecimalOp) Init() {
	p.input.Init()
}

type projNEInt16DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projNEInt16DecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt16DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt16DecimalConstOp) Init() {
	p.input.Init()
}

type projNEInt16ConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projNEInt16ConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt16ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt16ConstDecimalOp) Init() {
	p.input.Init()
}

type projNEInt16DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEInt16DecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEInt16DecimalOp) Init() {
	p.input.Init()
}

type projLTInt16DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projLTInt16DecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt16DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt16DecimalConstOp) Init() {
	p.input.Init()
}

type projLTInt16ConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projLTInt16ConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt16ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt16ConstDecimalOp) Init() {
	p.input.Init()
}

type projLTInt16DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTInt16DecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTInt16DecimalOp) Init() {
	p.input.Init()
}

type projLEInt16DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projLEInt16DecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt16DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt16DecimalConstOp) Init() {
	p.input.Init()
}

type projLEInt16ConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projLEInt16ConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt16ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt16ConstDecimalOp) Init() {
	p.input.Init()
}

type projLEInt16DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEInt16DecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEInt16DecimalOp) Init() {
	p.input.Init()
}

type projGTInt16DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projGTInt16DecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt16DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt16DecimalConstOp) Init() {
	p.input.Init()
}

type projGTInt16ConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projGTInt16ConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt16ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt16ConstDecimalOp) Init() {
	p.input.Init()
}

type projGTInt16DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTInt16DecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTInt16DecimalOp) Init() {
	p.input.Init()
}

type projGEInt16DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projGEInt16DecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt16DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt16DecimalConstOp) Init() {
	p.input.Init()
}

type projGEInt16ConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projGEInt16ConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt16ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt16ConstDecimalOp) Init() {
	p.input.Init()
}

type projGEInt16DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEInt16DecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEInt16DecimalOp) Init() {
	p.input.Init()
}

type projEQInt16Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projEQInt16Int8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt16Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt16Int8ConstOp) Init() {
	p.input.Init()
}

type projEQInt16ConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projEQInt16ConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt16ConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt16ConstInt8Op) Init() {
	p.input.Init()
}

type projEQInt16Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQInt16Int8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt16Int8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQInt16Int8Op) Init() {
	p.input.Init()
}

type projNEInt16Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projNEInt16Int8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt16Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt16Int8ConstOp) Init() {
	p.input.Init()
}

type projNEInt16ConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projNEInt16ConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt16ConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt16ConstInt8Op) Init() {
	p.input.Init()
}

type projNEInt16Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEInt16Int8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt16Int8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEInt16Int8Op) Init() {
	p.input.Init()
}

type projLTInt16Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projLTInt16Int8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt16Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt16Int8ConstOp) Init() {
	p.input.Init()
}

type projLTInt16ConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projLTInt16ConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt16ConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt16ConstInt8Op) Init() {
	p.input.Init()
}

type projLTInt16Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTInt16Int8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt16Int8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTInt16Int8Op) Init() {
	p.input.Init()
}

type projLEInt16Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projLEInt16Int8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt16Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt16Int8ConstOp) Init() {
	p.input.Init()
}

type projLEInt16ConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projLEInt16ConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt16ConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt16ConstInt8Op) Init() {
	p.input.Init()
}

type projLEInt16Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEInt16Int8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt16Int8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEInt16Int8Op) Init() {
	p.input.Init()
}

type projGTInt16Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projGTInt16Int8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt16Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt16Int8ConstOp) Init() {
	p.input.Init()
}

type projGTInt16ConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projGTInt16ConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt16ConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt16ConstInt8Op) Init() {
	p.input.Init()
}

type projGTInt16Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTInt16Int8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt16Int8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTInt16Int8Op) Init() {
	p.input.Init()
}

type projGEInt16Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projGEInt16Int8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt16Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt16Int8ConstOp) Init() {
	p.input.Init()
}

type projGEInt16ConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projGEInt16ConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt16ConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt16ConstInt8Op) Init() {
	p.input.Init()
}

type projGEInt16Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEInt16Int8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt16Int8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEInt16Int8Op) Init() {
	p.input.Init()
}

type projPlusInt16Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projPlusInt16Int16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int16}, coldata.BatchSize)
}

func (p projPlusInt16Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int16)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				result := arg + p.constArg
				if (result < arg) != (p.constArg < 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				result := arg + p.constArg
				if (result < arg) != (p.constArg < 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projPlusInt16Int16ConstOp) Init() {
	p.input.Init()
}

type projPlusInt16ConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projPlusInt16ConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int16}, coldata.BatchSize)
}

func (p projPlusInt16ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int16)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				result := p.constArg + arg
				if (result < p.constArg) != (arg < 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				result := p.constArg + arg
				if (result < p.constArg) != (arg < 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projPlusInt16ConstInt16Op) Init() {
	p.input.Init()
}

type projPlusInt16Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projPlusInt16Int16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int16}, coldata.BatchSize)
}

func (p projPlusInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int16)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int16()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				result := arg1 + arg2
				if (result < arg1) != (arg2 < 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				result := arg1 + arg2
				if (result < arg1) != (arg2 < 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projPlusInt16Int16Op) Init() {
	p.input.Init()
}

type projMinusInt16Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projMinusInt16Int16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int16}, coldata.BatchSize)
}

func (p projMinusInt16Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int16)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				result := arg - p.constArg
				if (result < arg) != (p.constArg > 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				result := arg - p.constArg
				if (result < arg) != (p.constArg > 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projMinusInt16Int16ConstOp) Init() {
	p.input.Init()
}

type projMinusInt16ConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projMinusInt16ConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int16}, coldata.BatchSize)
}

func (p projMinusInt16ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int16)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				result := p.constArg - arg
				if (result < p.constArg) != (arg > 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				result := p.constArg - arg
				if (result < p.constArg) != (arg > 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projMinusInt16ConstInt16Op) Init() {
	p.input.Init()
}

type projMinusInt16Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projMinusInt16Int16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int16}, coldata.BatchSize)
}

func (p projMinusInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int16)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int16()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				result := arg1 - arg2
				if (result < arg1) != (arg2 > 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				result := arg1 - arg2
				if (result < arg1) != (arg2 > 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projMinusInt16Int16Op) Init() {
	p.input.Init()
}

type projMultInt16Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projMultInt16Int16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int16}, coldata.BatchSize)
}

func (p projMultInt16Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int16)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				result := arg * p.constArg
				if arg > math.MaxInt8 || arg < math.MinInt8 || p.constArg > math.MaxInt8 || p.constArg < math.MinInt8 {
					if arg != 0 && p.constArg != 0 {
						sameSign := (arg < 0) == (p.constArg < 0)
						if (result < 0) == sameSign {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						} else if result/p.constArg != arg {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
					}
				}
				projCol[i] = result
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				result := arg * p.constArg
				if arg > math.MaxInt8 || arg < math.MinInt8 || p.constArg > math.MaxInt8 || p.constArg < math.MinInt8 {
					if arg != 0 && p.constArg != 0 {
						sameSign := (arg < 0) == (p.constArg < 0)
						if (result < 0) == sameSign {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						} else if result/p.constArg != arg {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
					}
				}
				projCol[i] = result
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projMultInt16Int16ConstOp) Init() {
	p.input.Init()
}

type projMultInt16ConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projMultInt16ConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int16}, coldata.BatchSize)
}

func (p projMultInt16ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int16)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				result := p.constArg * arg
				if p.constArg > math.MaxInt8 || p.constArg < math.MinInt8 || arg > math.MaxInt8 || arg < math.MinInt8 {
					if p.constArg != 0 && arg != 0 {
						sameSign := (p.constArg < 0) == (arg < 0)
						if (result < 0) == sameSign {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						} else if result/arg != p.constArg {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
					}
				}
				projCol[i] = result
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				result := p.constArg * arg
				if p.constArg > math.MaxInt8 || p.constArg < math.MinInt8 || arg > math.MaxInt8 || arg < math.MinInt8 {
					if p.constArg != 0 && arg != 0 {
						sameSign := (p.constArg < 0) == (arg < 0)
						if (result < 0) == sameSign {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						} else if result/arg != p.constArg {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
					}
				}
				projCol[i] = result
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projMultInt16ConstInt16Op) Init() {
	p.input.Init()
}

type projMultInt16Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projMultInt16Int16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int16}, coldata.BatchSize)
}

func (p projMultInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int16)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int16()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				result := arg1 * arg2
				if arg1 > math.MaxInt8 || arg1 < math.MinInt8 || arg2 > math.MaxInt8 || arg2 < math.MinInt8 {
					if arg1 != 0 && arg2 != 0 {
						sameSign := (arg1 < 0) == (arg2 < 0)
						if (result < 0) == sameSign {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						} else if result/arg2 != arg1 {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
					}
				}
				projCol[i] = result
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				result := arg1 * arg2
				if arg1 > math.MaxInt8 || arg1 < math.MinInt8 || arg2 > math.MaxInt8 || arg2 < math.MinInt8 {
					if arg1 != 0 && arg2 != 0 {
						sameSign := (arg1 < 0) == (arg2 < 0)
						if (result < 0) == sameSign {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						} else if result/arg2 != arg1 {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
					}
				}
				projCol[i] = result
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projMultInt16Int16Op) Init() {
	p.input.Init()
}

type projDivInt16Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projDivInt16Int16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int16}, coldata.BatchSize)
}

func (p projDivInt16Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int16)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				if p.constArg == 0 {
					execerror.NonVectorizedPanic(tree.ErrDivByZero)
				}
				result := arg / p.constArg
				if arg == math.MinInt16 && p.constArg == -1 {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				if p.constArg == 0 {
					execerror.NonVectorizedPanic(tree.ErrDivByZero)
				}
				result := arg / p.constArg
				if arg == math.MinInt16 && p.constArg == -1 {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projDivInt16Int16ConstOp) Init() {
	p.input.Init()
}

type projDivInt16ConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projDivInt16ConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int16}, coldata.BatchSize)
}

func (p projDivInt16ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int16)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				if arg == 0 {
					execerror.NonVectorizedPanic(tree.ErrDivByZero)
				}
				result := p.constArg / arg
				if p.constArg == math.MinInt16 && arg == -1 {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				if arg == 0 {
					execerror.NonVectorizedPanic(tree.ErrDivByZero)
				}
				result := p.constArg / arg
				if p.constArg == math.MinInt16 && arg == -1 {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projDivInt16ConstInt16Op) Init() {
	p.input.Init()
}

type projDivInt16Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projDivInt16Int16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int16}, coldata.BatchSize)
}

func (p projDivInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int16)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int16()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				if arg2 == 0 {
					execerror.NonVectorizedPanic(tree.ErrDivByZero)
				}
				result := arg1 / arg2
				if arg1 == math.MinInt16 && arg2 == -1 {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				if arg2 == 0 {
					execerror.NonVectorizedPanic(tree.ErrDivByZero)
				}
				result := arg1 / arg2
				if arg1 == math.MinInt16 && arg2 == -1 {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projDivInt16Int16Op) Init() {
	p.input.Init()
}

type projEQInt16Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projEQInt16Int16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt16Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt16Int16ConstOp) Init() {
	p.input.Init()
}

type projEQInt16ConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projEQInt16ConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt16ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt16ConstInt16Op) Init() {
	p.input.Init()
}

type projEQInt16Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQInt16Int16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQInt16Int16Op) Init() {
	p.input.Init()
}

type projNEInt16Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projNEInt16Int16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt16Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt16Int16ConstOp) Init() {
	p.input.Init()
}

type projNEInt16ConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projNEInt16ConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt16ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt16ConstInt16Op) Init() {
	p.input.Init()
}

type projNEInt16Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEInt16Int16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEInt16Int16Op) Init() {
	p.input.Init()
}

type projLTInt16Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projLTInt16Int16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt16Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt16Int16ConstOp) Init() {
	p.input.Init()
}

type projLTInt16ConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projLTInt16ConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt16ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt16ConstInt16Op) Init() {
	p.input.Init()
}

type projLTInt16Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTInt16Int16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTInt16Int16Op) Init() {
	p.input.Init()
}

type projLEInt16Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projLEInt16Int16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt16Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt16Int16ConstOp) Init() {
	p.input.Init()
}

type projLEInt16ConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projLEInt16ConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt16ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt16ConstInt16Op) Init() {
	p.input.Init()
}

type projLEInt16Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEInt16Int16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEInt16Int16Op) Init() {
	p.input.Init()
}

type projGTInt16Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projGTInt16Int16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt16Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt16Int16ConstOp) Init() {
	p.input.Init()
}

type projGTInt16ConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projGTInt16ConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt16ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt16ConstInt16Op) Init() {
	p.input.Init()
}

type projGTInt16Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTInt16Int16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTInt16Int16Op) Init() {
	p.input.Init()
}

type projGEInt16Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projGEInt16Int16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt16Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt16Int16ConstOp) Init() {
	p.input.Init()
}

type projGEInt16ConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projGEInt16ConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt16ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt16ConstInt16Op) Init() {
	p.input.Init()
}

type projGEInt16Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEInt16Int16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEInt16Int16Op) Init() {
	p.input.Init()
}

type projEQInt16Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projEQInt16Int32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt16Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt16Int32ConstOp) Init() {
	p.input.Init()
}

type projEQInt16ConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projEQInt16ConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt16ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt16ConstInt32Op) Init() {
	p.input.Init()
}

type projEQInt16Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQInt16Int32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQInt16Int32Op) Init() {
	p.input.Init()
}

type projNEInt16Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projNEInt16Int32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt16Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt16Int32ConstOp) Init() {
	p.input.Init()
}

type projNEInt16ConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projNEInt16ConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt16ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt16ConstInt32Op) Init() {
	p.input.Init()
}

type projNEInt16Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEInt16Int32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEInt16Int32Op) Init() {
	p.input.Init()
}

type projLTInt16Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projLTInt16Int32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt16Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt16Int32ConstOp) Init() {
	p.input.Init()
}

type projLTInt16ConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projLTInt16ConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt16ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt16ConstInt32Op) Init() {
	p.input.Init()
}

type projLTInt16Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTInt16Int32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTInt16Int32Op) Init() {
	p.input.Init()
}

type projLEInt16Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projLEInt16Int32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt16Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt16Int32ConstOp) Init() {
	p.input.Init()
}

type projLEInt16ConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projLEInt16ConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt16ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt16ConstInt32Op) Init() {
	p.input.Init()
}

type projLEInt16Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEInt16Int32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEInt16Int32Op) Init() {
	p.input.Init()
}

type projGTInt16Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projGTInt16Int32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt16Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt16Int32ConstOp) Init() {
	p.input.Init()
}

type projGTInt16ConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projGTInt16ConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt16ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt16ConstInt32Op) Init() {
	p.input.Init()
}

type projGTInt16Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTInt16Int32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTInt16Int32Op) Init() {
	p.input.Init()
}

type projGEInt16Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projGEInt16Int32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt16Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt16Int32ConstOp) Init() {
	p.input.Init()
}

type projGEInt16ConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projGEInt16ConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt16ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt16ConstInt32Op) Init() {
	p.input.Init()
}

type projGEInt16Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEInt16Int32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEInt16Int32Op) Init() {
	p.input.Init()
}

type projEQInt16Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projEQInt16Int64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt16Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt16Int64ConstOp) Init() {
	p.input.Init()
}

type projEQInt16ConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projEQInt16ConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt16ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt16ConstInt64Op) Init() {
	p.input.Init()
}

type projEQInt16Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQInt16Int64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQInt16Int64Op) Init() {
	p.input.Init()
}

type projNEInt16Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projNEInt16Int64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt16Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt16Int64ConstOp) Init() {
	p.input.Init()
}

type projNEInt16ConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projNEInt16ConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt16ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt16ConstInt64Op) Init() {
	p.input.Init()
}

type projNEInt16Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEInt16Int64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEInt16Int64Op) Init() {
	p.input.Init()
}

type projLTInt16Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projLTInt16Int64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt16Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt16Int64ConstOp) Init() {
	p.input.Init()
}

type projLTInt16ConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projLTInt16ConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt16ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt16ConstInt64Op) Init() {
	p.input.Init()
}

type projLTInt16Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTInt16Int64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTInt16Int64Op) Init() {
	p.input.Init()
}

type projLEInt16Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projLEInt16Int64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt16Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt16Int64ConstOp) Init() {
	p.input.Init()
}

type projLEInt16ConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projLEInt16ConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt16ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt16ConstInt64Op) Init() {
	p.input.Init()
}

type projLEInt16Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEInt16Int64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEInt16Int64Op) Init() {
	p.input.Init()
}

type projGTInt16Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projGTInt16Int64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt16Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt16Int64ConstOp) Init() {
	p.input.Init()
}

type projGTInt16ConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projGTInt16ConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt16ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt16ConstInt64Op) Init() {
	p.input.Init()
}

type projGTInt16Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTInt16Int64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTInt16Int64Op) Init() {
	p.input.Init()
}

type projGEInt16Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projGEInt16Int64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt16Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt16Int64ConstOp) Init() {
	p.input.Init()
}

type projGEInt16ConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projGEInt16ConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt16ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt16ConstInt64Op) Init() {
	p.input.Init()
}

type projGEInt16Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEInt16Int64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEInt16Int64Op) Init() {
	p.input.Init()
}

type projEQInt16Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projEQInt16Float32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt16Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt16Float32ConstOp) Init() {
	p.input.Init()
}

type projEQInt16ConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projEQInt16ConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt16ConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt16ConstFloat32Op) Init() {
	p.input.Init()
}

type projEQInt16Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQInt16Float32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt16Float32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQInt16Float32Op) Init() {
	p.input.Init()
}

type projNEInt16Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projNEInt16Float32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt16Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt16Float32ConstOp) Init() {
	p.input.Init()
}

type projNEInt16ConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projNEInt16ConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt16ConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt16ConstFloat32Op) Init() {
	p.input.Init()
}

type projNEInt16Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEInt16Float32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt16Float32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEInt16Float32Op) Init() {
	p.input.Init()
}

type projLTInt16Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projLTInt16Float32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt16Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt16Float32ConstOp) Init() {
	p.input.Init()
}

type projLTInt16ConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projLTInt16ConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt16ConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt16ConstFloat32Op) Init() {
	p.input.Init()
}

type projLTInt16Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTInt16Float32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt16Float32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTInt16Float32Op) Init() {
	p.input.Init()
}

type projLEInt16Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projLEInt16Float32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt16Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt16Float32ConstOp) Init() {
	p.input.Init()
}

type projLEInt16ConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projLEInt16ConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt16ConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt16ConstFloat32Op) Init() {
	p.input.Init()
}

type projLEInt16Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEInt16Float32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt16Float32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEInt16Float32Op) Init() {
	p.input.Init()
}

type projGTInt16Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projGTInt16Float32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt16Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt16Float32ConstOp) Init() {
	p.input.Init()
}

type projGTInt16ConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projGTInt16ConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt16ConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt16ConstFloat32Op) Init() {
	p.input.Init()
}

type projGTInt16Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTInt16Float32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt16Float32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTInt16Float32Op) Init() {
	p.input.Init()
}

type projGEInt16Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projGEInt16Float32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt16Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt16Float32ConstOp) Init() {
	p.input.Init()
}

type projGEInt16ConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projGEInt16ConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt16ConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt16ConstFloat32Op) Init() {
	p.input.Init()
}

type projGEInt16Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEInt16Float32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt16Float32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEInt16Float32Op) Init() {
	p.input.Init()
}

type projEQInt16Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projEQInt16Float64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt16Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt16Float64ConstOp) Init() {
	p.input.Init()
}

type projEQInt16ConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projEQInt16ConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt16ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt16ConstFloat64Op) Init() {
	p.input.Init()
}

type projEQInt16Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQInt16Float64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt16Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQInt16Float64Op) Init() {
	p.input.Init()
}

type projNEInt16Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projNEInt16Float64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt16Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt16Float64ConstOp) Init() {
	p.input.Init()
}

type projNEInt16ConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projNEInt16ConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt16ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt16ConstFloat64Op) Init() {
	p.input.Init()
}

type projNEInt16Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEInt16Float64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt16Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEInt16Float64Op) Init() {
	p.input.Init()
}

type projLTInt16Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projLTInt16Float64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt16Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt16Float64ConstOp) Init() {
	p.input.Init()
}

type projLTInt16ConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projLTInt16ConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt16ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt16ConstFloat64Op) Init() {
	p.input.Init()
}

type projLTInt16Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTInt16Float64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt16Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTInt16Float64Op) Init() {
	p.input.Init()
}

type projLEInt16Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projLEInt16Float64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt16Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt16Float64ConstOp) Init() {
	p.input.Init()
}

type projLEInt16ConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projLEInt16ConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt16ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt16ConstFloat64Op) Init() {
	p.input.Init()
}

type projLEInt16Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEInt16Float64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt16Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEInt16Float64Op) Init() {
	p.input.Init()
}

type projGTInt16Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projGTInt16Float64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt16Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt16Float64ConstOp) Init() {
	p.input.Init()
}

type projGTInt16ConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projGTInt16ConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt16ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt16ConstFloat64Op) Init() {
	p.input.Init()
}

type projGTInt16Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTInt16Float64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt16Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTInt16Float64Op) Init() {
	p.input.Init()
}

type projGEInt16Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projGEInt16Float64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt16Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt16Float64ConstOp) Init() {
	p.input.Init()
}

type projGEInt16ConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projGEInt16ConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt16ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt16ConstFloat64Op) Init() {
	p.input.Init()
}

type projGEInt16Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEInt16Float64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt16Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int16()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEInt16Float64Op) Init() {
	p.input.Init()
}

type projEQInt32DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projEQInt32DecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt32DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt32DecimalConstOp) Init() {
	p.input.Init()
}

type projEQInt32ConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projEQInt32ConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt32ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt32ConstDecimalOp) Init() {
	p.input.Init()
}

type projEQInt32DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQInt32DecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQInt32DecimalOp) Init() {
	p.input.Init()
}

type projNEInt32DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projNEInt32DecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt32DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt32DecimalConstOp) Init() {
	p.input.Init()
}

type projNEInt32ConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projNEInt32ConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt32ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt32ConstDecimalOp) Init() {
	p.input.Init()
}

type projNEInt32DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEInt32DecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEInt32DecimalOp) Init() {
	p.input.Init()
}

type projLTInt32DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projLTInt32DecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt32DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt32DecimalConstOp) Init() {
	p.input.Init()
}

type projLTInt32ConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projLTInt32ConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt32ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt32ConstDecimalOp) Init() {
	p.input.Init()
}

type projLTInt32DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTInt32DecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTInt32DecimalOp) Init() {
	p.input.Init()
}

type projLEInt32DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projLEInt32DecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt32DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt32DecimalConstOp) Init() {
	p.input.Init()
}

type projLEInt32ConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projLEInt32ConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt32ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt32ConstDecimalOp) Init() {
	p.input.Init()
}

type projLEInt32DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEInt32DecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEInt32DecimalOp) Init() {
	p.input.Init()
}

type projGTInt32DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projGTInt32DecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt32DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt32DecimalConstOp) Init() {
	p.input.Init()
}

type projGTInt32ConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projGTInt32ConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt32ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt32ConstDecimalOp) Init() {
	p.input.Init()
}

type projGTInt32DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTInt32DecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTInt32DecimalOp) Init() {
	p.input.Init()
}

type projGEInt32DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projGEInt32DecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt32DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt32DecimalConstOp) Init() {
	p.input.Init()
}

type projGEInt32ConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projGEInt32ConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt32ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt32ConstDecimalOp) Init() {
	p.input.Init()
}

type projGEInt32DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEInt32DecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEInt32DecimalOp) Init() {
	p.input.Init()
}

type projEQInt32Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projEQInt32Int8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt32Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt32Int8ConstOp) Init() {
	p.input.Init()
}

type projEQInt32ConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projEQInt32ConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt32ConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt32ConstInt8Op) Init() {
	p.input.Init()
}

type projEQInt32Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQInt32Int8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt32Int8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQInt32Int8Op) Init() {
	p.input.Init()
}

type projNEInt32Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projNEInt32Int8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt32Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt32Int8ConstOp) Init() {
	p.input.Init()
}

type projNEInt32ConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projNEInt32ConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt32ConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt32ConstInt8Op) Init() {
	p.input.Init()
}

type projNEInt32Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEInt32Int8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt32Int8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEInt32Int8Op) Init() {
	p.input.Init()
}

type projLTInt32Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projLTInt32Int8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt32Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt32Int8ConstOp) Init() {
	p.input.Init()
}

type projLTInt32ConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projLTInt32ConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt32ConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt32ConstInt8Op) Init() {
	p.input.Init()
}

type projLTInt32Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTInt32Int8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt32Int8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTInt32Int8Op) Init() {
	p.input.Init()
}

type projLEInt32Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projLEInt32Int8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt32Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt32Int8ConstOp) Init() {
	p.input.Init()
}

type projLEInt32ConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projLEInt32ConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt32ConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt32ConstInt8Op) Init() {
	p.input.Init()
}

type projLEInt32Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEInt32Int8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt32Int8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEInt32Int8Op) Init() {
	p.input.Init()
}

type projGTInt32Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projGTInt32Int8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt32Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt32Int8ConstOp) Init() {
	p.input.Init()
}

type projGTInt32ConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projGTInt32ConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt32ConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt32ConstInt8Op) Init() {
	p.input.Init()
}

type projGTInt32Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTInt32Int8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt32Int8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTInt32Int8Op) Init() {
	p.input.Init()
}

type projGEInt32Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projGEInt32Int8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt32Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt32Int8ConstOp) Init() {
	p.input.Init()
}

type projGEInt32ConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projGEInt32ConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt32ConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt32ConstInt8Op) Init() {
	p.input.Init()
}

type projGEInt32Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEInt32Int8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt32Int8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEInt32Int8Op) Init() {
	p.input.Init()
}

type projEQInt32Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projEQInt32Int16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt32Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt32Int16ConstOp) Init() {
	p.input.Init()
}

type projEQInt32ConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projEQInt32ConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt32ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt32ConstInt16Op) Init() {
	p.input.Init()
}

type projEQInt32Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQInt32Int16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQInt32Int16Op) Init() {
	p.input.Init()
}

type projNEInt32Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projNEInt32Int16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt32Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt32Int16ConstOp) Init() {
	p.input.Init()
}

type projNEInt32ConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projNEInt32ConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt32ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt32ConstInt16Op) Init() {
	p.input.Init()
}

type projNEInt32Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEInt32Int16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEInt32Int16Op) Init() {
	p.input.Init()
}

type projLTInt32Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projLTInt32Int16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt32Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt32Int16ConstOp) Init() {
	p.input.Init()
}

type projLTInt32ConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projLTInt32ConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt32ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt32ConstInt16Op) Init() {
	p.input.Init()
}

type projLTInt32Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTInt32Int16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTInt32Int16Op) Init() {
	p.input.Init()
}

type projLEInt32Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projLEInt32Int16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt32Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt32Int16ConstOp) Init() {
	p.input.Init()
}

type projLEInt32ConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projLEInt32ConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt32ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt32ConstInt16Op) Init() {
	p.input.Init()
}

type projLEInt32Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEInt32Int16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEInt32Int16Op) Init() {
	p.input.Init()
}

type projGTInt32Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projGTInt32Int16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt32Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt32Int16ConstOp) Init() {
	p.input.Init()
}

type projGTInt32ConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projGTInt32ConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt32ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt32ConstInt16Op) Init() {
	p.input.Init()
}

type projGTInt32Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTInt32Int16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTInt32Int16Op) Init() {
	p.input.Init()
}

type projGEInt32Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projGEInt32Int16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt32Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt32Int16ConstOp) Init() {
	p.input.Init()
}

type projGEInt32ConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projGEInt32ConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt32ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt32ConstInt16Op) Init() {
	p.input.Init()
}

type projGEInt32Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEInt32Int16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEInt32Int16Op) Init() {
	p.input.Init()
}

type projPlusInt32Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projPlusInt32Int32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int32}, coldata.BatchSize)
}

func (p projPlusInt32Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int32)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				result := arg + p.constArg
				if (result < arg) != (p.constArg < 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				result := arg + p.constArg
				if (result < arg) != (p.constArg < 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projPlusInt32Int32ConstOp) Init() {
	p.input.Init()
}

type projPlusInt32ConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projPlusInt32ConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int32}, coldata.BatchSize)
}

func (p projPlusInt32ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int32)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				result := p.constArg + arg
				if (result < p.constArg) != (arg < 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				result := p.constArg + arg
				if (result < p.constArg) != (arg < 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projPlusInt32ConstInt32Op) Init() {
	p.input.Init()
}

type projPlusInt32Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projPlusInt32Int32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int32}, coldata.BatchSize)
}

func (p projPlusInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int32)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int32()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				result := arg1 + arg2
				if (result < arg1) != (arg2 < 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				result := arg1 + arg2
				if (result < arg1) != (arg2 < 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projPlusInt32Int32Op) Init() {
	p.input.Init()
}

type projMinusInt32Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projMinusInt32Int32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int32}, coldata.BatchSize)
}

func (p projMinusInt32Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int32)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				result := arg - p.constArg
				if (result < arg) != (p.constArg > 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				result := arg - p.constArg
				if (result < arg) != (p.constArg > 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projMinusInt32Int32ConstOp) Init() {
	p.input.Init()
}

type projMinusInt32ConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projMinusInt32ConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int32}, coldata.BatchSize)
}

func (p projMinusInt32ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int32)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				result := p.constArg - arg
				if (result < p.constArg) != (arg > 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				result := p.constArg - arg
				if (result < p.constArg) != (arg > 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projMinusInt32ConstInt32Op) Init() {
	p.input.Init()
}

type projMinusInt32Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projMinusInt32Int32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int32}, coldata.BatchSize)
}

func (p projMinusInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int32)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int32()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				result := arg1 - arg2
				if (result < arg1) != (arg2 > 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				result := arg1 - arg2
				if (result < arg1) != (arg2 > 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projMinusInt32Int32Op) Init() {
	p.input.Init()
}

type projMultInt32Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projMultInt32Int32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int32}, coldata.BatchSize)
}

func (p projMultInt32Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int32)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				result := arg * p.constArg
				if arg > math.MaxInt16 || arg < math.MinInt16 || p.constArg > math.MaxInt16 || p.constArg < math.MinInt16 {
					if arg != 0 && p.constArg != 0 {
						sameSign := (arg < 0) == (p.constArg < 0)
						if (result < 0) == sameSign {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						} else if result/p.constArg != arg {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
					}
				}
				projCol[i] = result
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				result := arg * p.constArg
				if arg > math.MaxInt16 || arg < math.MinInt16 || p.constArg > math.MaxInt16 || p.constArg < math.MinInt16 {
					if arg != 0 && p.constArg != 0 {
						sameSign := (arg < 0) == (p.constArg < 0)
						if (result < 0) == sameSign {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						} else if result/p.constArg != arg {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
					}
				}
				projCol[i] = result
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projMultInt32Int32ConstOp) Init() {
	p.input.Init()
}

type projMultInt32ConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projMultInt32ConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int32}, coldata.BatchSize)
}

func (p projMultInt32ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int32)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				result := p.constArg * arg
				if p.constArg > math.MaxInt16 || p.constArg < math.MinInt16 || arg > math.MaxInt16 || arg < math.MinInt16 {
					if p.constArg != 0 && arg != 0 {
						sameSign := (p.constArg < 0) == (arg < 0)
						if (result < 0) == sameSign {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						} else if result/arg != p.constArg {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
					}
				}
				projCol[i] = result
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				result := p.constArg * arg
				if p.constArg > math.MaxInt16 || p.constArg < math.MinInt16 || arg > math.MaxInt16 || arg < math.MinInt16 {
					if p.constArg != 0 && arg != 0 {
						sameSign := (p.constArg < 0) == (arg < 0)
						if (result < 0) == sameSign {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						} else if result/arg != p.constArg {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
					}
				}
				projCol[i] = result
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projMultInt32ConstInt32Op) Init() {
	p.input.Init()
}

type projMultInt32Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projMultInt32Int32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int32}, coldata.BatchSize)
}

func (p projMultInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int32)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int32()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				result := arg1 * arg2
				if arg1 > math.MaxInt16 || arg1 < math.MinInt16 || arg2 > math.MaxInt16 || arg2 < math.MinInt16 {
					if arg1 != 0 && arg2 != 0 {
						sameSign := (arg1 < 0) == (arg2 < 0)
						if (result < 0) == sameSign {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						} else if result/arg2 != arg1 {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
					}
				}
				projCol[i] = result
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				result := arg1 * arg2
				if arg1 > math.MaxInt16 || arg1 < math.MinInt16 || arg2 > math.MaxInt16 || arg2 < math.MinInt16 {
					if arg1 != 0 && arg2 != 0 {
						sameSign := (arg1 < 0) == (arg2 < 0)
						if (result < 0) == sameSign {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						} else if result/arg2 != arg1 {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
					}
				}
				projCol[i] = result
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projMultInt32Int32Op) Init() {
	p.input.Init()
}

type projDivInt32Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projDivInt32Int32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int32}, coldata.BatchSize)
}

func (p projDivInt32Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int32)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				if p.constArg == 0 {
					execerror.NonVectorizedPanic(tree.ErrDivByZero)
				}
				result := arg / p.constArg
				if arg == math.MinInt32 && p.constArg == -1 {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				if p.constArg == 0 {
					execerror.NonVectorizedPanic(tree.ErrDivByZero)
				}
				result := arg / p.constArg
				if arg == math.MinInt32 && p.constArg == -1 {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projDivInt32Int32ConstOp) Init() {
	p.input.Init()
}

type projDivInt32ConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projDivInt32ConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int32}, coldata.BatchSize)
}

func (p projDivInt32ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int32)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				if arg == 0 {
					execerror.NonVectorizedPanic(tree.ErrDivByZero)
				}
				result := p.constArg / arg
				if p.constArg == math.MinInt32 && arg == -1 {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				if arg == 0 {
					execerror.NonVectorizedPanic(tree.ErrDivByZero)
				}
				result := p.constArg / arg
				if p.constArg == math.MinInt32 && arg == -1 {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projDivInt32ConstInt32Op) Init() {
	p.input.Init()
}

type projDivInt32Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projDivInt32Int32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int32}, coldata.BatchSize)
}

func (p projDivInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int32)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int32()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				if arg2 == 0 {
					execerror.NonVectorizedPanic(tree.ErrDivByZero)
				}
				result := arg1 / arg2
				if arg1 == math.MinInt32 && arg2 == -1 {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				if arg2 == 0 {
					execerror.NonVectorizedPanic(tree.ErrDivByZero)
				}
				result := arg1 / arg2
				if arg1 == math.MinInt32 && arg2 == -1 {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projDivInt32Int32Op) Init() {
	p.input.Init()
}

type projEQInt32Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projEQInt32Int32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt32Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt32Int32ConstOp) Init() {
	p.input.Init()
}

type projEQInt32ConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projEQInt32ConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt32ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt32ConstInt32Op) Init() {
	p.input.Init()
}

type projEQInt32Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQInt32Int32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQInt32Int32Op) Init() {
	p.input.Init()
}

type projNEInt32Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projNEInt32Int32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt32Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt32Int32ConstOp) Init() {
	p.input.Init()
}

type projNEInt32ConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projNEInt32ConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt32ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt32ConstInt32Op) Init() {
	p.input.Init()
}

type projNEInt32Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEInt32Int32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEInt32Int32Op) Init() {
	p.input.Init()
}

type projLTInt32Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projLTInt32Int32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt32Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt32Int32ConstOp) Init() {
	p.input.Init()
}

type projLTInt32ConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projLTInt32ConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt32ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt32ConstInt32Op) Init() {
	p.input.Init()
}

type projLTInt32Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTInt32Int32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTInt32Int32Op) Init() {
	p.input.Init()
}

type projLEInt32Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projLEInt32Int32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt32Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt32Int32ConstOp) Init() {
	p.input.Init()
}

type projLEInt32ConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projLEInt32ConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt32ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt32ConstInt32Op) Init() {
	p.input.Init()
}

type projLEInt32Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEInt32Int32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEInt32Int32Op) Init() {
	p.input.Init()
}

type projGTInt32Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projGTInt32Int32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt32Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt32Int32ConstOp) Init() {
	p.input.Init()
}

type projGTInt32ConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projGTInt32ConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt32ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt32ConstInt32Op) Init() {
	p.input.Init()
}

type projGTInt32Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTInt32Int32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTInt32Int32Op) Init() {
	p.input.Init()
}

type projGEInt32Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projGEInt32Int32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt32Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt32Int32ConstOp) Init() {
	p.input.Init()
}

type projGEInt32ConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projGEInt32ConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt32ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt32ConstInt32Op) Init() {
	p.input.Init()
}

type projGEInt32Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEInt32Int32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEInt32Int32Op) Init() {
	p.input.Init()
}

type projEQInt32Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projEQInt32Int64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt32Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt32Int64ConstOp) Init() {
	p.input.Init()
}

type projEQInt32ConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projEQInt32ConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt32ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt32ConstInt64Op) Init() {
	p.input.Init()
}

type projEQInt32Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQInt32Int64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQInt32Int64Op) Init() {
	p.input.Init()
}

type projNEInt32Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projNEInt32Int64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt32Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt32Int64ConstOp) Init() {
	p.input.Init()
}

type projNEInt32ConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projNEInt32ConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt32ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt32ConstInt64Op) Init() {
	p.input.Init()
}

type projNEInt32Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEInt32Int64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEInt32Int64Op) Init() {
	p.input.Init()
}

type projLTInt32Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projLTInt32Int64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt32Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt32Int64ConstOp) Init() {
	p.input.Init()
}

type projLTInt32ConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projLTInt32ConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt32ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt32ConstInt64Op) Init() {
	p.input.Init()
}

type projLTInt32Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTInt32Int64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTInt32Int64Op) Init() {
	p.input.Init()
}

type projLEInt32Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projLEInt32Int64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt32Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt32Int64ConstOp) Init() {
	p.input.Init()
}

type projLEInt32ConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projLEInt32ConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt32ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt32ConstInt64Op) Init() {
	p.input.Init()
}

type projLEInt32Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEInt32Int64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEInt32Int64Op) Init() {
	p.input.Init()
}

type projGTInt32Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projGTInt32Int64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt32Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt32Int64ConstOp) Init() {
	p.input.Init()
}

type projGTInt32ConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projGTInt32ConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt32ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt32ConstInt64Op) Init() {
	p.input.Init()
}

type projGTInt32Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTInt32Int64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTInt32Int64Op) Init() {
	p.input.Init()
}

type projGEInt32Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projGEInt32Int64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt32Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt32Int64ConstOp) Init() {
	p.input.Init()
}

type projGEInt32ConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projGEInt32ConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt32ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt32ConstInt64Op) Init() {
	p.input.Init()
}

type projGEInt32Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEInt32Int64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEInt32Int64Op) Init() {
	p.input.Init()
}

type projEQInt32Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projEQInt32Float32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt32Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt32Float32ConstOp) Init() {
	p.input.Init()
}

type projEQInt32ConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projEQInt32ConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt32ConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt32ConstFloat32Op) Init() {
	p.input.Init()
}

type projEQInt32Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQInt32Float32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt32Float32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQInt32Float32Op) Init() {
	p.input.Init()
}

type projNEInt32Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projNEInt32Float32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt32Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt32Float32ConstOp) Init() {
	p.input.Init()
}

type projNEInt32ConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projNEInt32ConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt32ConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt32ConstFloat32Op) Init() {
	p.input.Init()
}

type projNEInt32Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEInt32Float32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt32Float32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEInt32Float32Op) Init() {
	p.input.Init()
}

type projLTInt32Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projLTInt32Float32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt32Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt32Float32ConstOp) Init() {
	p.input.Init()
}

type projLTInt32ConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projLTInt32ConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt32ConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt32ConstFloat32Op) Init() {
	p.input.Init()
}

type projLTInt32Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTInt32Float32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt32Float32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTInt32Float32Op) Init() {
	p.input.Init()
}

type projLEInt32Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projLEInt32Float32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt32Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt32Float32ConstOp) Init() {
	p.input.Init()
}

type projLEInt32ConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projLEInt32ConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt32ConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt32ConstFloat32Op) Init() {
	p.input.Init()
}

type projLEInt32Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEInt32Float32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt32Float32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEInt32Float32Op) Init() {
	p.input.Init()
}

type projGTInt32Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projGTInt32Float32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt32Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt32Float32ConstOp) Init() {
	p.input.Init()
}

type projGTInt32ConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projGTInt32ConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt32ConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt32ConstFloat32Op) Init() {
	p.input.Init()
}

type projGTInt32Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTInt32Float32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt32Float32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTInt32Float32Op) Init() {
	p.input.Init()
}

type projGEInt32Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projGEInt32Float32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt32Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt32Float32ConstOp) Init() {
	p.input.Init()
}

type projGEInt32ConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projGEInt32ConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt32ConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt32ConstFloat32Op) Init() {
	p.input.Init()
}

type projGEInt32Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEInt32Float32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt32Float32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEInt32Float32Op) Init() {
	p.input.Init()
}

type projEQInt32Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projEQInt32Float64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt32Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt32Float64ConstOp) Init() {
	p.input.Init()
}

type projEQInt32ConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projEQInt32ConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt32ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt32ConstFloat64Op) Init() {
	p.input.Init()
}

type projEQInt32Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQInt32Float64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt32Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQInt32Float64Op) Init() {
	p.input.Init()
}

type projNEInt32Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projNEInt32Float64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt32Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt32Float64ConstOp) Init() {
	p.input.Init()
}

type projNEInt32ConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projNEInt32ConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt32ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt32ConstFloat64Op) Init() {
	p.input.Init()
}

type projNEInt32Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEInt32Float64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt32Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEInt32Float64Op) Init() {
	p.input.Init()
}

type projLTInt32Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projLTInt32Float64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt32Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt32Float64ConstOp) Init() {
	p.input.Init()
}

type projLTInt32ConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projLTInt32ConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt32ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt32ConstFloat64Op) Init() {
	p.input.Init()
}

type projLTInt32Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTInt32Float64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt32Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTInt32Float64Op) Init() {
	p.input.Init()
}

type projLEInt32Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projLEInt32Float64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt32Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt32Float64ConstOp) Init() {
	p.input.Init()
}

type projLEInt32ConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projLEInt32ConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt32ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt32ConstFloat64Op) Init() {
	p.input.Init()
}

type projLEInt32Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEInt32Float64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt32Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEInt32Float64Op) Init() {
	p.input.Init()
}

type projGTInt32Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projGTInt32Float64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt32Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt32Float64ConstOp) Init() {
	p.input.Init()
}

type projGTInt32ConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projGTInt32ConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt32ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt32ConstFloat64Op) Init() {
	p.input.Init()
}

type projGTInt32Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTInt32Float64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt32Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTInt32Float64Op) Init() {
	p.input.Init()
}

type projGEInt32Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projGEInt32Float64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt32Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt32Float64ConstOp) Init() {
	p.input.Init()
}

type projGEInt32ConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projGEInt32ConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt32ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt32ConstFloat64Op) Init() {
	p.input.Init()
}

type projGEInt32Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEInt32Float64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt32Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int32()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEInt32Float64Op) Init() {
	p.input.Init()
}

type projEQInt64DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projEQInt64DecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt64DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt64DecimalConstOp) Init() {
	p.input.Init()
}

type projEQInt64ConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projEQInt64ConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt64ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt64ConstDecimalOp) Init() {
	p.input.Init()
}

type projEQInt64DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQInt64DecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQInt64DecimalOp) Init() {
	p.input.Init()
}

type projNEInt64DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projNEInt64DecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt64DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt64DecimalConstOp) Init() {
	p.input.Init()
}

type projNEInt64ConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projNEInt64ConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt64ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt64ConstDecimalOp) Init() {
	p.input.Init()
}

type projNEInt64DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEInt64DecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEInt64DecimalOp) Init() {
	p.input.Init()
}

type projLTInt64DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projLTInt64DecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt64DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt64DecimalConstOp) Init() {
	p.input.Init()
}

type projLTInt64ConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projLTInt64ConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt64ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt64ConstDecimalOp) Init() {
	p.input.Init()
}

type projLTInt64DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTInt64DecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTInt64DecimalOp) Init() {
	p.input.Init()
}

type projLEInt64DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projLEInt64DecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt64DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt64DecimalConstOp) Init() {
	p.input.Init()
}

type projLEInt64ConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projLEInt64ConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt64ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt64ConstDecimalOp) Init() {
	p.input.Init()
}

type projLEInt64DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEInt64DecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEInt64DecimalOp) Init() {
	p.input.Init()
}

type projGTInt64DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projGTInt64DecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt64DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt64DecimalConstOp) Init() {
	p.input.Init()
}

type projGTInt64ConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projGTInt64ConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt64ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt64ConstDecimalOp) Init() {
	p.input.Init()
}

type projGTInt64DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTInt64DecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTInt64DecimalOp) Init() {
	p.input.Init()
}

type projGEInt64DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projGEInt64DecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt64DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt64DecimalConstOp) Init() {
	p.input.Init()
}

type projGEInt64ConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projGEInt64ConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt64ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(p.constArg), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt64ConstDecimalOp) Init() {
	p.input.Init()
}

type projGEInt64DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEInt64DecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					tmpDec.SetFinite(int64(arg1), 0)
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEInt64DecimalOp) Init() {
	p.input.Init()
}

type projEQInt64Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projEQInt64Int8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt64Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt64Int8ConstOp) Init() {
	p.input.Init()
}

type projEQInt64ConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projEQInt64ConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt64ConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt64ConstInt8Op) Init() {
	p.input.Init()
}

type projEQInt64Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQInt64Int8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt64Int8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQInt64Int8Op) Init() {
	p.input.Init()
}

type projNEInt64Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projNEInt64Int8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt64Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt64Int8ConstOp) Init() {
	p.input.Init()
}

type projNEInt64ConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projNEInt64ConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt64ConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt64ConstInt8Op) Init() {
	p.input.Init()
}

type projNEInt64Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEInt64Int8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt64Int8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEInt64Int8Op) Init() {
	p.input.Init()
}

type projLTInt64Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projLTInt64Int8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt64Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt64Int8ConstOp) Init() {
	p.input.Init()
}

type projLTInt64ConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projLTInt64ConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt64ConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt64ConstInt8Op) Init() {
	p.input.Init()
}

type projLTInt64Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTInt64Int8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt64Int8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTInt64Int8Op) Init() {
	p.input.Init()
}

type projLEInt64Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projLEInt64Int8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt64Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt64Int8ConstOp) Init() {
	p.input.Init()
}

type projLEInt64ConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projLEInt64ConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt64ConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt64ConstInt8Op) Init() {
	p.input.Init()
}

type projLEInt64Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEInt64Int8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt64Int8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEInt64Int8Op) Init() {
	p.input.Init()
}

type projGTInt64Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projGTInt64Int8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt64Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt64Int8ConstOp) Init() {
	p.input.Init()
}

type projGTInt64ConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projGTInt64ConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt64ConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt64ConstInt8Op) Init() {
	p.input.Init()
}

type projGTInt64Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTInt64Int8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt64Int8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTInt64Int8Op) Init() {
	p.input.Init()
}

type projGEInt64Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projGEInt64Int8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt64Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt64Int8ConstOp) Init() {
	p.input.Init()
}

type projGEInt64ConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projGEInt64ConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt64ConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt64ConstInt8Op) Init() {
	p.input.Init()
}

type projGEInt64Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEInt64Int8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt64Int8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEInt64Int8Op) Init() {
	p.input.Init()
}

type projEQInt64Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projEQInt64Int16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt64Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt64Int16ConstOp) Init() {
	p.input.Init()
}

type projEQInt64ConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projEQInt64ConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt64ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt64ConstInt16Op) Init() {
	p.input.Init()
}

type projEQInt64Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQInt64Int16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQInt64Int16Op) Init() {
	p.input.Init()
}

type projNEInt64Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projNEInt64Int16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt64Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt64Int16ConstOp) Init() {
	p.input.Init()
}

type projNEInt64ConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projNEInt64ConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt64ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt64ConstInt16Op) Init() {
	p.input.Init()
}

type projNEInt64Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEInt64Int16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEInt64Int16Op) Init() {
	p.input.Init()
}

type projLTInt64Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projLTInt64Int16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt64Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt64Int16ConstOp) Init() {
	p.input.Init()
}

type projLTInt64ConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projLTInt64ConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt64ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt64ConstInt16Op) Init() {
	p.input.Init()
}

type projLTInt64Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTInt64Int16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTInt64Int16Op) Init() {
	p.input.Init()
}

type projLEInt64Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projLEInt64Int16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt64Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt64Int16ConstOp) Init() {
	p.input.Init()
}

type projLEInt64ConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projLEInt64ConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt64ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt64ConstInt16Op) Init() {
	p.input.Init()
}

type projLEInt64Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEInt64Int16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEInt64Int16Op) Init() {
	p.input.Init()
}

type projGTInt64Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projGTInt64Int16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt64Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt64Int16ConstOp) Init() {
	p.input.Init()
}

type projGTInt64ConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projGTInt64ConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt64ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt64ConstInt16Op) Init() {
	p.input.Init()
}

type projGTInt64Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTInt64Int16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTInt64Int16Op) Init() {
	p.input.Init()
}

type projGEInt64Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projGEInt64Int16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt64Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt64Int16ConstOp) Init() {
	p.input.Init()
}

type projGEInt64ConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projGEInt64ConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt64ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt64ConstInt16Op) Init() {
	p.input.Init()
}

type projGEInt64Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEInt64Int16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEInt64Int16Op) Init() {
	p.input.Init()
}

type projEQInt64Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projEQInt64Int32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt64Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt64Int32ConstOp) Init() {
	p.input.Init()
}

type projEQInt64ConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projEQInt64ConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt64ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt64ConstInt32Op) Init() {
	p.input.Init()
}

type projEQInt64Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQInt64Int32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQInt64Int32Op) Init() {
	p.input.Init()
}

type projNEInt64Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projNEInt64Int32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt64Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt64Int32ConstOp) Init() {
	p.input.Init()
}

type projNEInt64ConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projNEInt64ConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt64ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt64ConstInt32Op) Init() {
	p.input.Init()
}

type projNEInt64Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEInt64Int32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEInt64Int32Op) Init() {
	p.input.Init()
}

type projLTInt64Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projLTInt64Int32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt64Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt64Int32ConstOp) Init() {
	p.input.Init()
}

type projLTInt64ConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projLTInt64ConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt64ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt64ConstInt32Op) Init() {
	p.input.Init()
}

type projLTInt64Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTInt64Int32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTInt64Int32Op) Init() {
	p.input.Init()
}

type projLEInt64Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projLEInt64Int32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt64Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt64Int32ConstOp) Init() {
	p.input.Init()
}

type projLEInt64ConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projLEInt64ConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt64ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt64ConstInt32Op) Init() {
	p.input.Init()
}

type projLEInt64Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEInt64Int32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEInt64Int32Op) Init() {
	p.input.Init()
}

type projGTInt64Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projGTInt64Int32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt64Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt64Int32ConstOp) Init() {
	p.input.Init()
}

type projGTInt64ConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projGTInt64ConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt64ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt64ConstInt32Op) Init() {
	p.input.Init()
}

type projGTInt64Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTInt64Int32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTInt64Int32Op) Init() {
	p.input.Init()
}

type projGEInt64Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projGEInt64Int32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt64Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt64Int32ConstOp) Init() {
	p.input.Init()
}

type projGEInt64ConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projGEInt64ConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt64ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt64ConstInt32Op) Init() {
	p.input.Init()
}

type projGEInt64Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEInt64Int32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEInt64Int32Op) Init() {
	p.input.Init()
}

type projPlusInt64Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projPlusInt64Int64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int64}, coldata.BatchSize)
}

func (p projPlusInt64Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int64)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				result := arg + p.constArg
				if (result < arg) != (p.constArg < 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				result := arg + p.constArg
				if (result < arg) != (p.constArg < 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projPlusInt64Int64ConstOp) Init() {
	p.input.Init()
}

type projPlusInt64ConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projPlusInt64ConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int64}, coldata.BatchSize)
}

func (p projPlusInt64ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int64)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				result := p.constArg + arg
				if (result < p.constArg) != (arg < 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				result := p.constArg + arg
				if (result < p.constArg) != (arg < 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projPlusInt64ConstInt64Op) Init() {
	p.input.Init()
}

type projPlusInt64Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projPlusInt64Int64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int64}, coldata.BatchSize)
}

func (p projPlusInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int64)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				result := arg1 + arg2
				if (result < arg1) != (arg2 < 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				result := arg1 + arg2
				if (result < arg1) != (arg2 < 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projPlusInt64Int64Op) Init() {
	p.input.Init()
}

type projMinusInt64Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projMinusInt64Int64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int64}, coldata.BatchSize)
}

func (p projMinusInt64Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int64)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				result := arg - p.constArg
				if (result < arg) != (p.constArg > 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				result := arg - p.constArg
				if (result < arg) != (p.constArg > 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projMinusInt64Int64ConstOp) Init() {
	p.input.Init()
}

type projMinusInt64ConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projMinusInt64ConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int64}, coldata.BatchSize)
}

func (p projMinusInt64ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int64)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				result := p.constArg - arg
				if (result < p.constArg) != (arg > 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				result := p.constArg - arg
				if (result < p.constArg) != (arg > 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projMinusInt64ConstInt64Op) Init() {
	p.input.Init()
}

type projMinusInt64Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projMinusInt64Int64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int64}, coldata.BatchSize)
}

func (p projMinusInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int64)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				result := arg1 - arg2
				if (result < arg1) != (arg2 > 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				result := arg1 - arg2
				if (result < arg1) != (arg2 > 0) {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projMinusInt64Int64Op) Init() {
	p.input.Init()
}

type projMultInt64Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projMultInt64Int64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int64}, coldata.BatchSize)
}

func (p projMultInt64Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int64)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				result := arg * p.constArg
				if arg > math.MaxInt32 || arg < math.MinInt32 || p.constArg > math.MaxInt32 || p.constArg < math.MinInt32 {
					if arg != 0 && p.constArg != 0 {
						sameSign := (arg < 0) == (p.constArg < 0)
						if (result < 0) == sameSign {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						} else if result/p.constArg != arg {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
					}
				}
				projCol[i] = result
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				result := arg * p.constArg
				if arg > math.MaxInt32 || arg < math.MinInt32 || p.constArg > math.MaxInt32 || p.constArg < math.MinInt32 {
					if arg != 0 && p.constArg != 0 {
						sameSign := (arg < 0) == (p.constArg < 0)
						if (result < 0) == sameSign {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						} else if result/p.constArg != arg {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
					}
				}
				projCol[i] = result
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projMultInt64Int64ConstOp) Init() {
	p.input.Init()
}

type projMultInt64ConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projMultInt64ConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int64}, coldata.BatchSize)
}

func (p projMultInt64ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int64)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				result := p.constArg * arg
				if p.constArg > math.MaxInt32 || p.constArg < math.MinInt32 || arg > math.MaxInt32 || arg < math.MinInt32 {
					if p.constArg != 0 && arg != 0 {
						sameSign := (p.constArg < 0) == (arg < 0)
						if (result < 0) == sameSign {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						} else if result/arg != p.constArg {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
					}
				}
				projCol[i] = result
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				result := p.constArg * arg
				if p.constArg > math.MaxInt32 || p.constArg < math.MinInt32 || arg > math.MaxInt32 || arg < math.MinInt32 {
					if p.constArg != 0 && arg != 0 {
						sameSign := (p.constArg < 0) == (arg < 0)
						if (result < 0) == sameSign {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						} else if result/arg != p.constArg {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
					}
				}
				projCol[i] = result
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projMultInt64ConstInt64Op) Init() {
	p.input.Init()
}

type projMultInt64Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projMultInt64Int64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int64}, coldata.BatchSize)
}

func (p projMultInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int64)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				result := arg1 * arg2
				if arg1 > math.MaxInt32 || arg1 < math.MinInt32 || arg2 > math.MaxInt32 || arg2 < math.MinInt32 {
					if arg1 != 0 && arg2 != 0 {
						sameSign := (arg1 < 0) == (arg2 < 0)
						if (result < 0) == sameSign {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						} else if result/arg2 != arg1 {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
					}
				}
				projCol[i] = result
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				result := arg1 * arg2
				if arg1 > math.MaxInt32 || arg1 < math.MinInt32 || arg2 > math.MaxInt32 || arg2 < math.MinInt32 {
					if arg1 != 0 && arg2 != 0 {
						sameSign := (arg1 < 0) == (arg2 < 0)
						if (result < 0) == sameSign {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						} else if result/arg2 != arg1 {
							execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
						}
					}
				}
				projCol[i] = result
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projMultInt64Int64Op) Init() {
	p.input.Init()
}

type projDivInt64Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projDivInt64Int64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int64}, coldata.BatchSize)
}

func (p projDivInt64Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int64)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				if p.constArg == 0 {
					execerror.NonVectorizedPanic(tree.ErrDivByZero)
				}
				result := arg / p.constArg
				if arg == math.MinInt64 && p.constArg == -1 {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				if p.constArg == 0 {
					execerror.NonVectorizedPanic(tree.ErrDivByZero)
				}
				result := arg / p.constArg
				if arg == math.MinInt64 && p.constArg == -1 {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projDivInt64Int64ConstOp) Init() {
	p.input.Init()
}

type projDivInt64ConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projDivInt64ConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int64}, coldata.BatchSize)
}

func (p projDivInt64ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int64)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				if arg == 0 {
					execerror.NonVectorizedPanic(tree.ErrDivByZero)
				}
				result := p.constArg / arg
				if p.constArg == math.MinInt64 && arg == -1 {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				if arg == 0 {
					execerror.NonVectorizedPanic(tree.ErrDivByZero)
				}
				result := p.constArg / arg
				if p.constArg == math.MinInt64 && arg == -1 {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projDivInt64ConstInt64Op) Init() {
	p.input.Init()
}

type projDivInt64Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projDivInt64Int64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Int64}, coldata.BatchSize)
}

func (p projDivInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Int64)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Int64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				if arg2 == 0 {
					execerror.NonVectorizedPanic(tree.ErrDivByZero)
				}
				result := arg1 / arg2
				if arg1 == math.MinInt64 && arg2 == -1 {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				if arg2 == 0 {
					execerror.NonVectorizedPanic(tree.ErrDivByZero)
				}
				result := arg1 / arg2
				if arg1 == math.MinInt64 && arg2 == -1 {
					execerror.NonVectorizedPanic(tree.ErrIntOutOfRange)
				}
				projCol[i] = result
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projDivInt64Int64Op) Init() {
	p.input.Init()
}

type projEQInt64Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projEQInt64Int64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt64Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt64Int64ConstOp) Init() {
	p.input.Init()
}

type projEQInt64ConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projEQInt64ConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt64ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt64ConstInt64Op) Init() {
	p.input.Init()
}

type projEQInt64Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQInt64Int64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQInt64Int64Op) Init() {
	p.input.Init()
}

type projNEInt64Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projNEInt64Int64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt64Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt64Int64ConstOp) Init() {
	p.input.Init()
}

type projNEInt64ConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projNEInt64ConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt64ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt64ConstInt64Op) Init() {
	p.input.Init()
}

type projNEInt64Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEInt64Int64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEInt64Int64Op) Init() {
	p.input.Init()
}

type projLTInt64Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projLTInt64Int64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt64Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt64Int64ConstOp) Init() {
	p.input.Init()
}

type projLTInt64ConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projLTInt64ConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt64ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt64ConstInt64Op) Init() {
	p.input.Init()
}

type projLTInt64Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTInt64Int64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTInt64Int64Op) Init() {
	p.input.Init()
}

type projLEInt64Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projLEInt64Int64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt64Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt64Int64ConstOp) Init() {
	p.input.Init()
}

type projLEInt64ConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projLEInt64ConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt64ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt64ConstInt64Op) Init() {
	p.input.Init()
}

type projLEInt64Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEInt64Int64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEInt64Int64Op) Init() {
	p.input.Init()
}

type projGTInt64Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projGTInt64Int64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt64Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt64Int64ConstOp) Init() {
	p.input.Init()
}

type projGTInt64ConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projGTInt64ConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt64ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt64ConstInt64Op) Init() {
	p.input.Init()
}

type projGTInt64Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTInt64Int64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTInt64Int64Op) Init() {
	p.input.Init()
}

type projGEInt64Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projGEInt64Int64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt64Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(arg), int64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt64Int64ConstOp) Init() {
	p.input.Init()
}

type projGEInt64ConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projGEInt64ConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt64ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := int64(p.constArg), int64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt64ConstInt64Op) Init() {
	p.input.Init()
}

type projGEInt64Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEInt64Int64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := int64(arg1), int64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else {
						cmpResult = 0
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEInt64Int64Op) Init() {
	p.input.Init()
}

type projEQInt64Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projEQInt64Float32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt64Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt64Float32ConstOp) Init() {
	p.input.Init()
}

type projEQInt64ConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projEQInt64ConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt64ConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt64ConstFloat32Op) Init() {
	p.input.Init()
}

type projEQInt64Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQInt64Float32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt64Float32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQInt64Float32Op) Init() {
	p.input.Init()
}

type projNEInt64Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projNEInt64Float32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt64Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt64Float32ConstOp) Init() {
	p.input.Init()
}

type projNEInt64ConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projNEInt64ConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt64ConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt64ConstFloat32Op) Init() {
	p.input.Init()
}

type projNEInt64Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEInt64Float32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt64Float32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEInt64Float32Op) Init() {
	p.input.Init()
}

type projLTInt64Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projLTInt64Float32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt64Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt64Float32ConstOp) Init() {
	p.input.Init()
}

type projLTInt64ConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projLTInt64ConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt64ConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt64ConstFloat32Op) Init() {
	p.input.Init()
}

type projLTInt64Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTInt64Float32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt64Float32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTInt64Float32Op) Init() {
	p.input.Init()
}

type projLEInt64Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projLEInt64Float32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt64Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt64Float32ConstOp) Init() {
	p.input.Init()
}

type projLEInt64ConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projLEInt64ConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt64ConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt64ConstFloat32Op) Init() {
	p.input.Init()
}

type projLEInt64Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEInt64Float32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt64Float32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEInt64Float32Op) Init() {
	p.input.Init()
}

type projGTInt64Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projGTInt64Float32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt64Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt64Float32ConstOp) Init() {
	p.input.Init()
}

type projGTInt64ConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projGTInt64ConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt64ConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt64ConstFloat32Op) Init() {
	p.input.Init()
}

type projGTInt64Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTInt64Float32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt64Float32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTInt64Float32Op) Init() {
	p.input.Init()
}

type projGEInt64Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projGEInt64Float32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt64Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt64Float32ConstOp) Init() {
	p.input.Init()
}

type projGEInt64ConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projGEInt64ConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt64ConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt64ConstFloat32Op) Init() {
	p.input.Init()
}

type projGEInt64Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEInt64Float32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt64Float32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEInt64Float32Op) Init() {
	p.input.Init()
}

type projEQInt64Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projEQInt64Float64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt64Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt64Float64ConstOp) Init() {
	p.input.Init()
}

type projEQInt64ConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projEQInt64ConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt64ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQInt64ConstFloat64Op) Init() {
	p.input.Init()
}

type projEQInt64Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQInt64Float64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQInt64Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQInt64Float64Op) Init() {
	p.input.Init()
}

type projNEInt64Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projNEInt64Float64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt64Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt64Float64ConstOp) Init() {
	p.input.Init()
}

type projNEInt64ConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projNEInt64ConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt64ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEInt64ConstFloat64Op) Init() {
	p.input.Init()
}

type projNEInt64Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEInt64Float64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEInt64Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEInt64Float64Op) Init() {
	p.input.Init()
}

type projLTInt64Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projLTInt64Float64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt64Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt64Float64ConstOp) Init() {
	p.input.Init()
}

type projLTInt64ConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projLTInt64ConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt64ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTInt64ConstFloat64Op) Init() {
	p.input.Init()
}

type projLTInt64Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTInt64Float64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTInt64Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTInt64Float64Op) Init() {
	p.input.Init()
}

type projLEInt64Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projLEInt64Float64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt64Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt64Float64ConstOp) Init() {
	p.input.Init()
}

type projLEInt64ConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projLEInt64ConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt64ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEInt64ConstFloat64Op) Init() {
	p.input.Init()
}

type projLEInt64Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEInt64Float64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEInt64Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEInt64Float64Op) Init() {
	p.input.Init()
}

type projGTInt64Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projGTInt64Float64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt64Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt64Float64ConstOp) Init() {
	p.input.Init()
}

type projGTInt64ConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projGTInt64ConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt64ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTInt64ConstFloat64Op) Init() {
	p.input.Init()
}

type projGTInt64Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTInt64Float64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTInt64Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTInt64Float64Op) Init() {
	p.input.Init()
}

type projGEInt64Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projGEInt64Float64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt64Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt64Float64ConstOp) Init() {
	p.input.Init()
}

type projGEInt64ConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projGEInt64ConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt64ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEInt64ConstFloat64Op) Init() {
	p.input.Init()
}

type projGEInt64Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEInt64Float64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEInt64Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Int64()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if false {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEInt64Float64Op) Init() {
	p.input.Init()
}

type projEQFloat32DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projEQFloat32DecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat32DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQFloat32DecimalConstOp) Init() {
	p.input.Init()
}

type projEQFloat32ConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projEQFloat32ConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat32ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQFloat32ConstDecimalOp) Init() {
	p.input.Init()
}

type projEQFloat32DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQFloat32DecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat32DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQFloat32DecimalOp) Init() {
	p.input.Init()
}

type projNEFloat32DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projNEFloat32DecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat32DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEFloat32DecimalConstOp) Init() {
	p.input.Init()
}

type projNEFloat32ConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projNEFloat32ConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat32ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEFloat32ConstDecimalOp) Init() {
	p.input.Init()
}

type projNEFloat32DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEFloat32DecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat32DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEFloat32DecimalOp) Init() {
	p.input.Init()
}

type projLTFloat32DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projLTFloat32DecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat32DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTFloat32DecimalConstOp) Init() {
	p.input.Init()
}

type projLTFloat32ConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projLTFloat32ConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat32ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTFloat32ConstDecimalOp) Init() {
	p.input.Init()
}

type projLTFloat32DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTFloat32DecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat32DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTFloat32DecimalOp) Init() {
	p.input.Init()
}

type projLEFloat32DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projLEFloat32DecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat32DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEFloat32DecimalConstOp) Init() {
	p.input.Init()
}

type projLEFloat32ConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projLEFloat32ConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat32ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEFloat32ConstDecimalOp) Init() {
	p.input.Init()
}

type projLEFloat32DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEFloat32DecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat32DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEFloat32DecimalOp) Init() {
	p.input.Init()
}

type projGTFloat32DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projGTFloat32DecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat32DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTFloat32DecimalConstOp) Init() {
	p.input.Init()
}

type projGTFloat32ConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projGTFloat32ConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat32ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTFloat32ConstDecimalOp) Init() {
	p.input.Init()
}

type projGTFloat32DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTFloat32DecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat32DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTFloat32DecimalOp) Init() {
	p.input.Init()
}

type projGEFloat32DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projGEFloat32DecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat32DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEFloat32DecimalConstOp) Init() {
	p.input.Init()
}

type projGEFloat32ConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projGEFloat32ConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat32ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEFloat32ConstDecimalOp) Init() {
	p.input.Init()
}

type projGEFloat32DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEFloat32DecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat32DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEFloat32DecimalOp) Init() {
	p.input.Init()
}

type projEQFloat32Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projEQFloat32Int8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat32Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQFloat32Int8ConstOp) Init() {
	p.input.Init()
}

type projEQFloat32ConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projEQFloat32ConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat32ConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQFloat32ConstInt8Op) Init() {
	p.input.Init()
}

type projEQFloat32Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQFloat32Int8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat32Int8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQFloat32Int8Op) Init() {
	p.input.Init()
}

type projNEFloat32Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projNEFloat32Int8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat32Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEFloat32Int8ConstOp) Init() {
	p.input.Init()
}

type projNEFloat32ConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projNEFloat32ConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat32ConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEFloat32ConstInt8Op) Init() {
	p.input.Init()
}

type projNEFloat32Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEFloat32Int8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat32Int8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEFloat32Int8Op) Init() {
	p.input.Init()
}

type projLTFloat32Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projLTFloat32Int8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat32Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTFloat32Int8ConstOp) Init() {
	p.input.Init()
}

type projLTFloat32ConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projLTFloat32ConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat32ConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTFloat32ConstInt8Op) Init() {
	p.input.Init()
}

type projLTFloat32Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTFloat32Int8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat32Int8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTFloat32Int8Op) Init() {
	p.input.Init()
}

type projLEFloat32Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projLEFloat32Int8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat32Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEFloat32Int8ConstOp) Init() {
	p.input.Init()
}

type projLEFloat32ConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projLEFloat32ConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat32ConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEFloat32ConstInt8Op) Init() {
	p.input.Init()
}

type projLEFloat32Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEFloat32Int8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat32Int8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEFloat32Int8Op) Init() {
	p.input.Init()
}

type projGTFloat32Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projGTFloat32Int8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat32Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTFloat32Int8ConstOp) Init() {
	p.input.Init()
}

type projGTFloat32ConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projGTFloat32ConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat32ConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTFloat32ConstInt8Op) Init() {
	p.input.Init()
}

type projGTFloat32Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTFloat32Int8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat32Int8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTFloat32Int8Op) Init() {
	p.input.Init()
}

type projGEFloat32Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projGEFloat32Int8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat32Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEFloat32Int8ConstOp) Init() {
	p.input.Init()
}

type projGEFloat32ConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projGEFloat32ConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat32ConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEFloat32ConstInt8Op) Init() {
	p.input.Init()
}

type projGEFloat32Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEFloat32Int8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat32Int8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEFloat32Int8Op) Init() {
	p.input.Init()
}

type projEQFloat32Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projEQFloat32Int16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat32Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQFloat32Int16ConstOp) Init() {
	p.input.Init()
}

type projEQFloat32ConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projEQFloat32ConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat32ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQFloat32ConstInt16Op) Init() {
	p.input.Init()
}

type projEQFloat32Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQFloat32Int16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat32Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQFloat32Int16Op) Init() {
	p.input.Init()
}

type projNEFloat32Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projNEFloat32Int16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat32Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEFloat32Int16ConstOp) Init() {
	p.input.Init()
}

type projNEFloat32ConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projNEFloat32ConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat32ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEFloat32ConstInt16Op) Init() {
	p.input.Init()
}

type projNEFloat32Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEFloat32Int16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat32Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEFloat32Int16Op) Init() {
	p.input.Init()
}

type projLTFloat32Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projLTFloat32Int16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat32Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTFloat32Int16ConstOp) Init() {
	p.input.Init()
}

type projLTFloat32ConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projLTFloat32ConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat32ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTFloat32ConstInt16Op) Init() {
	p.input.Init()
}

type projLTFloat32Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTFloat32Int16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat32Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTFloat32Int16Op) Init() {
	p.input.Init()
}

type projLEFloat32Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projLEFloat32Int16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat32Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEFloat32Int16ConstOp) Init() {
	p.input.Init()
}

type projLEFloat32ConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projLEFloat32ConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat32ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEFloat32ConstInt16Op) Init() {
	p.input.Init()
}

type projLEFloat32Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEFloat32Int16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat32Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEFloat32Int16Op) Init() {
	p.input.Init()
}

type projGTFloat32Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projGTFloat32Int16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat32Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTFloat32Int16ConstOp) Init() {
	p.input.Init()
}

type projGTFloat32ConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projGTFloat32ConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat32ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTFloat32ConstInt16Op) Init() {
	p.input.Init()
}

type projGTFloat32Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTFloat32Int16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat32Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTFloat32Int16Op) Init() {
	p.input.Init()
}

type projGEFloat32Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projGEFloat32Int16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat32Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEFloat32Int16ConstOp) Init() {
	p.input.Init()
}

type projGEFloat32ConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projGEFloat32ConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat32ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEFloat32ConstInt16Op) Init() {
	p.input.Init()
}

type projGEFloat32Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEFloat32Int16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat32Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEFloat32Int16Op) Init() {
	p.input.Init()
}

type projEQFloat32Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projEQFloat32Int32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat32Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQFloat32Int32ConstOp) Init() {
	p.input.Init()
}

type projEQFloat32ConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projEQFloat32ConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat32ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQFloat32ConstInt32Op) Init() {
	p.input.Init()
}

type projEQFloat32Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQFloat32Int32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat32Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQFloat32Int32Op) Init() {
	p.input.Init()
}

type projNEFloat32Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projNEFloat32Int32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat32Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEFloat32Int32ConstOp) Init() {
	p.input.Init()
}

type projNEFloat32ConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projNEFloat32ConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat32ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEFloat32ConstInt32Op) Init() {
	p.input.Init()
}

type projNEFloat32Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEFloat32Int32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat32Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEFloat32Int32Op) Init() {
	p.input.Init()
}

type projLTFloat32Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projLTFloat32Int32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat32Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTFloat32Int32ConstOp) Init() {
	p.input.Init()
}

type projLTFloat32ConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projLTFloat32ConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat32ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTFloat32ConstInt32Op) Init() {
	p.input.Init()
}

type projLTFloat32Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTFloat32Int32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat32Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTFloat32Int32Op) Init() {
	p.input.Init()
}

type projLEFloat32Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projLEFloat32Int32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat32Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEFloat32Int32ConstOp) Init() {
	p.input.Init()
}

type projLEFloat32ConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projLEFloat32ConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat32ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEFloat32ConstInt32Op) Init() {
	p.input.Init()
}

type projLEFloat32Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEFloat32Int32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat32Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEFloat32Int32Op) Init() {
	p.input.Init()
}

type projGTFloat32Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projGTFloat32Int32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat32Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTFloat32Int32ConstOp) Init() {
	p.input.Init()
}

type projGTFloat32ConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projGTFloat32ConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat32ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTFloat32ConstInt32Op) Init() {
	p.input.Init()
}

type projGTFloat32Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTFloat32Int32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat32Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTFloat32Int32Op) Init() {
	p.input.Init()
}

type projGEFloat32Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projGEFloat32Int32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat32Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEFloat32Int32ConstOp) Init() {
	p.input.Init()
}

type projGEFloat32ConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projGEFloat32ConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat32ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEFloat32ConstInt32Op) Init() {
	p.input.Init()
}

type projGEFloat32Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEFloat32Int32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat32Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEFloat32Int32Op) Init() {
	p.input.Init()
}

type projEQFloat32Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projEQFloat32Int64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat32Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQFloat32Int64ConstOp) Init() {
	p.input.Init()
}

type projEQFloat32ConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projEQFloat32ConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat32ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQFloat32ConstInt64Op) Init() {
	p.input.Init()
}

type projEQFloat32Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQFloat32Int64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat32Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQFloat32Int64Op) Init() {
	p.input.Init()
}

type projNEFloat32Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projNEFloat32Int64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat32Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEFloat32Int64ConstOp) Init() {
	p.input.Init()
}

type projNEFloat32ConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projNEFloat32ConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat32ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEFloat32ConstInt64Op) Init() {
	p.input.Init()
}

type projNEFloat32Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEFloat32Int64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat32Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEFloat32Int64Op) Init() {
	p.input.Init()
}

type projLTFloat32Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projLTFloat32Int64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat32Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTFloat32Int64ConstOp) Init() {
	p.input.Init()
}

type projLTFloat32ConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projLTFloat32ConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat32ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTFloat32ConstInt64Op) Init() {
	p.input.Init()
}

type projLTFloat32Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTFloat32Int64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat32Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTFloat32Int64Op) Init() {
	p.input.Init()
}

type projLEFloat32Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projLEFloat32Int64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat32Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEFloat32Int64ConstOp) Init() {
	p.input.Init()
}

type projLEFloat32ConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projLEFloat32ConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat32ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEFloat32ConstInt64Op) Init() {
	p.input.Init()
}

type projLEFloat32Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEFloat32Int64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat32Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEFloat32Int64Op) Init() {
	p.input.Init()
}

type projGTFloat32Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projGTFloat32Int64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat32Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTFloat32Int64ConstOp) Init() {
	p.input.Init()
}

type projGTFloat32ConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projGTFloat32ConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat32ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTFloat32ConstInt64Op) Init() {
	p.input.Init()
}

type projGTFloat32Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTFloat32Int64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat32Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTFloat32Int64Op) Init() {
	p.input.Init()
}

type projGEFloat32Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projGEFloat32Int64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat32Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEFloat32Int64ConstOp) Init() {
	p.input.Init()
}

type projGEFloat32ConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projGEFloat32ConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat32ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEFloat32ConstInt64Op) Init() {
	p.input.Init()
}

type projGEFloat32Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEFloat32Int64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat32Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEFloat32Int64Op) Init() {
	p.input.Init()
}

type projPlusFloat32Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projPlusFloat32Float32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Float32}, coldata.BatchSize)
}

func (p projPlusFloat32Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Float32)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]
			projCol[i] = arg + p.constArg
		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]
			projCol[i] = arg + p.constArg
		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projPlusFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type projPlusFloat32ConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projPlusFloat32ConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Float32}, coldata.BatchSize)
}

func (p projPlusFloat32ConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Float32)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]
			projCol[i] = p.constArg + arg
		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]
			projCol[i] = p.constArg + arg
		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projPlusFloat32ConstFloat32Op) Init() {
	p.input.Init()
}

type projPlusFloat32Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projPlusFloat32Float32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Float32}, coldata.BatchSize)
}

func (p projPlusFloat32Float32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Float32)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Float32()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]
			projCol[i] = arg1 + arg2
		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]
			projCol[i] = arg1 + arg2
		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projPlusFloat32Float32Op) Init() {
	p.input.Init()
}

type projMinusFloat32Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projMinusFloat32Float32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Float32}, coldata.BatchSize)
}

func (p projMinusFloat32Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Float32)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]
			projCol[i] = arg - p.constArg
		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]
			projCol[i] = arg - p.constArg
		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projMinusFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type projMinusFloat32ConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projMinusFloat32ConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Float32}, coldata.BatchSize)
}

func (p projMinusFloat32ConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Float32)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]
			projCol[i] = p.constArg - arg
		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]
			projCol[i] = p.constArg - arg
		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projMinusFloat32ConstFloat32Op) Init() {
	p.input.Init()
}

type projMinusFloat32Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projMinusFloat32Float32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Float32}, coldata.BatchSize)
}

func (p projMinusFloat32Float32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Float32)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Float32()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]
			projCol[i] = arg1 - arg2
		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]
			projCol[i] = arg1 - arg2
		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projMinusFloat32Float32Op) Init() {
	p.input.Init()
}

type projMultFloat32Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projMultFloat32Float32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Float32}, coldata.BatchSize)
}

func (p projMultFloat32Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Float32)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]
			projCol[i] = arg * p.constArg
		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]
			projCol[i] = arg * p.constArg
		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projMultFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type projMultFloat32ConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projMultFloat32ConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Float32}, coldata.BatchSize)
}

func (p projMultFloat32ConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Float32)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]
			projCol[i] = p.constArg * arg
		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]
			projCol[i] = p.constArg * arg
		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projMultFloat32ConstFloat32Op) Init() {
	p.input.Init()
}

type projMultFloat32Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projMultFloat32Float32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Float32}, coldata.BatchSize)
}

func (p projMultFloat32Float32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Float32)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Float32()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]
			projCol[i] = arg1 * arg2
		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]
			projCol[i] = arg1 * arg2
		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projMultFloat32Float32Op) Init() {
	p.input.Init()
}

type projDivFloat32Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projDivFloat32Float32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Float32}, coldata.BatchSize)
}

func (p projDivFloat32Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Float32)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]
			projCol[i] = arg / p.constArg
		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]
			projCol[i] = arg / p.constArg
		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projDivFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type projDivFloat32ConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projDivFloat32ConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Float32}, coldata.BatchSize)
}

func (p projDivFloat32ConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Float32)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]
			projCol[i] = p.constArg / arg
		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]
			projCol[i] = p.constArg / arg
		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projDivFloat32ConstFloat32Op) Init() {
	p.input.Init()
}

type projDivFloat32Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projDivFloat32Float32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Float32}, coldata.BatchSize)
}

func (p projDivFloat32Float32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Float32)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Float32()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]
			projCol[i] = arg1 / arg2
		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]
			projCol[i] = arg1 / arg2
		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projDivFloat32Float32Op) Init() {
	p.input.Init()
}

type projEQFloat32Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projEQFloat32Float32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat32Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type projEQFloat32ConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projEQFloat32ConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat32ConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQFloat32ConstFloat32Op) Init() {
	p.input.Init()
}

type projEQFloat32Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQFloat32Float32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat32Float32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQFloat32Float32Op) Init() {
	p.input.Init()
}

type projNEFloat32Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projNEFloat32Float32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat32Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type projNEFloat32ConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projNEFloat32ConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat32ConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEFloat32ConstFloat32Op) Init() {
	p.input.Init()
}

type projNEFloat32Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEFloat32Float32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat32Float32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEFloat32Float32Op) Init() {
	p.input.Init()
}

type projLTFloat32Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projLTFloat32Float32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat32Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type projLTFloat32ConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projLTFloat32ConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat32ConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTFloat32ConstFloat32Op) Init() {
	p.input.Init()
}

type projLTFloat32Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTFloat32Float32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat32Float32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTFloat32Float32Op) Init() {
	p.input.Init()
}

type projLEFloat32Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projLEFloat32Float32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat32Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type projLEFloat32ConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projLEFloat32ConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat32ConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEFloat32ConstFloat32Op) Init() {
	p.input.Init()
}

type projLEFloat32Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEFloat32Float32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat32Float32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEFloat32Float32Op) Init() {
	p.input.Init()
}

type projGTFloat32Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projGTFloat32Float32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat32Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type projGTFloat32ConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projGTFloat32ConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat32ConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTFloat32ConstFloat32Op) Init() {
	p.input.Init()
}

type projGTFloat32Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTFloat32Float32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat32Float32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTFloat32Float32Op) Init() {
	p.input.Init()
}

type projGEFloat32Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projGEFloat32Float32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat32Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type projGEFloat32ConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projGEFloat32ConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat32ConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEFloat32ConstFloat32Op) Init() {
	p.input.Init()
}

type projGEFloat32Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEFloat32Float32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat32Float32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEFloat32Float32Op) Init() {
	p.input.Init()
}

type projEQFloat32Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projEQFloat32Float64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat32Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQFloat32Float64ConstOp) Init() {
	p.input.Init()
}

type projEQFloat32ConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projEQFloat32ConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat32ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQFloat32ConstFloat64Op) Init() {
	p.input.Init()
}

type projEQFloat32Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQFloat32Float64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat32Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQFloat32Float64Op) Init() {
	p.input.Init()
}

type projNEFloat32Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projNEFloat32Float64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat32Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEFloat32Float64ConstOp) Init() {
	p.input.Init()
}

type projNEFloat32ConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projNEFloat32ConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat32ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEFloat32ConstFloat64Op) Init() {
	p.input.Init()
}

type projNEFloat32Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEFloat32Float64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat32Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEFloat32Float64Op) Init() {
	p.input.Init()
}

type projLTFloat32Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projLTFloat32Float64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat32Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTFloat32Float64ConstOp) Init() {
	p.input.Init()
}

type projLTFloat32ConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projLTFloat32ConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat32ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTFloat32ConstFloat64Op) Init() {
	p.input.Init()
}

type projLTFloat32Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTFloat32Float64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat32Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTFloat32Float64Op) Init() {
	p.input.Init()
}

type projLEFloat32Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projLEFloat32Float64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat32Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEFloat32Float64ConstOp) Init() {
	p.input.Init()
}

type projLEFloat32ConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projLEFloat32ConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat32ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEFloat32ConstFloat64Op) Init() {
	p.input.Init()
}

type projLEFloat32Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEFloat32Float64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat32Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEFloat32Float64Op) Init() {
	p.input.Init()
}

type projGTFloat32Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projGTFloat32Float64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat32Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTFloat32Float64ConstOp) Init() {
	p.input.Init()
}

type projGTFloat32ConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projGTFloat32ConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat32ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTFloat32ConstFloat64Op) Init() {
	p.input.Init()
}

type projGTFloat32Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTFloat32Float64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat32Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTFloat32Float64Op) Init() {
	p.input.Init()
}

type projGEFloat32Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projGEFloat32Float64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat32Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEFloat32Float64ConstOp) Init() {
	p.input.Init()
}

type projGEFloat32ConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projGEFloat32ConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat32ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEFloat32ConstFloat64Op) Init() {
	p.input.Init()
}

type projGEFloat32Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEFloat32Float64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat32Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float32()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEFloat32Float64Op) Init() {
	p.input.Init()
}

type projEQFloat64DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projEQFloat64DecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat64DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQFloat64DecimalConstOp) Init() {
	p.input.Init()
}

type projEQFloat64ConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projEQFloat64ConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat64ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQFloat64ConstDecimalOp) Init() {
	p.input.Init()
}

type projEQFloat64DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQFloat64DecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat64DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQFloat64DecimalOp) Init() {
	p.input.Init()
}

type projNEFloat64DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projNEFloat64DecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat64DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEFloat64DecimalConstOp) Init() {
	p.input.Init()
}

type projNEFloat64ConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projNEFloat64ConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat64ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEFloat64ConstDecimalOp) Init() {
	p.input.Init()
}

type projNEFloat64DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEFloat64DecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat64DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEFloat64DecimalOp) Init() {
	p.input.Init()
}

type projLTFloat64DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projLTFloat64DecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat64DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTFloat64DecimalConstOp) Init() {
	p.input.Init()
}

type projLTFloat64ConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projLTFloat64ConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat64ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTFloat64ConstDecimalOp) Init() {
	p.input.Init()
}

type projLTFloat64DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTFloat64DecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat64DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTFloat64DecimalOp) Init() {
	p.input.Init()
}

type projLEFloat64DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projLEFloat64DecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat64DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEFloat64DecimalConstOp) Init() {
	p.input.Init()
}

type projLEFloat64ConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projLEFloat64ConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat64ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEFloat64ConstDecimalOp) Init() {
	p.input.Init()
}

type projLEFloat64DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEFloat64DecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat64DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEFloat64DecimalOp) Init() {
	p.input.Init()
}

type projGTFloat64DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projGTFloat64DecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat64DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTFloat64DecimalConstOp) Init() {
	p.input.Init()
}

type projGTFloat64ConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projGTFloat64ConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat64ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTFloat64ConstDecimalOp) Init() {
	p.input.Init()
}

type projGTFloat64DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTFloat64DecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat64DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTFloat64DecimalOp) Init() {
	p.input.Init()
}

type projGEFloat64DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p projGEFloat64DecimalConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat64DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEFloat64DecimalConstOp) Init() {
	p.input.Init()
}

type projGEFloat64ConstDecimalOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projGEFloat64ConstDecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat64ConstDecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Decimal()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEFloat64ConstDecimalOp) Init() {
	p.input.Init()
}

type projGEFloat64DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEFloat64DecimalOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat64DecimalOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Decimal()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					tmpDec := &apd.Decimal{}
					if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
						execerror.NonVectorizedPanic(err)
					}
					cmpResult = tree.CompareDecimals(tmpDec, &arg2)
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEFloat64DecimalOp) Init() {
	p.input.Init()
}

type projEQFloat64Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projEQFloat64Int8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat64Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQFloat64Int8ConstOp) Init() {
	p.input.Init()
}

type projEQFloat64ConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projEQFloat64ConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat64ConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQFloat64ConstInt8Op) Init() {
	p.input.Init()
}

type projEQFloat64Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQFloat64Int8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat64Int8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQFloat64Int8Op) Init() {
	p.input.Init()
}

type projNEFloat64Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projNEFloat64Int8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat64Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEFloat64Int8ConstOp) Init() {
	p.input.Init()
}

type projNEFloat64ConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projNEFloat64ConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat64ConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEFloat64ConstInt8Op) Init() {
	p.input.Init()
}

type projNEFloat64Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEFloat64Int8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat64Int8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEFloat64Int8Op) Init() {
	p.input.Init()
}

type projLTFloat64Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projLTFloat64Int8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat64Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTFloat64Int8ConstOp) Init() {
	p.input.Init()
}

type projLTFloat64ConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projLTFloat64ConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat64ConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTFloat64ConstInt8Op) Init() {
	p.input.Init()
}

type projLTFloat64Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTFloat64Int8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat64Int8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTFloat64Int8Op) Init() {
	p.input.Init()
}

type projLEFloat64Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projLEFloat64Int8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat64Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEFloat64Int8ConstOp) Init() {
	p.input.Init()
}

type projLEFloat64ConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projLEFloat64ConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat64ConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEFloat64ConstInt8Op) Init() {
	p.input.Init()
}

type projLEFloat64Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEFloat64Int8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat64Int8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEFloat64Int8Op) Init() {
	p.input.Init()
}

type projGTFloat64Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projGTFloat64Int8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat64Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTFloat64Int8ConstOp) Init() {
	p.input.Init()
}

type projGTFloat64ConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projGTFloat64ConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat64ConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTFloat64ConstInt8Op) Init() {
	p.input.Init()
}

type projGTFloat64Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTFloat64Int8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat64Int8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTFloat64Int8Op) Init() {
	p.input.Init()
}

type projGEFloat64Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8

	outputIdx int
}

func (p projGEFloat64Int8ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat64Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEFloat64Int8ConstOp) Init() {
	p.input.Init()
}

type projGEFloat64ConstInt8Op struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projGEFloat64ConstInt8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat64ConstInt8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int8()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEFloat64ConstInt8Op) Init() {
	p.input.Init()
}

type projGEFloat64Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEFloat64Int8Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat64Int8Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int8()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEFloat64Int8Op) Init() {
	p.input.Init()
}

type projEQFloat64Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projEQFloat64Int16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat64Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQFloat64Int16ConstOp) Init() {
	p.input.Init()
}

type projEQFloat64ConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projEQFloat64ConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat64ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQFloat64ConstInt16Op) Init() {
	p.input.Init()
}

type projEQFloat64Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQFloat64Int16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat64Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQFloat64Int16Op) Init() {
	p.input.Init()
}

type projNEFloat64Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projNEFloat64Int16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat64Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEFloat64Int16ConstOp) Init() {
	p.input.Init()
}

type projNEFloat64ConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projNEFloat64ConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat64ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEFloat64ConstInt16Op) Init() {
	p.input.Init()
}

type projNEFloat64Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEFloat64Int16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat64Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEFloat64Int16Op) Init() {
	p.input.Init()
}

type projLTFloat64Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projLTFloat64Int16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat64Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTFloat64Int16ConstOp) Init() {
	p.input.Init()
}

type projLTFloat64ConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projLTFloat64ConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat64ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTFloat64ConstInt16Op) Init() {
	p.input.Init()
}

type projLTFloat64Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTFloat64Int16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat64Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTFloat64Int16Op) Init() {
	p.input.Init()
}

type projLEFloat64Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projLEFloat64Int16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat64Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEFloat64Int16ConstOp) Init() {
	p.input.Init()
}

type projLEFloat64ConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projLEFloat64ConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat64ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEFloat64ConstInt16Op) Init() {
	p.input.Init()
}

type projLEFloat64Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEFloat64Int16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat64Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEFloat64Int16Op) Init() {
	p.input.Init()
}

type projGTFloat64Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projGTFloat64Int16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat64Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTFloat64Int16ConstOp) Init() {
	p.input.Init()
}

type projGTFloat64ConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projGTFloat64ConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat64ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTFloat64ConstInt16Op) Init() {
	p.input.Init()
}

type projGTFloat64Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTFloat64Int16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat64Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTFloat64Int16Op) Init() {
	p.input.Init()
}

type projGEFloat64Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16

	outputIdx int
}

func (p projGEFloat64Int16ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat64Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEFloat64Int16ConstOp) Init() {
	p.input.Init()
}

type projGEFloat64ConstInt16Op struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projGEFloat64ConstInt16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat64ConstInt16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int16()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEFloat64ConstInt16Op) Init() {
	p.input.Init()
}

type projGEFloat64Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEFloat64Int16Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat64Int16Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int16()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEFloat64Int16Op) Init() {
	p.input.Init()
}

type projEQFloat64Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projEQFloat64Int32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat64Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQFloat64Int32ConstOp) Init() {
	p.input.Init()
}

type projEQFloat64ConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projEQFloat64ConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat64ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQFloat64ConstInt32Op) Init() {
	p.input.Init()
}

type projEQFloat64Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQFloat64Int32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat64Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQFloat64Int32Op) Init() {
	p.input.Init()
}

type projNEFloat64Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projNEFloat64Int32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat64Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEFloat64Int32ConstOp) Init() {
	p.input.Init()
}

type projNEFloat64ConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projNEFloat64ConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat64ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEFloat64ConstInt32Op) Init() {
	p.input.Init()
}

type projNEFloat64Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEFloat64Int32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat64Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEFloat64Int32Op) Init() {
	p.input.Init()
}

type projLTFloat64Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projLTFloat64Int32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat64Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTFloat64Int32ConstOp) Init() {
	p.input.Init()
}

type projLTFloat64ConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projLTFloat64ConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat64ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTFloat64ConstInt32Op) Init() {
	p.input.Init()
}

type projLTFloat64Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTFloat64Int32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat64Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTFloat64Int32Op) Init() {
	p.input.Init()
}

type projLEFloat64Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projLEFloat64Int32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat64Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEFloat64Int32ConstOp) Init() {
	p.input.Init()
}

type projLEFloat64ConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projLEFloat64ConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat64ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEFloat64ConstInt32Op) Init() {
	p.input.Init()
}

type projLEFloat64Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEFloat64Int32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat64Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEFloat64Int32Op) Init() {
	p.input.Init()
}

type projGTFloat64Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projGTFloat64Int32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat64Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTFloat64Int32ConstOp) Init() {
	p.input.Init()
}

type projGTFloat64ConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projGTFloat64ConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat64ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTFloat64ConstInt32Op) Init() {
	p.input.Init()
}

type projGTFloat64Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTFloat64Int32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat64Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTFloat64Int32Op) Init() {
	p.input.Init()
}

type projGEFloat64Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32

	outputIdx int
}

func (p projGEFloat64Int32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat64Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEFloat64Int32ConstOp) Init() {
	p.input.Init()
}

type projGEFloat64ConstInt32Op struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projGEFloat64ConstInt32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat64ConstInt32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEFloat64ConstInt32Op) Init() {
	p.input.Init()
}

type projGEFloat64Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEFloat64Int32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat64Int32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEFloat64Int32Op) Init() {
	p.input.Init()
}

type projEQFloat64Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projEQFloat64Int64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat64Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQFloat64Int64ConstOp) Init() {
	p.input.Init()
}

type projEQFloat64ConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projEQFloat64ConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat64ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQFloat64ConstInt64Op) Init() {
	p.input.Init()
}

type projEQFloat64Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQFloat64Int64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat64Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQFloat64Int64Op) Init() {
	p.input.Init()
}

type projNEFloat64Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projNEFloat64Int64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat64Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEFloat64Int64ConstOp) Init() {
	p.input.Init()
}

type projNEFloat64ConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projNEFloat64ConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat64ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEFloat64ConstInt64Op) Init() {
	p.input.Init()
}

type projNEFloat64Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEFloat64Int64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat64Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEFloat64Int64Op) Init() {
	p.input.Init()
}

type projLTFloat64Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projLTFloat64Int64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat64Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTFloat64Int64ConstOp) Init() {
	p.input.Init()
}

type projLTFloat64ConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projLTFloat64ConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat64ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTFloat64ConstInt64Op) Init() {
	p.input.Init()
}

type projLTFloat64Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTFloat64Int64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat64Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTFloat64Int64Op) Init() {
	p.input.Init()
}

type projLEFloat64Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projLEFloat64Int64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat64Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEFloat64Int64ConstOp) Init() {
	p.input.Init()
}

type projLEFloat64ConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projLEFloat64ConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat64ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEFloat64ConstInt64Op) Init() {
	p.input.Init()
}

type projLEFloat64Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEFloat64Int64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat64Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEFloat64Int64Op) Init() {
	p.input.Init()
}

type projGTFloat64Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projGTFloat64Int64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat64Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTFloat64Int64ConstOp) Init() {
	p.input.Init()
}

type projGTFloat64ConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projGTFloat64ConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat64ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTFloat64ConstInt64Op) Init() {
	p.input.Init()
}

type projGTFloat64Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTFloat64Int64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat64Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTFloat64Int64Op) Init() {
	p.input.Init()
}

type projGEFloat64Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64

	outputIdx int
}

func (p projGEFloat64Int64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat64Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEFloat64Int64ConstOp) Init() {
	p.input.Init()
}

type projGEFloat64ConstInt64Op struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projGEFloat64ConstInt64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat64ConstInt64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Int64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEFloat64ConstInt64Op) Init() {
	p.input.Init()
}

type projGEFloat64Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEFloat64Int64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat64Int64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Int64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if false {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEFloat64Int64Op) Init() {
	p.input.Init()
}

type projEQFloat64Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projEQFloat64Float32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat64Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQFloat64Float32ConstOp) Init() {
	p.input.Init()
}

type projEQFloat64ConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projEQFloat64ConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat64ConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQFloat64ConstFloat32Op) Init() {
	p.input.Init()
}

type projEQFloat64Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQFloat64Float32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat64Float32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQFloat64Float32Op) Init() {
	p.input.Init()
}

type projNEFloat64Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projNEFloat64Float32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat64Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEFloat64Float32ConstOp) Init() {
	p.input.Init()
}

type projNEFloat64ConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projNEFloat64ConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat64ConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEFloat64ConstFloat32Op) Init() {
	p.input.Init()
}

type projNEFloat64Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEFloat64Float32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat64Float32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEFloat64Float32Op) Init() {
	p.input.Init()
}

type projLTFloat64Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projLTFloat64Float32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat64Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTFloat64Float32ConstOp) Init() {
	p.input.Init()
}

type projLTFloat64ConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projLTFloat64ConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat64ConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTFloat64ConstFloat32Op) Init() {
	p.input.Init()
}

type projLTFloat64Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTFloat64Float32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat64Float32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTFloat64Float32Op) Init() {
	p.input.Init()
}

type projLEFloat64Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projLEFloat64Float32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat64Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEFloat64Float32ConstOp) Init() {
	p.input.Init()
}

type projLEFloat64ConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projLEFloat64ConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat64ConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEFloat64ConstFloat32Op) Init() {
	p.input.Init()
}

type projLEFloat64Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEFloat64Float32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat64Float32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEFloat64Float32Op) Init() {
	p.input.Init()
}

type projGTFloat64Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projGTFloat64Float32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat64Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTFloat64Float32ConstOp) Init() {
	p.input.Init()
}

type projGTFloat64ConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projGTFloat64ConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat64ConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTFloat64ConstFloat32Op) Init() {
	p.input.Init()
}

type projGTFloat64Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTFloat64Float32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat64Float32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTFloat64Float32Op) Init() {
	p.input.Init()
}

type projGEFloat64Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32

	outputIdx int
}

func (p projGEFloat64Float32ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat64Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEFloat64Float32ConstOp) Init() {
	p.input.Init()
}

type projGEFloat64ConstFloat32Op struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projGEFloat64ConstFloat32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat64ConstFloat32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float32()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEFloat64ConstFloat32Op) Init() {
	p.input.Init()
}

type projGEFloat64Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEFloat64Float32Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat64Float32Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Float32()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEFloat64Float32Op) Init() {
	p.input.Init()
}

type projPlusFloat64Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projPlusFloat64Float64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Float64}, coldata.BatchSize)
}

func (p projPlusFloat64Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Float64)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]
			projCol[i] = arg + p.constArg
		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]
			projCol[i] = arg + p.constArg
		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projPlusFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type projPlusFloat64ConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projPlusFloat64ConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Float64}, coldata.BatchSize)
}

func (p projPlusFloat64ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Float64)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]
			projCol[i] = p.constArg + arg
		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]
			projCol[i] = p.constArg + arg
		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projPlusFloat64ConstFloat64Op) Init() {
	p.input.Init()
}

type projPlusFloat64Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projPlusFloat64Float64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Float64}, coldata.BatchSize)
}

func (p projPlusFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Float64)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Float64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]
			projCol[i] = arg1 + arg2
		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]
			projCol[i] = arg1 + arg2
		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projPlusFloat64Float64Op) Init() {
	p.input.Init()
}

type projMinusFloat64Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projMinusFloat64Float64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Float64}, coldata.BatchSize)
}

func (p projMinusFloat64Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Float64)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]
			projCol[i] = arg - p.constArg
		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]
			projCol[i] = arg - p.constArg
		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projMinusFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type projMinusFloat64ConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projMinusFloat64ConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Float64}, coldata.BatchSize)
}

func (p projMinusFloat64ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Float64)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]
			projCol[i] = p.constArg - arg
		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]
			projCol[i] = p.constArg - arg
		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projMinusFloat64ConstFloat64Op) Init() {
	p.input.Init()
}

type projMinusFloat64Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projMinusFloat64Float64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Float64}, coldata.BatchSize)
}

func (p projMinusFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Float64)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Float64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]
			projCol[i] = arg1 - arg2
		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]
			projCol[i] = arg1 - arg2
		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projMinusFloat64Float64Op) Init() {
	p.input.Init()
}

type projMultFloat64Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projMultFloat64Float64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Float64}, coldata.BatchSize)
}

func (p projMultFloat64Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Float64)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]
			projCol[i] = arg * p.constArg
		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]
			projCol[i] = arg * p.constArg
		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projMultFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type projMultFloat64ConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projMultFloat64ConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Float64}, coldata.BatchSize)
}

func (p projMultFloat64ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Float64)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]
			projCol[i] = p.constArg * arg
		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]
			projCol[i] = p.constArg * arg
		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projMultFloat64ConstFloat64Op) Init() {
	p.input.Init()
}

type projMultFloat64Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projMultFloat64Float64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Float64}, coldata.BatchSize)
}

func (p projMultFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Float64)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Float64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]
			projCol[i] = arg1 * arg2
		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]
			projCol[i] = arg1 * arg2
		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projMultFloat64Float64Op) Init() {
	p.input.Init()
}

type projDivFloat64Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projDivFloat64Float64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Float64}, coldata.BatchSize)
}

func (p projDivFloat64Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Float64)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]
			projCol[i] = arg / p.constArg
		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]
			projCol[i] = arg / p.constArg
		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projDivFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type projDivFloat64ConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projDivFloat64ConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Float64}, coldata.BatchSize)
}

func (p projDivFloat64ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Float64)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]
			projCol[i] = p.constArg / arg
		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]
			projCol[i] = p.constArg / arg
		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projDivFloat64ConstFloat64Op) Init() {
	p.input.Init()
}

type projDivFloat64Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projDivFloat64Float64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Float64}, coldata.BatchSize)
}

func (p projDivFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Float64)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Float64()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]
			projCol[i] = arg1 / arg2
		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]
			projCol[i] = arg1 / arg2
		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projDivFloat64Float64Op) Init() {
	p.input.Init()
}

type projEQFloat64Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projEQFloat64Float64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat64Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type projEQFloat64ConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projEQFloat64ConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat64ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projEQFloat64ConstFloat64Op) Init() {
	p.input.Init()
}

type projEQFloat64Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projEQFloat64Float64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projEQFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult == 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projEQFloat64Float64Op) Init() {
	p.input.Init()
}

type projNEFloat64Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projNEFloat64Float64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat64Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type projNEFloat64ConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projNEFloat64ConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat64ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projNEFloat64ConstFloat64Op) Init() {
	p.input.Init()
}

type projNEFloat64Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projNEFloat64Float64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projNEFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult != 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projNEFloat64Float64Op) Init() {
	p.input.Init()
}

type projLTFloat64Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projLTFloat64Float64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat64Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type projLTFloat64ConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projLTFloat64ConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat64ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLTFloat64ConstFloat64Op) Init() {
	p.input.Init()
}

type projLTFloat64Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLTFloat64Float64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLTFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult < 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLTFloat64Float64Op) Init() {
	p.input.Init()
}

type projLEFloat64Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projLEFloat64Float64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat64Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type projLEFloat64ConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projLEFloat64ConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat64ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projLEFloat64ConstFloat64Op) Init() {
	p.input.Init()
}

type projLEFloat64Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projLEFloat64Float64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projLEFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult <= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projLEFloat64Float64Op) Init() {
	p.input.Init()
}

type projGTFloat64Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projGTFloat64Float64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat64Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type projGTFloat64ConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projGTFloat64ConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat64ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGTFloat64ConstFloat64Op) Init() {
	p.input.Init()
}

type projGTFloat64Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGTFloat64Float64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGTFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult > 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGTFloat64Float64Op) Init() {
	p.input.Init()
}

type projGEFloat64Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projGEFloat64Float64ConstOp) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat64Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(arg), float64(p.constArg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type projGEFloat64ConstFloat64Op struct {
	OneInputNode

	colIdx   int
	constArg float64

	outputIdx int
}

func (p projGEFloat64ConstFloat64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat64ConstFloat64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	vec := batch.ColVec(p.colIdx)
	col := vec.Float64()
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg := col[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col = col[0:int(n)]
		colLen := len(col)
		_ = projCol[colLen-1]
		for i := range col {
			arg := col[i]

			{
				var cmpResult int

				{
					a, b := float64(p.constArg), float64(arg)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec.Nulls().MaybeHasNulls() {
		nulls := vec.Nulls().Copy()
		projVec.SetNulls(&nulls)
	}
	return batch
}

func (p projGEFloat64ConstFloat64Op) Init() {
	p.input.Init()
}

type projGEFloat64Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p projGEFloat64Float64Op) EstimateStaticMemoryUsage() int {
	return EstimateBatchSizeBytes([]coltypes.T{coltypes.Bool}, coldata.BatchSize)
}

func (p projGEFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	batch := p.input.Next(ctx)
	n := batch.Length()
	if p.outputIdx == batch.Width() {
		batch.AppendCol(coltypes.Bool)
	}
	if n == 0 {
		return batch
	}
	projVec := batch.ColVec(p.outputIdx)
	projCol := projVec.Bool()
	vec1 := batch.ColVec(p.col1Idx)
	vec2 := batch.ColVec(p.col2Idx)
	col1 := vec1.Float64()
	col2 := vec2.Float64()
	if sel := batch.Selection(); sel != nil {
		sel = sel[:n]
		for _, i := range sel {
			arg1 := col1[int(i)]
			arg2 := col2[int(i)]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	} else {
		col1 = col1[0:int(n)]
		colLen := len(col1)
		_ = projCol[colLen-1]
		_ = col2[0 : colLen-1]
		for i := range col1 {
			arg1 := col1[i]
			arg2 := col2[i]

			{
				var cmpResult int

				{
					a, b := float64(arg1), float64(arg2)
					if a < b {
						cmpResult = -1
					} else if a > b {
						cmpResult = 1
					} else if a == b {
						cmpResult = 0
					} else if math.IsNaN(a) {
						if math.IsNaN(b) {
							cmpResult = 0
						} else {
							cmpResult = -1
						}
					} else {
						cmpResult = 1
					}
				}

				projCol[i] = cmpResult >= 0
			}

		}
	}
	if vec1.Nulls().MaybeHasNulls() || vec2.Nulls().MaybeHasNulls() {
		projVec.SetNulls(vec1.Nulls().Or(vec2.Nulls()))
	}
	return batch
}

func (p projGEFloat64Float64Op) Init() {
	p.input.Init()
}

// GetProjectionConstOperator returns the appropriate constant projection
// operator for the given left and right column types and comparison.
func GetProjectionRConstOperator(
	leftColType *types.T,
	rightColType *types.T,
	op tree.Operator,
	input Operator,
	colIdx int,
	constArg tree.Datum,
	outputIdx int,
) (Operator, error) {
	c, err := typeconv.GetDatumToPhysicalFn(rightColType)(constArg)
	if err != nil {
		return nil, err
	}
	switch leftType := typeconv.FromColumnType(leftColType); leftType {

	case coltypes.Bool:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {

		case coltypes.Bool:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQBoolBoolConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(bool),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEBoolBoolConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(bool),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTBoolBoolConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(bool),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEBoolBoolConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(bool),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTBoolBoolConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(bool),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEBoolBoolConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(bool),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	case coltypes.Bytes:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {

		case coltypes.Bytes:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQBytesBytesConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.([]byte),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEBytesBytesConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.([]byte),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTBytesBytesConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.([]byte),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEBytesBytesConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.([]byte),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTBytesBytesConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.([]byte),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEBytesBytesConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.([]byte),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	case coltypes.Decimal:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {

		case coltypes.Decimal:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				case tree.Plus:
					return &projPlusDecimalDecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.Minus:
					return &projMinusDecimalDecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.Mult:
					return &projMultDecimalDecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.Div:
					return &projDivDecimalDecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQDecimalDecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEDecimalDecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTDecimalDecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEDecimalDecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTDecimalDecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEDecimalDecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int8:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQDecimalInt8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEDecimalInt8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTDecimalInt8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEDecimalInt8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTDecimalInt8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEDecimalInt8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int16:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQDecimalInt16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEDecimalInt16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTDecimalInt16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEDecimalInt16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTDecimalInt16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEDecimalInt16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQDecimalInt32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEDecimalInt32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTDecimalInt32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEDecimalInt32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTDecimalInt32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEDecimalInt32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQDecimalInt64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEDecimalInt64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTDecimalInt64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEDecimalInt64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTDecimalInt64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEDecimalInt64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQDecimalFloat32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEDecimalFloat32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTDecimalFloat32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEDecimalFloat32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTDecimalFloat32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEDecimalFloat32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQDecimalFloat64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEDecimalFloat64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTDecimalFloat64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEDecimalFloat64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTDecimalFloat64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEDecimalFloat64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	case coltypes.Int8:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {

		case coltypes.Decimal:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt8DecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt8DecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt8DecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt8DecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt8DecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt8DecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int8:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				case tree.Plus:
					return &projPlusInt8Int8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.Minus:
					return &projMinusInt8Int8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.Mult:
					return &projMultInt8Int8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.Div:
					return &projDivInt8Int8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt8Int8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt8Int8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt8Int8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt8Int8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt8Int8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt8Int8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int16:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt8Int16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt8Int16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt8Int16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt8Int16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt8Int16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt8Int16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt8Int32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt8Int32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt8Int32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt8Int32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt8Int32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt8Int32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt8Int64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt8Int64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt8Int64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt8Int64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt8Int64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt8Int64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt8Float32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt8Float32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt8Float32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt8Float32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt8Float32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt8Float32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt8Float64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt8Float64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt8Float64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt8Float64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt8Float64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt8Float64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	case coltypes.Int16:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {

		case coltypes.Decimal:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt16DecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt16DecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt16DecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt16DecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt16DecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt16DecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int8:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt16Int8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt16Int8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt16Int8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt16Int8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt16Int8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt16Int8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int16:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				case tree.Plus:
					return &projPlusInt16Int16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.Minus:
					return &projMinusInt16Int16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.Mult:
					return &projMultInt16Int16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.Div:
					return &projDivInt16Int16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt16Int16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt16Int16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt16Int16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt16Int16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt16Int16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt16Int16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt16Int32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt16Int32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt16Int32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt16Int32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt16Int32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt16Int32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt16Int64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt16Int64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt16Int64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt16Int64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt16Int64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt16Int64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt16Float32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt16Float32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt16Float32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt16Float32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt16Float32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt16Float32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt16Float64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt16Float64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt16Float64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt16Float64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt16Float64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt16Float64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	case coltypes.Int32:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {

		case coltypes.Decimal:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt32DecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt32DecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt32DecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt32DecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt32DecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt32DecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int8:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt32Int8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt32Int8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt32Int8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt32Int8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt32Int8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt32Int8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int16:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt32Int16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt32Int16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt32Int16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt32Int16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt32Int16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt32Int16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				case tree.Plus:
					return &projPlusInt32Int32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.Minus:
					return &projMinusInt32Int32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.Mult:
					return &projMultInt32Int32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.Div:
					return &projDivInt32Int32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt32Int32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt32Int32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt32Int32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt32Int32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt32Int32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt32Int32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt32Int64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt32Int64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt32Int64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt32Int64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt32Int64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt32Int64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt32Float32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt32Float32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt32Float32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt32Float32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt32Float32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt32Float32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt32Float64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt32Float64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt32Float64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt32Float64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt32Float64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt32Float64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	case coltypes.Int64:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {

		case coltypes.Decimal:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt64DecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt64DecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt64DecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt64DecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt64DecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt64DecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int8:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt64Int8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt64Int8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt64Int8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt64Int8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt64Int8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt64Int8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int16:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt64Int16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt64Int16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt64Int16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt64Int16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt64Int16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt64Int16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt64Int32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt64Int32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt64Int32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt64Int32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt64Int32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt64Int32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				case tree.Plus:
					return &projPlusInt64Int64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.Minus:
					return &projMinusInt64Int64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.Mult:
					return &projMultInt64Int64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.Div:
					return &projDivInt64Int64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt64Int64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt64Int64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt64Int64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt64Int64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt64Int64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt64Int64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt64Float32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt64Float32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt64Float32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt64Float32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt64Float32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt64Float32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt64Float64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt64Float64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt64Float64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt64Float64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt64Float64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt64Float64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	case coltypes.Float32:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {

		case coltypes.Decimal:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat32DecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat32DecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat32DecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat32DecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat32DecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat32DecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int8:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat32Int8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat32Int8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat32Int8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat32Int8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat32Int8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat32Int8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int16:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat32Int16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat32Int16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat32Int16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat32Int16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat32Int16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat32Int16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat32Int32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat32Int32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat32Int32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat32Int32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat32Int32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat32Int32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat32Int64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat32Int64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat32Int64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat32Int64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat32Int64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat32Int64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				case tree.Plus:
					return &projPlusFloat32Float32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.Minus:
					return &projMinusFloat32Float32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.Mult:
					return &projMultFloat32Float32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.Div:
					return &projDivFloat32Float32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat32Float32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat32Float32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat32Float32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat32Float32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat32Float32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat32Float32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat32Float64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat32Float64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat32Float64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat32Float64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat32Float64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat32Float64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	case coltypes.Float64:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {

		case coltypes.Decimal:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat64DecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat64DecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat64DecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat64DecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat64DecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat64DecimalConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int8:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat64Int8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat64Int8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat64Int8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat64Int8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat64Int8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat64Int8ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int16:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat64Int16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat64Int16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat64Int16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat64Int16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat64Int16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat64Int16ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat64Int32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat64Int32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat64Int32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat64Int32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat64Int32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat64Int32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat64Int64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat64Int64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat64Int64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat64Int64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat64Int64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat64Int64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat64Float32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat64Float32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat64Float32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat64Float32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat64Float32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat64Float32ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				case tree.Plus:
					return &projPlusFloat64Float64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.Minus:
					return &projMinusFloat64Float64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.Mult:
					return &projMultFloat64Float64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.Div:
					return &projDivFloat64Float64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat64Float64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat64Float64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat64Float64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat64Float64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat64Float64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat64Float64ConstOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	default:
		return nil, errors.Errorf("unhandled left type: %s", leftType)
	}
}

// GetProjectionConstOperator returns the appropriate constant projection
// operator for the given left and right column types and comparison.
func GetProjectionLConstOperator(
	leftColType *types.T,
	rightColType *types.T,
	op tree.Operator,
	input Operator,
	colIdx int,
	constArg tree.Datum,
	outputIdx int,
) (Operator, error) {
	c, err := typeconv.GetDatumToPhysicalFn(leftColType)(constArg)
	if err != nil {
		return nil, err
	}
	switch leftType := typeconv.FromColumnType(leftColType); leftType {

	case coltypes.Bool:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {

		case coltypes.Bool:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQBoolConstBoolOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(bool),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEBoolConstBoolOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(bool),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTBoolConstBoolOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(bool),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEBoolConstBoolOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(bool),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTBoolConstBoolOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(bool),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEBoolConstBoolOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(bool),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	case coltypes.Bytes:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {

		case coltypes.Bytes:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQBytesConstBytesOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.([]byte),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEBytesConstBytesOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.([]byte),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTBytesConstBytesOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.([]byte),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEBytesConstBytesOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.([]byte),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTBytesConstBytesOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.([]byte),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEBytesConstBytesOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.([]byte),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	case coltypes.Decimal:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {

		case coltypes.Decimal:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				case tree.Plus:
					return &projPlusDecimalConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.Minus:
					return &projMinusDecimalConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.Mult:
					return &projMultDecimalConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.Div:
					return &projDivDecimalConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQDecimalConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEDecimalConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTDecimalConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEDecimalConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTDecimalConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEDecimalConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int8:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQDecimalConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEDecimalConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTDecimalConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEDecimalConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTDecimalConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEDecimalConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int16:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQDecimalConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEDecimalConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTDecimalConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEDecimalConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTDecimalConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEDecimalConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQDecimalConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEDecimalConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTDecimalConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEDecimalConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTDecimalConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEDecimalConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQDecimalConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEDecimalConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTDecimalConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEDecimalConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTDecimalConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEDecimalConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQDecimalConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEDecimalConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTDecimalConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEDecimalConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTDecimalConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEDecimalConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQDecimalConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEDecimalConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTDecimalConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEDecimalConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTDecimalConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEDecimalConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(apd.Decimal),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	case coltypes.Int8:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {

		case coltypes.Decimal:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt8ConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt8ConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt8ConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt8ConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt8ConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt8ConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int8:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				case tree.Plus:
					return &projPlusInt8ConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.Minus:
					return &projMinusInt8ConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.Mult:
					return &projMultInt8ConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.Div:
					return &projDivInt8ConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt8ConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt8ConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt8ConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt8ConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt8ConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt8ConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int16:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt8ConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt8ConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt8ConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt8ConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt8ConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt8ConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt8ConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt8ConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt8ConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt8ConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt8ConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt8ConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt8ConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt8ConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt8ConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt8ConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt8ConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt8ConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt8ConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt8ConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt8ConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt8ConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt8ConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt8ConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt8ConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt8ConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt8ConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt8ConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt8ConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt8ConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int8),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	case coltypes.Int16:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {

		case coltypes.Decimal:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt16ConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt16ConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt16ConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt16ConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt16ConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt16ConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int8:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt16ConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt16ConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt16ConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt16ConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt16ConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt16ConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int16:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				case tree.Plus:
					return &projPlusInt16ConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.Minus:
					return &projMinusInt16ConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.Mult:
					return &projMultInt16ConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.Div:
					return &projDivInt16ConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt16ConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt16ConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt16ConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt16ConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt16ConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt16ConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt16ConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt16ConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt16ConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt16ConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt16ConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt16ConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt16ConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt16ConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt16ConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt16ConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt16ConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt16ConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt16ConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt16ConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt16ConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt16ConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt16ConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt16ConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt16ConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt16ConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt16ConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt16ConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt16ConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt16ConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int16),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	case coltypes.Int32:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {

		case coltypes.Decimal:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt32ConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt32ConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt32ConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt32ConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt32ConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt32ConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int8:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt32ConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt32ConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt32ConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt32ConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt32ConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt32ConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int16:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt32ConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt32ConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt32ConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt32ConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt32ConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt32ConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				case tree.Plus:
					return &projPlusInt32ConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.Minus:
					return &projMinusInt32ConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.Mult:
					return &projMultInt32ConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.Div:
					return &projDivInt32ConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt32ConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt32ConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt32ConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt32ConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt32ConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt32ConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt32ConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt32ConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt32ConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt32ConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt32ConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt32ConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt32ConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt32ConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt32ConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt32ConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt32ConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt32ConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt32ConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt32ConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt32ConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt32ConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt32ConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt32ConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int32),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	case coltypes.Int64:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {

		case coltypes.Decimal:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt64ConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt64ConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt64ConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt64ConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt64ConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt64ConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int8:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt64ConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt64ConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt64ConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt64ConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt64ConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt64ConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int16:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt64ConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt64ConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt64ConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt64ConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt64ConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt64ConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt64ConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt64ConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt64ConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt64ConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt64ConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt64ConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				case tree.Plus:
					return &projPlusInt64ConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.Minus:
					return &projMinusInt64ConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.Mult:
					return &projMultInt64ConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.Div:
					return &projDivInt64ConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt64ConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt64ConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt64ConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt64ConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt64ConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt64ConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt64ConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt64ConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt64ConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt64ConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt64ConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt64ConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt64ConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt64ConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt64ConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt64ConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt64ConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt64ConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(int64),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	case coltypes.Float32:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {

		case coltypes.Decimal:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat32ConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat32ConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat32ConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat32ConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat32ConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat32ConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int8:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat32ConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat32ConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat32ConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat32ConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat32ConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat32ConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int16:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat32ConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat32ConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat32ConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat32ConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat32ConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat32ConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat32ConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat32ConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat32ConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat32ConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat32ConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat32ConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat32ConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat32ConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat32ConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat32ConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat32ConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat32ConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				case tree.Plus:
					return &projPlusFloat32ConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.Minus:
					return &projMinusFloat32ConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.Mult:
					return &projMultFloat32ConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.Div:
					return &projDivFloat32ConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat32ConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat32ConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat32ConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat32ConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat32ConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat32ConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat32ConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat32ConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat32ConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat32ConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat32ConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat32ConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float32),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	case coltypes.Float64:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {

		case coltypes.Decimal:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat64ConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat64ConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat64ConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat64ConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat64ConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat64ConstDecimalOp{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int8:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat64ConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat64ConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat64ConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat64ConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat64ConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat64ConstInt8Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int16:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat64ConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat64ConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat64ConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat64ConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat64ConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat64ConstInt16Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat64ConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat64ConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat64ConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat64ConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat64ConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat64ConstInt32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat64ConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat64ConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat64ConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat64ConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat64ConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat64ConstInt64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat64ConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat64ConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat64ConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat64ConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat64ConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat64ConstFloat32Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				case tree.Plus:
					return &projPlusFloat64ConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.Minus:
					return &projMinusFloat64ConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.Mult:
					return &projMultFloat64ConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.Div:
					return &projDivFloat64ConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat64ConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat64ConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat64ConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat64ConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat64ConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat64ConstFloat64Op{
						OneInputNode: NewOneInputNode(input),
						colIdx:       colIdx,
						constArg:     c.(float64),
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	default:
		return nil, errors.Errorf("unhandled left type: %s", leftType)
	}
}

// GetProjectionOperator returns the appropriate projection operator for the
// given left and right column types and comparison.
func GetProjectionOperator(
	leftColType *types.T,
	rightColType *types.T,
	op tree.Operator,
	input Operator,
	col1Idx int,
	col2Idx int,
	outputIdx int,
) (Operator, error) {
	switch leftType := typeconv.FromColumnType(leftColType); leftType {

	case coltypes.Bool:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {

		case coltypes.Bool:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQBoolBoolOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEBoolBoolOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTBoolBoolOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEBoolBoolOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTBoolBoolOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEBoolBoolOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	case coltypes.Bytes:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {

		case coltypes.Bytes:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQBytesBytesOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEBytesBytesOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTBytesBytesOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEBytesBytesOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTBytesBytesOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEBytesBytesOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	case coltypes.Decimal:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {

		case coltypes.Decimal:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				case tree.Plus:
					return &projPlusDecimalDecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.Minus:
					return &projMinusDecimalDecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.Mult:
					return &projMultDecimalDecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.Div:
					return &projDivDecimalDecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQDecimalDecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEDecimalDecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTDecimalDecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEDecimalDecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTDecimalDecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEDecimalDecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int8:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQDecimalInt8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEDecimalInt8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTDecimalInt8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEDecimalInt8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTDecimalInt8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEDecimalInt8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int16:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQDecimalInt16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEDecimalInt16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTDecimalInt16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEDecimalInt16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTDecimalInt16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEDecimalInt16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQDecimalInt32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEDecimalInt32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTDecimalInt32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEDecimalInt32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTDecimalInt32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEDecimalInt32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQDecimalInt64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEDecimalInt64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTDecimalInt64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEDecimalInt64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTDecimalInt64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEDecimalInt64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQDecimalFloat32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEDecimalFloat32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTDecimalFloat32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEDecimalFloat32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTDecimalFloat32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEDecimalFloat32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQDecimalFloat64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEDecimalFloat64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTDecimalFloat64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEDecimalFloat64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTDecimalFloat64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEDecimalFloat64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	case coltypes.Int8:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {

		case coltypes.Decimal:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt8DecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt8DecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt8DecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt8DecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt8DecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt8DecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int8:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				case tree.Plus:
					return &projPlusInt8Int8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.Minus:
					return &projMinusInt8Int8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.Mult:
					return &projMultInt8Int8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.Div:
					return &projDivInt8Int8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt8Int8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt8Int8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt8Int8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt8Int8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt8Int8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt8Int8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int16:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt8Int16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt8Int16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt8Int16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt8Int16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt8Int16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt8Int16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt8Int32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt8Int32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt8Int32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt8Int32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt8Int32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt8Int32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt8Int64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt8Int64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt8Int64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt8Int64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt8Int64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt8Int64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt8Float32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt8Float32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt8Float32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt8Float32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt8Float32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt8Float32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt8Float64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt8Float64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt8Float64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt8Float64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt8Float64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt8Float64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	case coltypes.Int16:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {

		case coltypes.Decimal:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt16DecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt16DecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt16DecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt16DecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt16DecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt16DecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int8:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt16Int8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt16Int8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt16Int8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt16Int8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt16Int8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt16Int8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int16:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				case tree.Plus:
					return &projPlusInt16Int16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.Minus:
					return &projMinusInt16Int16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.Mult:
					return &projMultInt16Int16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.Div:
					return &projDivInt16Int16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt16Int16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt16Int16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt16Int16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt16Int16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt16Int16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt16Int16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt16Int32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt16Int32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt16Int32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt16Int32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt16Int32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt16Int32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt16Int64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt16Int64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt16Int64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt16Int64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt16Int64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt16Int64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt16Float32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt16Float32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt16Float32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt16Float32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt16Float32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt16Float32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt16Float64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt16Float64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt16Float64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt16Float64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt16Float64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt16Float64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	case coltypes.Int32:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {

		case coltypes.Decimal:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt32DecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt32DecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt32DecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt32DecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt32DecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt32DecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int8:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt32Int8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt32Int8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt32Int8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt32Int8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt32Int8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt32Int8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int16:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt32Int16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt32Int16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt32Int16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt32Int16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt32Int16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt32Int16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				case tree.Plus:
					return &projPlusInt32Int32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.Minus:
					return &projMinusInt32Int32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.Mult:
					return &projMultInt32Int32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.Div:
					return &projDivInt32Int32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt32Int32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt32Int32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt32Int32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt32Int32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt32Int32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt32Int32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt32Int64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt32Int64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt32Int64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt32Int64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt32Int64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt32Int64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt32Float32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt32Float32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt32Float32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt32Float32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt32Float32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt32Float32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt32Float64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt32Float64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt32Float64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt32Float64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt32Float64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt32Float64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	case coltypes.Int64:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {

		case coltypes.Decimal:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt64DecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt64DecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt64DecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt64DecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt64DecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt64DecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int8:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt64Int8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt64Int8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt64Int8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt64Int8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt64Int8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt64Int8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int16:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt64Int16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt64Int16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt64Int16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt64Int16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt64Int16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt64Int16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt64Int32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt64Int32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt64Int32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt64Int32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt64Int32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt64Int32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				case tree.Plus:
					return &projPlusInt64Int64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.Minus:
					return &projMinusInt64Int64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.Mult:
					return &projMultInt64Int64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.Div:
					return &projDivInt64Int64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt64Int64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt64Int64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt64Int64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt64Int64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt64Int64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt64Int64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt64Float32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt64Float32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt64Float32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt64Float32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt64Float32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt64Float32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQInt64Float64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEInt64Float64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTInt64Float64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEInt64Float64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTInt64Float64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEInt64Float64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	case coltypes.Float32:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {

		case coltypes.Decimal:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat32DecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat32DecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat32DecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat32DecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat32DecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat32DecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int8:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat32Int8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat32Int8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat32Int8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat32Int8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat32Int8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat32Int8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int16:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat32Int16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat32Int16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat32Int16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat32Int16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat32Int16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat32Int16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat32Int32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat32Int32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat32Int32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat32Int32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat32Int32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat32Int32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat32Int64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat32Int64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat32Int64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat32Int64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat32Int64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat32Int64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				case tree.Plus:
					return &projPlusFloat32Float32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.Minus:
					return &projMinusFloat32Float32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.Mult:
					return &projMultFloat32Float32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.Div:
					return &projDivFloat32Float32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat32Float32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat32Float32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat32Float32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat32Float32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat32Float32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat32Float32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat32Float64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat32Float64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat32Float64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat32Float64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat32Float64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat32Float64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	case coltypes.Float64:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {

		case coltypes.Decimal:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat64DecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat64DecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat64DecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat64DecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat64DecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat64DecimalOp{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int8:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat64Int8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat64Int8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat64Int8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat64Int8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat64Int8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat64Int8Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int16:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat64Int16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat64Int16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat64Int16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat64Int16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat64Int16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat64Int16Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat64Int32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat64Int32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat64Int32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat64Int32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat64Int32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat64Int32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Int64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat64Int64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat64Int64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat64Int64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat64Int64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat64Int64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat64Int64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float32:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat64Float32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat64Float32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat64Float32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat64Float32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat64Float32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat64Float32Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		case coltypes.Float64:
			switch op.(type) {
			case tree.BinaryOperator:
				switch op {

				case tree.Plus:
					return &projPlusFloat64Float64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.Minus:
					return &projMinusFloat64Float64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.Mult:
					return &projMultFloat64Float64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.Div:
					return &projDivFloat64Float64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled binary operator: %s", op)
				}
			case tree.ComparisonOperator:
				switch op {

				case tree.EQ:
					return &projEQFloat64Float64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.NE:
					return &projNEFloat64Float64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LT:
					return &projLTFloat64Float64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.LE:
					return &projLEFloat64Float64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GT:
					return &projGTFloat64Float64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				case tree.GE:
					return &projGEFloat64Float64Op{
						OneInputNode: NewOneInputNode(input),
						col1Idx:      col1Idx,
						col2Idx:      col2Idx,
						outputIdx:    outputIdx,
					}, nil

				default:
					return nil, errors.Errorf("unhandled comparison operator: %s", op)
				}
			default:
				return nil, errors.New("unhandled operator type")
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	default:
		return nil, errors.Errorf("unhandled left type: %s", leftType)
	}
}
