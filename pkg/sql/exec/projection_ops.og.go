// Code generated by execgen; DO NOT EDIT.

package exec

import "bytes"

import "github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
import "github.com/cockroachdb/apd"

type projPlusDecimalDecimalConstOp struct {
	input Operator

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p *projPlusDecimalDecimalConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Decimal()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Decimal()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			if _, err := tree.DecimalCtx.Add(&projCol[i], &col[i], &p.constArg); err != nil {
				panic(err)
			}
		}
	} else {
		col = col[:n]
		for i := range col {
			if _, err := tree.DecimalCtx.Add(&projCol[i], &col[i], &p.constArg); err != nil {
				panic(err)
			}
		}
	}
	return batch
}

func (p projPlusDecimalDecimalConstOp) Init() {
	p.input.Init()
}

type projPlusDecimalDecimalOp struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projPlusDecimalDecimalOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Decimal()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Decimal()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Decimal()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			if _, err := tree.DecimalCtx.Add(&projCol[i], &col1[i], &col2[i]); err != nil {
				panic(err)
			}
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			if _, err := tree.DecimalCtx.Add(&projCol[i], &col1[i], &col2[i]); err != nil {
				panic(err)
			}
		}
	}
	return batch
}

func (p projPlusDecimalDecimalOp) Init() {
	p.input.Init()
}

type projMinusDecimalDecimalConstOp struct {
	input Operator

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p *projMinusDecimalDecimalConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Decimal()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Decimal()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			if _, err := tree.DecimalCtx.Sub(&projCol[i], &col[i], &p.constArg); err != nil {
				panic(err)
			}
		}
	} else {
		col = col[:n]
		for i := range col {
			if _, err := tree.DecimalCtx.Sub(&projCol[i], &col[i], &p.constArg); err != nil {
				panic(err)
			}
		}
	}
	return batch
}

func (p projMinusDecimalDecimalConstOp) Init() {
	p.input.Init()
}

type projMinusDecimalDecimalOp struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projMinusDecimalDecimalOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Decimal()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Decimal()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Decimal()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			if _, err := tree.DecimalCtx.Sub(&projCol[i], &col1[i], &col2[i]); err != nil {
				panic(err)
			}
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			if _, err := tree.DecimalCtx.Sub(&projCol[i], &col1[i], &col2[i]); err != nil {
				panic(err)
			}
		}
	}
	return batch
}

func (p projMinusDecimalDecimalOp) Init() {
	p.input.Init()
}

type projMultDecimalDecimalConstOp struct {
	input Operator

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p *projMultDecimalDecimalConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Decimal()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Decimal()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			if _, err := tree.DecimalCtx.Mul(&projCol[i], &col[i], &p.constArg); err != nil {
				panic(err)
			}
		}
	} else {
		col = col[:n]
		for i := range col {
			if _, err := tree.DecimalCtx.Mul(&projCol[i], &col[i], &p.constArg); err != nil {
				panic(err)
			}
		}
	}
	return batch
}

func (p projMultDecimalDecimalConstOp) Init() {
	p.input.Init()
}

type projMultDecimalDecimalOp struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projMultDecimalDecimalOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Decimal()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Decimal()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Decimal()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			if _, err := tree.DecimalCtx.Mul(&projCol[i], &col1[i], &col2[i]); err != nil {
				panic(err)
			}
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			if _, err := tree.DecimalCtx.Mul(&projCol[i], &col1[i], &col2[i]); err != nil {
				panic(err)
			}
		}
	}
	return batch
}

func (p projMultDecimalDecimalOp) Init() {
	p.input.Init()
}

type projDivDecimalDecimalConstOp struct {
	input Operator

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p *projDivDecimalDecimalConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Decimal()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Decimal()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			if _, err := tree.DecimalCtx.Quo(&projCol[i], &col[i], &p.constArg); err != nil {
				panic(err)
			}
		}
	} else {
		col = col[:n]
		for i := range col {
			if _, err := tree.DecimalCtx.Quo(&projCol[i], &col[i], &p.constArg); err != nil {
				panic(err)
			}
		}
	}
	return batch
}

func (p projDivDecimalDecimalConstOp) Init() {
	p.input.Init()
}

type projDivDecimalDecimalOp struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projDivDecimalDecimalOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Decimal()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Decimal()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Decimal()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			if _, err := tree.DecimalCtx.Quo(&projCol[i], &col1[i], &col2[i]); err != nil {
				panic(err)
			}
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			if _, err := tree.DecimalCtx.Quo(&projCol[i], &col1[i], &col2[i]); err != nil {
				panic(err)
			}
		}
	}
	return batch
}

func (p projDivDecimalDecimalOp) Init() {
	p.input.Init()
}

type projPlusInt8Int8ConstOp struct {
	input Operator

	colIdx   int
	constArg int8

	outputIdx int
}

func (p *projPlusInt8Int8ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int8()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int8()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] + p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] + p.constArg
		}
	}
	return batch
}

func (p projPlusInt8Int8ConstOp) Init() {
	p.input.Init()
}

type projPlusInt8Int8Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projPlusInt8Int8Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int8()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int8()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int8()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] + col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] + col2[i]
		}
	}
	return batch
}

func (p projPlusInt8Int8Op) Init() {
	p.input.Init()
}

type projMinusInt8Int8ConstOp struct {
	input Operator

	colIdx   int
	constArg int8

	outputIdx int
}

func (p *projMinusInt8Int8ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int8()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int8()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] - p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] - p.constArg
		}
	}
	return batch
}

func (p projMinusInt8Int8ConstOp) Init() {
	p.input.Init()
}

type projMinusInt8Int8Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projMinusInt8Int8Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int8()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int8()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int8()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] - col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] - col2[i]
		}
	}
	return batch
}

func (p projMinusInt8Int8Op) Init() {
	p.input.Init()
}

type projMultInt8Int8ConstOp struct {
	input Operator

	colIdx   int
	constArg int8

	outputIdx int
}

func (p *projMultInt8Int8ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int8()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int8()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] * p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] * p.constArg
		}
	}
	return batch
}

func (p projMultInt8Int8ConstOp) Init() {
	p.input.Init()
}

type projMultInt8Int8Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projMultInt8Int8Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int8()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int8()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int8()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] * col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] * col2[i]
		}
	}
	return batch
}

func (p projMultInt8Int8Op) Init() {
	p.input.Init()
}

type projDivInt8Int8ConstOp struct {
	input Operator

	colIdx   int
	constArg int8

	outputIdx int
}

func (p *projDivInt8Int8ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int8()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int8()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] / p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] / p.constArg
		}
	}
	return batch
}

func (p projDivInt8Int8ConstOp) Init() {
	p.input.Init()
}

type projDivInt8Int8Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projDivInt8Int8Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int8()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int8()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int8()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] / col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] / col2[i]
		}
	}
	return batch
}

func (p projDivInt8Int8Op) Init() {
	p.input.Init()
}

type projPlusInt16Int16ConstOp struct {
	input Operator

	colIdx   int
	constArg int16

	outputIdx int
}

func (p *projPlusInt16Int16ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int16()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int16()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] + p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] + p.constArg
		}
	}
	return batch
}

func (p projPlusInt16Int16ConstOp) Init() {
	p.input.Init()
}

type projPlusInt16Int16Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projPlusInt16Int16Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int16()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int16()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int16()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] + col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] + col2[i]
		}
	}
	return batch
}

func (p projPlusInt16Int16Op) Init() {
	p.input.Init()
}

type projMinusInt16Int16ConstOp struct {
	input Operator

	colIdx   int
	constArg int16

	outputIdx int
}

func (p *projMinusInt16Int16ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int16()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int16()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] - p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] - p.constArg
		}
	}
	return batch
}

func (p projMinusInt16Int16ConstOp) Init() {
	p.input.Init()
}

type projMinusInt16Int16Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projMinusInt16Int16Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int16()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int16()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int16()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] - col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] - col2[i]
		}
	}
	return batch
}

func (p projMinusInt16Int16Op) Init() {
	p.input.Init()
}

type projMultInt16Int16ConstOp struct {
	input Operator

	colIdx   int
	constArg int16

	outputIdx int
}

func (p *projMultInt16Int16ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int16()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int16()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] * p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] * p.constArg
		}
	}
	return batch
}

func (p projMultInt16Int16ConstOp) Init() {
	p.input.Init()
}

type projMultInt16Int16Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projMultInt16Int16Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int16()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int16()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int16()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] * col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] * col2[i]
		}
	}
	return batch
}

func (p projMultInt16Int16Op) Init() {
	p.input.Init()
}

type projDivInt16Int16ConstOp struct {
	input Operator

	colIdx   int
	constArg int16

	outputIdx int
}

func (p *projDivInt16Int16ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int16()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int16()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] / p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] / p.constArg
		}
	}
	return batch
}

func (p projDivInt16Int16ConstOp) Init() {
	p.input.Init()
}

type projDivInt16Int16Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projDivInt16Int16Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int16()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int16()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int16()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] / col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] / col2[i]
		}
	}
	return batch
}

func (p projDivInt16Int16Op) Init() {
	p.input.Init()
}

type projPlusInt32Int32ConstOp struct {
	input Operator

	colIdx   int
	constArg int32

	outputIdx int
}

func (p *projPlusInt32Int32ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int32()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] + p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] + p.constArg
		}
	}
	return batch
}

func (p projPlusInt32Int32ConstOp) Init() {
	p.input.Init()
}

type projPlusInt32Int32Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projPlusInt32Int32Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int32()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int32()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] + col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] + col2[i]
		}
	}
	return batch
}

func (p projPlusInt32Int32Op) Init() {
	p.input.Init()
}

type projMinusInt32Int32ConstOp struct {
	input Operator

	colIdx   int
	constArg int32

	outputIdx int
}

func (p *projMinusInt32Int32ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int32()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] - p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] - p.constArg
		}
	}
	return batch
}

func (p projMinusInt32Int32ConstOp) Init() {
	p.input.Init()
}

type projMinusInt32Int32Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projMinusInt32Int32Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int32()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int32()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] - col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] - col2[i]
		}
	}
	return batch
}

func (p projMinusInt32Int32Op) Init() {
	p.input.Init()
}

type projMultInt32Int32ConstOp struct {
	input Operator

	colIdx   int
	constArg int32

	outputIdx int
}

func (p *projMultInt32Int32ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int32()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] * p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] * p.constArg
		}
	}
	return batch
}

func (p projMultInt32Int32ConstOp) Init() {
	p.input.Init()
}

type projMultInt32Int32Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projMultInt32Int32Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int32()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int32()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] * col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] * col2[i]
		}
	}
	return batch
}

func (p projMultInt32Int32Op) Init() {
	p.input.Init()
}

type projDivInt32Int32ConstOp struct {
	input Operator

	colIdx   int
	constArg int32

	outputIdx int
}

func (p *projDivInt32Int32ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int32()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] / p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] / p.constArg
		}
	}
	return batch
}

func (p projDivInt32Int32ConstOp) Init() {
	p.input.Init()
}

type projDivInt32Int32Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projDivInt32Int32Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int32()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int32()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] / col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] / col2[i]
		}
	}
	return batch
}

func (p projDivInt32Int32Op) Init() {
	p.input.Init()
}

type projPlusInt64Int64ConstOp struct {
	input Operator

	colIdx   int
	constArg int64

	outputIdx int
}

func (p *projPlusInt64Int64ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int64()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] + p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] + p.constArg
		}
	}
	return batch
}

func (p projPlusInt64Int64ConstOp) Init() {
	p.input.Init()
}

type projPlusInt64Int64Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projPlusInt64Int64Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int64()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int64()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] + col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] + col2[i]
		}
	}
	return batch
}

func (p projPlusInt64Int64Op) Init() {
	p.input.Init()
}

type projMinusInt64Int64ConstOp struct {
	input Operator

	colIdx   int
	constArg int64

	outputIdx int
}

func (p *projMinusInt64Int64ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int64()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] - p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] - p.constArg
		}
	}
	return batch
}

func (p projMinusInt64Int64ConstOp) Init() {
	p.input.Init()
}

type projMinusInt64Int64Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projMinusInt64Int64Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int64()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int64()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] - col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] - col2[i]
		}
	}
	return batch
}

func (p projMinusInt64Int64Op) Init() {
	p.input.Init()
}

type projMultInt64Int64ConstOp struct {
	input Operator

	colIdx   int
	constArg int64

	outputIdx int
}

func (p *projMultInt64Int64ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int64()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] * p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] * p.constArg
		}
	}
	return batch
}

func (p projMultInt64Int64ConstOp) Init() {
	p.input.Init()
}

type projMultInt64Int64Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projMultInt64Int64Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int64()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int64()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] * col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] * col2[i]
		}
	}
	return batch
}

func (p projMultInt64Int64Op) Init() {
	p.input.Init()
}

type projDivInt64Int64ConstOp struct {
	input Operator

	colIdx   int
	constArg int64

	outputIdx int
}

func (p *projDivInt64Int64ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int64()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] / p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] / p.constArg
		}
	}
	return batch
}

func (p projDivInt64Int64ConstOp) Init() {
	p.input.Init()
}

type projDivInt64Int64Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projDivInt64Int64Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Int64()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int64()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] / col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] / col2[i]
		}
	}
	return batch
}

func (p projDivInt64Int64Op) Init() {
	p.input.Init()
}

type projPlusFloat32Float32ConstOp struct {
	input Operator

	colIdx   int
	constArg float32

	outputIdx int
}

func (p *projPlusFloat32Float32ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Float32()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Float32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] + p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] + p.constArg
		}
	}
	return batch
}

func (p projPlusFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type projPlusFloat32Float32Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projPlusFloat32Float32Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Float32()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Float32()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Float32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] + col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] + col2[i]
		}
	}
	return batch
}

func (p projPlusFloat32Float32Op) Init() {
	p.input.Init()
}

type projMinusFloat32Float32ConstOp struct {
	input Operator

	colIdx   int
	constArg float32

	outputIdx int
}

func (p *projMinusFloat32Float32ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Float32()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Float32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] - p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] - p.constArg
		}
	}
	return batch
}

func (p projMinusFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type projMinusFloat32Float32Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projMinusFloat32Float32Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Float32()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Float32()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Float32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] - col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] - col2[i]
		}
	}
	return batch
}

func (p projMinusFloat32Float32Op) Init() {
	p.input.Init()
}

type projMultFloat32Float32ConstOp struct {
	input Operator

	colIdx   int
	constArg float32

	outputIdx int
}

func (p *projMultFloat32Float32ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Float32()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Float32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] * p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] * p.constArg
		}
	}
	return batch
}

func (p projMultFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type projMultFloat32Float32Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projMultFloat32Float32Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Float32()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Float32()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Float32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] * col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] * col2[i]
		}
	}
	return batch
}

func (p projMultFloat32Float32Op) Init() {
	p.input.Init()
}

type projDivFloat32Float32ConstOp struct {
	input Operator

	colIdx   int
	constArg float32

	outputIdx int
}

func (p *projDivFloat32Float32ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Float32()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Float32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] / p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] / p.constArg
		}
	}
	return batch
}

func (p projDivFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type projDivFloat32Float32Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projDivFloat32Float32Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Float32()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Float32()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Float32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] / col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] / col2[i]
		}
	}
	return batch
}

func (p projDivFloat32Float32Op) Init() {
	p.input.Init()
}

type projPlusFloat64Float64ConstOp struct {
	input Operator

	colIdx   int
	constArg float64

	outputIdx int
}

func (p *projPlusFloat64Float64ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Float64()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Float64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] + p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] + p.constArg
		}
	}
	return batch
}

func (p projPlusFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type projPlusFloat64Float64Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projPlusFloat64Float64Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Float64()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Float64()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Float64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] + col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] + col2[i]
		}
	}
	return batch
}

func (p projPlusFloat64Float64Op) Init() {
	p.input.Init()
}

type projMinusFloat64Float64ConstOp struct {
	input Operator

	colIdx   int
	constArg float64

	outputIdx int
}

func (p *projMinusFloat64Float64ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Float64()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Float64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] - p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] - p.constArg
		}
	}
	return batch
}

func (p projMinusFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type projMinusFloat64Float64Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projMinusFloat64Float64Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Float64()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Float64()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Float64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] - col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] - col2[i]
		}
	}
	return batch
}

func (p projMinusFloat64Float64Op) Init() {
	p.input.Init()
}

type projMultFloat64Float64ConstOp struct {
	input Operator

	colIdx   int
	constArg float64

	outputIdx int
}

func (p *projMultFloat64Float64ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Float64()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Float64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] * p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] * p.constArg
		}
	}
	return batch
}

func (p projMultFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type projMultFloat64Float64Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projMultFloat64Float64Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Float64()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Float64()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Float64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] * col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] * col2[i]
		}
	}
	return batch
}

func (p projMultFloat64Float64Op) Init() {
	p.input.Init()
}

type projDivFloat64Float64ConstOp struct {
	input Operator

	colIdx   int
	constArg float64

	outputIdx int
}

func (p *projDivFloat64Float64ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Float64()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Float64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] / p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] / p.constArg
		}
	}
	return batch
}

func (p projDivFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type projDivFloat64Float64Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projDivFloat64Float64Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Float64()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Float64()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Float64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] / col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] / col2[i]
		}
	}
	return batch
}

func (p projDivFloat64Float64Op) Init() {
	p.input.Init()
}

type projEQBoolBoolConstOp struct {
	input Operator

	colIdx   int
	constArg bool

	outputIdx int
}

func (p *projEQBoolBoolConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Bool()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] == p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] == p.constArg
		}
	}
	return batch
}

func (p projEQBoolBoolConstOp) Init() {
	p.input.Init()
}

type projEQBoolBoolOp struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projEQBoolBoolOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Bool()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Bool()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] == col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] == col2[i]
		}
	}
	return batch
}

func (p projEQBoolBoolOp) Init() {
	p.input.Init()
}

type projNEBoolBoolConstOp struct {
	input Operator

	colIdx   int
	constArg bool

	outputIdx int
}

func (p *projNEBoolBoolConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Bool()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] != p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] != p.constArg
		}
	}
	return batch
}

func (p projNEBoolBoolConstOp) Init() {
	p.input.Init()
}

type projNEBoolBoolOp struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projNEBoolBoolOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Bool()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Bool()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] != col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] != col2[i]
		}
	}
	return batch
}

func (p projNEBoolBoolOp) Init() {
	p.input.Init()
}

type projLTBoolBoolConstOp struct {
	input Operator

	colIdx   int
	constArg bool

	outputIdx int
}

func (p *projLTBoolBoolConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Bool()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = tree.CompareBools(col[i], p.constArg) < 0
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = tree.CompareBools(col[i], p.constArg) < 0
		}
	}
	return batch
}

func (p projLTBoolBoolConstOp) Init() {
	p.input.Init()
}

type projLTBoolBoolOp struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projLTBoolBoolOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Bool()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Bool()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = tree.CompareBools(col1[i], col2[i]) < 0
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = tree.CompareBools(col1[i], col2[i]) < 0
		}
	}
	return batch
}

func (p projLTBoolBoolOp) Init() {
	p.input.Init()
}

type projLEBoolBoolConstOp struct {
	input Operator

	colIdx   int
	constArg bool

	outputIdx int
}

func (p *projLEBoolBoolConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Bool()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = tree.CompareBools(col[i], p.constArg) <= 0
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = tree.CompareBools(col[i], p.constArg) <= 0
		}
	}
	return batch
}

func (p projLEBoolBoolConstOp) Init() {
	p.input.Init()
}

type projLEBoolBoolOp struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projLEBoolBoolOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Bool()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Bool()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = tree.CompareBools(col1[i], col2[i]) <= 0
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = tree.CompareBools(col1[i], col2[i]) <= 0
		}
	}
	return batch
}

func (p projLEBoolBoolOp) Init() {
	p.input.Init()
}

type projGTBoolBoolConstOp struct {
	input Operator

	colIdx   int
	constArg bool

	outputIdx int
}

func (p *projGTBoolBoolConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Bool()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = tree.CompareBools(col[i], p.constArg) > 0
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = tree.CompareBools(col[i], p.constArg) > 0
		}
	}
	return batch
}

func (p projGTBoolBoolConstOp) Init() {
	p.input.Init()
}

type projGTBoolBoolOp struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projGTBoolBoolOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Bool()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Bool()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = tree.CompareBools(col1[i], col2[i]) > 0
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = tree.CompareBools(col1[i], col2[i]) > 0
		}
	}
	return batch
}

func (p projGTBoolBoolOp) Init() {
	p.input.Init()
}

type projGEBoolBoolConstOp struct {
	input Operator

	colIdx   int
	constArg bool

	outputIdx int
}

func (p *projGEBoolBoolConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Bool()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = tree.CompareBools(col[i], p.constArg) >= 0
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = tree.CompareBools(col[i], p.constArg) >= 0
		}
	}
	return batch
}

func (p projGEBoolBoolConstOp) Init() {
	p.input.Init()
}

type projGEBoolBoolOp struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projGEBoolBoolOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Bool()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Bool()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = tree.CompareBools(col1[i], col2[i]) >= 0
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = tree.CompareBools(col1[i], col2[i]) >= 0
		}
	}
	return batch
}

func (p projGEBoolBoolOp) Init() {
	p.input.Init()
}

type projEQBytesBytesConstOp struct {
	input Operator

	colIdx   int
	constArg []byte

	outputIdx int
}

func (p *projEQBytesBytesConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Bytes()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = bytes.Equal(col[i], p.constArg)
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = bytes.Equal(col[i], p.constArg)
		}
	}
	return batch
}

func (p projEQBytesBytesConstOp) Init() {
	p.input.Init()
}

type projEQBytesBytesOp struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projEQBytesBytesOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Bytes()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Bytes()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = bytes.Equal(col1[i], col2[i])
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = bytes.Equal(col1[i], col2[i])
		}
	}
	return batch
}

func (p projEQBytesBytesOp) Init() {
	p.input.Init()
}

type projNEBytesBytesConstOp struct {
	input Operator

	colIdx   int
	constArg []byte

	outputIdx int
}

func (p *projNEBytesBytesConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Bytes()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = !bytes.Equal(col[i], p.constArg)
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = !bytes.Equal(col[i], p.constArg)
		}
	}
	return batch
}

func (p projNEBytesBytesConstOp) Init() {
	p.input.Init()
}

type projNEBytesBytesOp struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projNEBytesBytesOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Bytes()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Bytes()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = !bytes.Equal(col1[i], col2[i])
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = !bytes.Equal(col1[i], col2[i])
		}
	}
	return batch
}

func (p projNEBytesBytesOp) Init() {
	p.input.Init()
}

type projLTBytesBytesConstOp struct {
	input Operator

	colIdx   int
	constArg []byte

	outputIdx int
}

func (p *projLTBytesBytesConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Bytes()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = bytes.Compare(col[i], p.constArg) < 0
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = bytes.Compare(col[i], p.constArg) < 0
		}
	}
	return batch
}

func (p projLTBytesBytesConstOp) Init() {
	p.input.Init()
}

type projLTBytesBytesOp struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projLTBytesBytesOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Bytes()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Bytes()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = bytes.Compare(col1[i], col2[i]) < 0
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = bytes.Compare(col1[i], col2[i]) < 0
		}
	}
	return batch
}

func (p projLTBytesBytesOp) Init() {
	p.input.Init()
}

type projLEBytesBytesConstOp struct {
	input Operator

	colIdx   int
	constArg []byte

	outputIdx int
}

func (p *projLEBytesBytesConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Bytes()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = bytes.Compare(col[i], p.constArg) <= 0
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = bytes.Compare(col[i], p.constArg) <= 0
		}
	}
	return batch
}

func (p projLEBytesBytesConstOp) Init() {
	p.input.Init()
}

type projLEBytesBytesOp struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projLEBytesBytesOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Bytes()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Bytes()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = bytes.Compare(col1[i], col2[i]) <= 0
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = bytes.Compare(col1[i], col2[i]) <= 0
		}
	}
	return batch
}

func (p projLEBytesBytesOp) Init() {
	p.input.Init()
}

type projGTBytesBytesConstOp struct {
	input Operator

	colIdx   int
	constArg []byte

	outputIdx int
}

func (p *projGTBytesBytesConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Bytes()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = bytes.Compare(col[i], p.constArg) > 0
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = bytes.Compare(col[i], p.constArg) > 0
		}
	}
	return batch
}

func (p projGTBytesBytesConstOp) Init() {
	p.input.Init()
}

type projGTBytesBytesOp struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projGTBytesBytesOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Bytes()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Bytes()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = bytes.Compare(col1[i], col2[i]) > 0
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = bytes.Compare(col1[i], col2[i]) > 0
		}
	}
	return batch
}

func (p projGTBytesBytesOp) Init() {
	p.input.Init()
}

type projGEBytesBytesConstOp struct {
	input Operator

	colIdx   int
	constArg []byte

	outputIdx int
}

func (p *projGEBytesBytesConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Bytes()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = bytes.Compare(col[i], p.constArg) >= 0
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = bytes.Compare(col[i], p.constArg) >= 0
		}
	}
	return batch
}

func (p projGEBytesBytesConstOp) Init() {
	p.input.Init()
}

type projGEBytesBytesOp struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projGEBytesBytesOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Bytes()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Bytes()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = bytes.Compare(col1[i], col2[i]) >= 0
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = bytes.Compare(col1[i], col2[i]) >= 0
		}
	}
	return batch
}

func (p projGEBytesBytesOp) Init() {
	p.input.Init()
}

type projEQDecimalDecimalConstOp struct {
	input Operator

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p *projEQDecimalDecimalConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Decimal()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = tree.CompareDecimals(&col[i], &p.constArg) == 0
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = tree.CompareDecimals(&col[i], &p.constArg) == 0
		}
	}
	return batch
}

func (p projEQDecimalDecimalConstOp) Init() {
	p.input.Init()
}

type projEQDecimalDecimalOp struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projEQDecimalDecimalOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Decimal()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Decimal()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = tree.CompareDecimals(&col1[i], &col2[i]) == 0
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = tree.CompareDecimals(&col1[i], &col2[i]) == 0
		}
	}
	return batch
}

func (p projEQDecimalDecimalOp) Init() {
	p.input.Init()
}

type projNEDecimalDecimalConstOp struct {
	input Operator

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p *projNEDecimalDecimalConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Decimal()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = tree.CompareDecimals(&col[i], &p.constArg) != 0
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = tree.CompareDecimals(&col[i], &p.constArg) != 0
		}
	}
	return batch
}

func (p projNEDecimalDecimalConstOp) Init() {
	p.input.Init()
}

type projNEDecimalDecimalOp struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projNEDecimalDecimalOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Decimal()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Decimal()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = tree.CompareDecimals(&col1[i], &col2[i]) != 0
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = tree.CompareDecimals(&col1[i], &col2[i]) != 0
		}
	}
	return batch
}

func (p projNEDecimalDecimalOp) Init() {
	p.input.Init()
}

type projLTDecimalDecimalConstOp struct {
	input Operator

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p *projLTDecimalDecimalConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Decimal()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = tree.CompareDecimals(&col[i], &p.constArg) < 0
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = tree.CompareDecimals(&col[i], &p.constArg) < 0
		}
	}
	return batch
}

func (p projLTDecimalDecimalConstOp) Init() {
	p.input.Init()
}

type projLTDecimalDecimalOp struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projLTDecimalDecimalOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Decimal()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Decimal()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = tree.CompareDecimals(&col1[i], &col2[i]) < 0
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = tree.CompareDecimals(&col1[i], &col2[i]) < 0
		}
	}
	return batch
}

func (p projLTDecimalDecimalOp) Init() {
	p.input.Init()
}

type projLEDecimalDecimalConstOp struct {
	input Operator

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p *projLEDecimalDecimalConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Decimal()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = tree.CompareDecimals(&col[i], &p.constArg) <= 0
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = tree.CompareDecimals(&col[i], &p.constArg) <= 0
		}
	}
	return batch
}

func (p projLEDecimalDecimalConstOp) Init() {
	p.input.Init()
}

type projLEDecimalDecimalOp struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projLEDecimalDecimalOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Decimal()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Decimal()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = tree.CompareDecimals(&col1[i], &col2[i]) <= 0
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = tree.CompareDecimals(&col1[i], &col2[i]) <= 0
		}
	}
	return batch
}

func (p projLEDecimalDecimalOp) Init() {
	p.input.Init()
}

type projGTDecimalDecimalConstOp struct {
	input Operator

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p *projGTDecimalDecimalConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Decimal()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = tree.CompareDecimals(&col[i], &p.constArg) > 0
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = tree.CompareDecimals(&col[i], &p.constArg) > 0
		}
	}
	return batch
}

func (p projGTDecimalDecimalConstOp) Init() {
	p.input.Init()
}

type projGTDecimalDecimalOp struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projGTDecimalDecimalOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Decimal()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Decimal()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = tree.CompareDecimals(&col1[i], &col2[i]) > 0
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = tree.CompareDecimals(&col1[i], &col2[i]) > 0
		}
	}
	return batch
}

func (p projGTDecimalDecimalOp) Init() {
	p.input.Init()
}

type projGEDecimalDecimalConstOp struct {
	input Operator

	colIdx   int
	constArg apd.Decimal

	outputIdx int
}

func (p *projGEDecimalDecimalConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Decimal()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = tree.CompareDecimals(&col[i], &p.constArg) >= 0
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = tree.CompareDecimals(&col[i], &p.constArg) >= 0
		}
	}
	return batch
}

func (p projGEDecimalDecimalConstOp) Init() {
	p.input.Init()
}

type projGEDecimalDecimalOp struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projGEDecimalDecimalOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Decimal()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Decimal()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = tree.CompareDecimals(&col1[i], &col2[i]) >= 0
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = tree.CompareDecimals(&col1[i], &col2[i]) >= 0
		}
	}
	return batch
}

func (p projGEDecimalDecimalOp) Init() {
	p.input.Init()
}

type projEQInt8Int8ConstOp struct {
	input Operator

	colIdx   int
	constArg int8

	outputIdx int
}

func (p *projEQInt8Int8ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int8()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] == p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] == p.constArg
		}
	}
	return batch
}

func (p projEQInt8Int8ConstOp) Init() {
	p.input.Init()
}

type projEQInt8Int8Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projEQInt8Int8Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int8()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int8()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] == col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] == col2[i]
		}
	}
	return batch
}

func (p projEQInt8Int8Op) Init() {
	p.input.Init()
}

type projNEInt8Int8ConstOp struct {
	input Operator

	colIdx   int
	constArg int8

	outputIdx int
}

func (p *projNEInt8Int8ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int8()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] != p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] != p.constArg
		}
	}
	return batch
}

func (p projNEInt8Int8ConstOp) Init() {
	p.input.Init()
}

type projNEInt8Int8Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projNEInt8Int8Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int8()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int8()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] != col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] != col2[i]
		}
	}
	return batch
}

func (p projNEInt8Int8Op) Init() {
	p.input.Init()
}

type projLTInt8Int8ConstOp struct {
	input Operator

	colIdx   int
	constArg int8

	outputIdx int
}

func (p *projLTInt8Int8ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int8()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] < p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] < p.constArg
		}
	}
	return batch
}

func (p projLTInt8Int8ConstOp) Init() {
	p.input.Init()
}

type projLTInt8Int8Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projLTInt8Int8Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int8()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int8()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] < col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] < col2[i]
		}
	}
	return batch
}

func (p projLTInt8Int8Op) Init() {
	p.input.Init()
}

type projLEInt8Int8ConstOp struct {
	input Operator

	colIdx   int
	constArg int8

	outputIdx int
}

func (p *projLEInt8Int8ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int8()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] <= p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] <= p.constArg
		}
	}
	return batch
}

func (p projLEInt8Int8ConstOp) Init() {
	p.input.Init()
}

type projLEInt8Int8Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projLEInt8Int8Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int8()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int8()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] <= col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] <= col2[i]
		}
	}
	return batch
}

func (p projLEInt8Int8Op) Init() {
	p.input.Init()
}

type projGTInt8Int8ConstOp struct {
	input Operator

	colIdx   int
	constArg int8

	outputIdx int
}

func (p *projGTInt8Int8ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int8()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] > p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] > p.constArg
		}
	}
	return batch
}

func (p projGTInt8Int8ConstOp) Init() {
	p.input.Init()
}

type projGTInt8Int8Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projGTInt8Int8Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int8()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int8()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] > col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] > col2[i]
		}
	}
	return batch
}

func (p projGTInt8Int8Op) Init() {
	p.input.Init()
}

type projGEInt8Int8ConstOp struct {
	input Operator

	colIdx   int
	constArg int8

	outputIdx int
}

func (p *projGEInt8Int8ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int8()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] >= p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] >= p.constArg
		}
	}
	return batch
}

func (p projGEInt8Int8ConstOp) Init() {
	p.input.Init()
}

type projGEInt8Int8Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projGEInt8Int8Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int8()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int8()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] >= col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] >= col2[i]
		}
	}
	return batch
}

func (p projGEInt8Int8Op) Init() {
	p.input.Init()
}

type projEQInt16Int16ConstOp struct {
	input Operator

	colIdx   int
	constArg int16

	outputIdx int
}

func (p *projEQInt16Int16ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int16()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] == p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] == p.constArg
		}
	}
	return batch
}

func (p projEQInt16Int16ConstOp) Init() {
	p.input.Init()
}

type projEQInt16Int16Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projEQInt16Int16Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int16()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int16()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] == col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] == col2[i]
		}
	}
	return batch
}

func (p projEQInt16Int16Op) Init() {
	p.input.Init()
}

type projNEInt16Int16ConstOp struct {
	input Operator

	colIdx   int
	constArg int16

	outputIdx int
}

func (p *projNEInt16Int16ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int16()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] != p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] != p.constArg
		}
	}
	return batch
}

func (p projNEInt16Int16ConstOp) Init() {
	p.input.Init()
}

type projNEInt16Int16Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projNEInt16Int16Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int16()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int16()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] != col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] != col2[i]
		}
	}
	return batch
}

func (p projNEInt16Int16Op) Init() {
	p.input.Init()
}

type projLTInt16Int16ConstOp struct {
	input Operator

	colIdx   int
	constArg int16

	outputIdx int
}

func (p *projLTInt16Int16ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int16()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] < p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] < p.constArg
		}
	}
	return batch
}

func (p projLTInt16Int16ConstOp) Init() {
	p.input.Init()
}

type projLTInt16Int16Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projLTInt16Int16Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int16()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int16()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] < col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] < col2[i]
		}
	}
	return batch
}

func (p projLTInt16Int16Op) Init() {
	p.input.Init()
}

type projLEInt16Int16ConstOp struct {
	input Operator

	colIdx   int
	constArg int16

	outputIdx int
}

func (p *projLEInt16Int16ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int16()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] <= p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] <= p.constArg
		}
	}
	return batch
}

func (p projLEInt16Int16ConstOp) Init() {
	p.input.Init()
}

type projLEInt16Int16Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projLEInt16Int16Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int16()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int16()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] <= col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] <= col2[i]
		}
	}
	return batch
}

func (p projLEInt16Int16Op) Init() {
	p.input.Init()
}

type projGTInt16Int16ConstOp struct {
	input Operator

	colIdx   int
	constArg int16

	outputIdx int
}

func (p *projGTInt16Int16ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int16()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] > p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] > p.constArg
		}
	}
	return batch
}

func (p projGTInt16Int16ConstOp) Init() {
	p.input.Init()
}

type projGTInt16Int16Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projGTInt16Int16Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int16()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int16()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] > col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] > col2[i]
		}
	}
	return batch
}

func (p projGTInt16Int16Op) Init() {
	p.input.Init()
}

type projGEInt16Int16ConstOp struct {
	input Operator

	colIdx   int
	constArg int16

	outputIdx int
}

func (p *projGEInt16Int16ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int16()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] >= p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] >= p.constArg
		}
	}
	return batch
}

func (p projGEInt16Int16ConstOp) Init() {
	p.input.Init()
}

type projGEInt16Int16Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projGEInt16Int16Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int16()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int16()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] >= col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] >= col2[i]
		}
	}
	return batch
}

func (p projGEInt16Int16Op) Init() {
	p.input.Init()
}

type projEQInt32Int32ConstOp struct {
	input Operator

	colIdx   int
	constArg int32

	outputIdx int
}

func (p *projEQInt32Int32ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] == p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] == p.constArg
		}
	}
	return batch
}

func (p projEQInt32Int32ConstOp) Init() {
	p.input.Init()
}

type projEQInt32Int32Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projEQInt32Int32Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int32()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] == col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] == col2[i]
		}
	}
	return batch
}

func (p projEQInt32Int32Op) Init() {
	p.input.Init()
}

type projNEInt32Int32ConstOp struct {
	input Operator

	colIdx   int
	constArg int32

	outputIdx int
}

func (p *projNEInt32Int32ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] != p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] != p.constArg
		}
	}
	return batch
}

func (p projNEInt32Int32ConstOp) Init() {
	p.input.Init()
}

type projNEInt32Int32Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projNEInt32Int32Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int32()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] != col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] != col2[i]
		}
	}
	return batch
}

func (p projNEInt32Int32Op) Init() {
	p.input.Init()
}

type projLTInt32Int32ConstOp struct {
	input Operator

	colIdx   int
	constArg int32

	outputIdx int
}

func (p *projLTInt32Int32ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] < p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] < p.constArg
		}
	}
	return batch
}

func (p projLTInt32Int32ConstOp) Init() {
	p.input.Init()
}

type projLTInt32Int32Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projLTInt32Int32Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int32()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] < col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] < col2[i]
		}
	}
	return batch
}

func (p projLTInt32Int32Op) Init() {
	p.input.Init()
}

type projLEInt32Int32ConstOp struct {
	input Operator

	colIdx   int
	constArg int32

	outputIdx int
}

func (p *projLEInt32Int32ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] <= p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] <= p.constArg
		}
	}
	return batch
}

func (p projLEInt32Int32ConstOp) Init() {
	p.input.Init()
}

type projLEInt32Int32Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projLEInt32Int32Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int32()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] <= col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] <= col2[i]
		}
	}
	return batch
}

func (p projLEInt32Int32Op) Init() {
	p.input.Init()
}

type projGTInt32Int32ConstOp struct {
	input Operator

	colIdx   int
	constArg int32

	outputIdx int
}

func (p *projGTInt32Int32ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] > p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] > p.constArg
		}
	}
	return batch
}

func (p projGTInt32Int32ConstOp) Init() {
	p.input.Init()
}

type projGTInt32Int32Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projGTInt32Int32Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int32()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] > col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] > col2[i]
		}
	}
	return batch
}

func (p projGTInt32Int32Op) Init() {
	p.input.Init()
}

type projGEInt32Int32ConstOp struct {
	input Operator

	colIdx   int
	constArg int32

	outputIdx int
}

func (p *projGEInt32Int32ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] >= p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] >= p.constArg
		}
	}
	return batch
}

func (p projGEInt32Int32ConstOp) Init() {
	p.input.Init()
}

type projGEInt32Int32Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projGEInt32Int32Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int32()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] >= col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] >= col2[i]
		}
	}
	return batch
}

func (p projGEInt32Int32Op) Init() {
	p.input.Init()
}

type projEQInt64Int64ConstOp struct {
	input Operator

	colIdx   int
	constArg int64

	outputIdx int
}

func (p *projEQInt64Int64ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] == p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] == p.constArg
		}
	}
	return batch
}

func (p projEQInt64Int64ConstOp) Init() {
	p.input.Init()
}

type projEQInt64Int64Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projEQInt64Int64Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int64()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] == col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] == col2[i]
		}
	}
	return batch
}

func (p projEQInt64Int64Op) Init() {
	p.input.Init()
}

type projNEInt64Int64ConstOp struct {
	input Operator

	colIdx   int
	constArg int64

	outputIdx int
}

func (p *projNEInt64Int64ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] != p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] != p.constArg
		}
	}
	return batch
}

func (p projNEInt64Int64ConstOp) Init() {
	p.input.Init()
}

type projNEInt64Int64Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projNEInt64Int64Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int64()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] != col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] != col2[i]
		}
	}
	return batch
}

func (p projNEInt64Int64Op) Init() {
	p.input.Init()
}

type projLTInt64Int64ConstOp struct {
	input Operator

	colIdx   int
	constArg int64

	outputIdx int
}

func (p *projLTInt64Int64ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] < p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] < p.constArg
		}
	}
	return batch
}

func (p projLTInt64Int64ConstOp) Init() {
	p.input.Init()
}

type projLTInt64Int64Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projLTInt64Int64Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int64()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] < col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] < col2[i]
		}
	}
	return batch
}

func (p projLTInt64Int64Op) Init() {
	p.input.Init()
}

type projLEInt64Int64ConstOp struct {
	input Operator

	colIdx   int
	constArg int64

	outputIdx int
}

func (p *projLEInt64Int64ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] <= p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] <= p.constArg
		}
	}
	return batch
}

func (p projLEInt64Int64ConstOp) Init() {
	p.input.Init()
}

type projLEInt64Int64Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projLEInt64Int64Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int64()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] <= col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] <= col2[i]
		}
	}
	return batch
}

func (p projLEInt64Int64Op) Init() {
	p.input.Init()
}

type projGTInt64Int64ConstOp struct {
	input Operator

	colIdx   int
	constArg int64

	outputIdx int
}

func (p *projGTInt64Int64ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] > p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] > p.constArg
		}
	}
	return batch
}

func (p projGTInt64Int64ConstOp) Init() {
	p.input.Init()
}

type projGTInt64Int64Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projGTInt64Int64Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int64()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] > col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] > col2[i]
		}
	}
	return batch
}

func (p projGTInt64Int64Op) Init() {
	p.input.Init()
}

type projGEInt64Int64ConstOp struct {
	input Operator

	colIdx   int
	constArg int64

	outputIdx int
}

func (p *projGEInt64Int64ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Int64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] >= p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] >= p.constArg
		}
	}
	return batch
}

func (p projGEInt64Int64ConstOp) Init() {
	p.input.Init()
}

type projGEInt64Int64Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projGEInt64Int64Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Int64()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Int64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] >= col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] >= col2[i]
		}
	}
	return batch
}

func (p projGEInt64Int64Op) Init() {
	p.input.Init()
}

type projEQFloat32Float32ConstOp struct {
	input Operator

	colIdx   int
	constArg float32

	outputIdx int
}

func (p *projEQFloat32Float32ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Float32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] == p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] == p.constArg
		}
	}
	return batch
}

func (p projEQFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type projEQFloat32Float32Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projEQFloat32Float32Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Float32()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Float32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] == col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] == col2[i]
		}
	}
	return batch
}

func (p projEQFloat32Float32Op) Init() {
	p.input.Init()
}

type projNEFloat32Float32ConstOp struct {
	input Operator

	colIdx   int
	constArg float32

	outputIdx int
}

func (p *projNEFloat32Float32ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Float32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] != p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] != p.constArg
		}
	}
	return batch
}

func (p projNEFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type projNEFloat32Float32Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projNEFloat32Float32Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Float32()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Float32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] != col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] != col2[i]
		}
	}
	return batch
}

func (p projNEFloat32Float32Op) Init() {
	p.input.Init()
}

type projLTFloat32Float32ConstOp struct {
	input Operator

	colIdx   int
	constArg float32

	outputIdx int
}

func (p *projLTFloat32Float32ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Float32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] < p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] < p.constArg
		}
	}
	return batch
}

func (p projLTFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type projLTFloat32Float32Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projLTFloat32Float32Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Float32()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Float32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] < col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] < col2[i]
		}
	}
	return batch
}

func (p projLTFloat32Float32Op) Init() {
	p.input.Init()
}

type projLEFloat32Float32ConstOp struct {
	input Operator

	colIdx   int
	constArg float32

	outputIdx int
}

func (p *projLEFloat32Float32ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Float32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] <= p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] <= p.constArg
		}
	}
	return batch
}

func (p projLEFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type projLEFloat32Float32Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projLEFloat32Float32Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Float32()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Float32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] <= col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] <= col2[i]
		}
	}
	return batch
}

func (p projLEFloat32Float32Op) Init() {
	p.input.Init()
}

type projGTFloat32Float32ConstOp struct {
	input Operator

	colIdx   int
	constArg float32

	outputIdx int
}

func (p *projGTFloat32Float32ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Float32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] > p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] > p.constArg
		}
	}
	return batch
}

func (p projGTFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type projGTFloat32Float32Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projGTFloat32Float32Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Float32()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Float32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] > col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] > col2[i]
		}
	}
	return batch
}

func (p projGTFloat32Float32Op) Init() {
	p.input.Init()
}

type projGEFloat32Float32ConstOp struct {
	input Operator

	colIdx   int
	constArg float32

	outputIdx int
}

func (p *projGEFloat32Float32ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Float32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] >= p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] >= p.constArg
		}
	}
	return batch
}

func (p projGEFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type projGEFloat32Float32Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projGEFloat32Float32Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Float32()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Float32()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] >= col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] >= col2[i]
		}
	}
	return batch
}

func (p projGEFloat32Float32Op) Init() {
	p.input.Init()
}

type projEQFloat64Float64ConstOp struct {
	input Operator

	colIdx   int
	constArg float64

	outputIdx int
}

func (p *projEQFloat64Float64ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Float64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] == p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] == p.constArg
		}
	}
	return batch
}

func (p projEQFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type projEQFloat64Float64Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projEQFloat64Float64Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Float64()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Float64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] == col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] == col2[i]
		}
	}
	return batch
}

func (p projEQFloat64Float64Op) Init() {
	p.input.Init()
}

type projNEFloat64Float64ConstOp struct {
	input Operator

	colIdx   int
	constArg float64

	outputIdx int
}

func (p *projNEFloat64Float64ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Float64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] != p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] != p.constArg
		}
	}
	return batch
}

func (p projNEFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type projNEFloat64Float64Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projNEFloat64Float64Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Float64()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Float64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] != col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] != col2[i]
		}
	}
	return batch
}

func (p projNEFloat64Float64Op) Init() {
	p.input.Init()
}

type projLTFloat64Float64ConstOp struct {
	input Operator

	colIdx   int
	constArg float64

	outputIdx int
}

func (p *projLTFloat64Float64ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Float64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] < p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] < p.constArg
		}
	}
	return batch
}

func (p projLTFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type projLTFloat64Float64Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projLTFloat64Float64Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Float64()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Float64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] < col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] < col2[i]
		}
	}
	return batch
}

func (p projLTFloat64Float64Op) Init() {
	p.input.Init()
}

type projLEFloat64Float64ConstOp struct {
	input Operator

	colIdx   int
	constArg float64

	outputIdx int
}

func (p *projLEFloat64Float64ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Float64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] <= p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] <= p.constArg
		}
	}
	return batch
}

func (p projLEFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type projLEFloat64Float64Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projLEFloat64Float64Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Float64()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Float64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] <= col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] <= col2[i]
		}
	}
	return batch
}

func (p projLEFloat64Float64Op) Init() {
	p.input.Init()
}

type projGTFloat64Float64ConstOp struct {
	input Operator

	colIdx   int
	constArg float64

	outputIdx int
}

func (p *projGTFloat64Float64ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Float64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] > p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] > p.constArg
		}
	}
	return batch
}

func (p projGTFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type projGTFloat64Float64Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projGTFloat64Float64Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Float64()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Float64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] > col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] > col2[i]
		}
	}
	return batch
}

func (p projGTFloat64Float64Op) Init() {
	p.input.Init()
}

type projGEFloat64Float64ConstOp struct {
	input Operator

	colIdx   int
	constArg float64

	outputIdx int
}

func (p *projGEFloat64Float64ConstOp) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col := batch.ColVec(p.colIdx).Float64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col[i] >= p.constArg
		}
	} else {
		col = col[:n]
		for i := range col {
			projCol[i] = col[i] >= p.constArg
		}
	}
	return batch
}

func (p projGEFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type projGEFloat64Float64Op struct {
	input Operator

	col1Idx int
	col2Idx int

	outputIdx int
}

func (p *projGEFloat64Float64Op) Next() ColBatch {
	batch := p.input.Next()
	projCol := batch.ColVec(p.outputIdx).Bool()[:ColBatchSize]
	col1 := batch.ColVec(p.col1Idx).Float64()[:ColBatchSize]
	col2 := batch.ColVec(p.col2Idx).Float64()[:ColBatchSize]
	n := batch.Length()
	if sel := batch.Selection(); sel != nil {
		for _, i := range sel {
			projCol[i] = col1[i] >= col2[i]
		}
	} else {
		col1 = col1[:n]
		for i := range col1 {
			projCol[i] = col1[i] >= col2[i]
		}
	}
	return batch
}

func (p projGEFloat64Float64Op) Init() {
	p.input.Init()
}
