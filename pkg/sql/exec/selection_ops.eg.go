// Code generated by execgen; DO NOT EDIT.

package exec

import (
	"bytes"
	"context"
	"math"

	"github.com/cockroachdb/apd"
	"github.com/cockroachdb/cockroach/pkg/col/coldata"
	"github.com/cockroachdb/cockroach/pkg/col/coltypes"
	"github.com/cockroachdb/cockroach/pkg/sql/exec/execerror"
	"github.com/cockroachdb/cockroach/pkg/sql/exec/typeconv"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/types"
	"github.com/pkg/errors"
)

type selEQBoolBoolConstOp struct {
	OneInputNode

	colIdx   int
	constArg bool
}

func (p *selEQBoolBoolConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Bool()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQBoolBoolConstOp) Init() {
	p.input.Init()
}

type selEQBoolBoolOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQBoolBoolOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Bool()
		col2 := vec2.Bool()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQBoolBoolOp) Init() {
	p.input.Init()
}

type selNEBoolBoolConstOp struct {
	OneInputNode

	colIdx   int
	constArg bool
}

func (p *selNEBoolBoolConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Bool()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEBoolBoolConstOp) Init() {
	p.input.Init()
}

type selNEBoolBoolOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEBoolBoolOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Bool()
		col2 := vec2.Bool()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEBoolBoolOp) Init() {
	p.input.Init()
}

type selLTBoolBoolConstOp struct {
	OneInputNode

	colIdx   int
	constArg bool
}

func (p *selLTBoolBoolConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Bool()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTBoolBoolConstOp) Init() {
	p.input.Init()
}

type selLTBoolBoolOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTBoolBoolOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Bool()
		col2 := vec2.Bool()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTBoolBoolOp) Init() {
	p.input.Init()
}

type selLEBoolBoolConstOp struct {
	OneInputNode

	colIdx   int
	constArg bool
}

func (p *selLEBoolBoolConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Bool()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEBoolBoolConstOp) Init() {
	p.input.Init()
}

type selLEBoolBoolOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEBoolBoolOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Bool()
		col2 := vec2.Bool()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEBoolBoolOp) Init() {
	p.input.Init()
}

type selGTBoolBoolConstOp struct {
	OneInputNode

	colIdx   int
	constArg bool
}

func (p *selGTBoolBoolConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Bool()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTBoolBoolConstOp) Init() {
	p.input.Init()
}

type selGTBoolBoolOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTBoolBoolOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Bool()
		col2 := vec2.Bool()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTBoolBoolOp) Init() {
	p.input.Init()
}

type selGEBoolBoolConstOp struct {
	OneInputNode

	colIdx   int
	constArg bool
}

func (p *selGEBoolBoolConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Bool()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						if !arg && p.constArg {
							cmpResult = -1
						} else if arg && !p.constArg {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEBoolBoolConstOp) Init() {
	p.input.Init()
}

type selGEBoolBoolOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEBoolBoolOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Bool()
		col2 := vec2.Bool()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						if !arg1 && arg2 {
							cmpResult = -1
						} else if arg1 && !arg2 {
							cmpResult = 1
						} else {
							cmpResult = 0
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEBoolBoolOp) Init() {
	p.input.Init()
}

type selEQBytesBytesConstOp struct {
	OneInputNode

	colIdx   int
	constArg []byte
}

func (p *selEQBytesBytesConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Bytes()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(int(i))

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col.Slice(0, int(n))
				for i := 0; i < col.Len(); i++ {
					var cmp bool
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(int(i))

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col.Slice(0, int(n))
				for i := 0; i < col.Len(); i++ {
					var cmp bool
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQBytesBytesConstOp) Init() {
	p.input.Init()
}

type selEQBytesBytesOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQBytesBytesOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Bytes()
		col2 := vec2.Bytes()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(int(i))
					arg2 := col2.Get(int(i))

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1.Slice(0, int(n))
				col1Len := col1.Len()
				col2 = col2.Slice(0, col1Len)
				for i := 0; i < col1.Len(); i++ {
					var cmp bool
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(int(i))
					arg2 := col2.Get(int(i))

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1.Slice(0, int(n))
				col1Len := col1.Len()
				col2 = col2.Slice(0, col1Len)
				for i := 0; i < col1.Len(); i++ {
					var cmp bool
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQBytesBytesOp) Init() {
	p.input.Init()
}

type selNEBytesBytesConstOp struct {
	OneInputNode

	colIdx   int
	constArg []byte
}

func (p *selNEBytesBytesConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Bytes()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(int(i))

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col.Slice(0, int(n))
				for i := 0; i < col.Len(); i++ {
					var cmp bool
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(int(i))

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col.Slice(0, int(n))
				for i := 0; i < col.Len(); i++ {
					var cmp bool
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEBytesBytesConstOp) Init() {
	p.input.Init()
}

type selNEBytesBytesOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEBytesBytesOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Bytes()
		col2 := vec2.Bytes()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(int(i))
					arg2 := col2.Get(int(i))

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1.Slice(0, int(n))
				col1Len := col1.Len()
				col2 = col2.Slice(0, col1Len)
				for i := 0; i < col1.Len(); i++ {
					var cmp bool
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(int(i))
					arg2 := col2.Get(int(i))

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1.Slice(0, int(n))
				col1Len := col1.Len()
				col2 = col2.Slice(0, col1Len)
				for i := 0; i < col1.Len(); i++ {
					var cmp bool
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEBytesBytesOp) Init() {
	p.input.Init()
}

type selLTBytesBytesConstOp struct {
	OneInputNode

	colIdx   int
	constArg []byte
}

func (p *selLTBytesBytesConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Bytes()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(int(i))

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col.Slice(0, int(n))
				for i := 0; i < col.Len(); i++ {
					var cmp bool
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(int(i))

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col.Slice(0, int(n))
				for i := 0; i < col.Len(); i++ {
					var cmp bool
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTBytesBytesConstOp) Init() {
	p.input.Init()
}

type selLTBytesBytesOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTBytesBytesOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Bytes()
		col2 := vec2.Bytes()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(int(i))
					arg2 := col2.Get(int(i))

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1.Slice(0, int(n))
				col1Len := col1.Len()
				col2 = col2.Slice(0, col1Len)
				for i := 0; i < col1.Len(); i++ {
					var cmp bool
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(int(i))
					arg2 := col2.Get(int(i))

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1.Slice(0, int(n))
				col1Len := col1.Len()
				col2 = col2.Slice(0, col1Len)
				for i := 0; i < col1.Len(); i++ {
					var cmp bool
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTBytesBytesOp) Init() {
	p.input.Init()
}

type selLEBytesBytesConstOp struct {
	OneInputNode

	colIdx   int
	constArg []byte
}

func (p *selLEBytesBytesConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Bytes()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(int(i))

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col.Slice(0, int(n))
				for i := 0; i < col.Len(); i++ {
					var cmp bool
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(int(i))

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col.Slice(0, int(n))
				for i := 0; i < col.Len(); i++ {
					var cmp bool
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEBytesBytesConstOp) Init() {
	p.input.Init()
}

type selLEBytesBytesOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEBytesBytesOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Bytes()
		col2 := vec2.Bytes()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(int(i))
					arg2 := col2.Get(int(i))

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1.Slice(0, int(n))
				col1Len := col1.Len()
				col2 = col2.Slice(0, col1Len)
				for i := 0; i < col1.Len(); i++ {
					var cmp bool
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(int(i))
					arg2 := col2.Get(int(i))

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1.Slice(0, int(n))
				col1Len := col1.Len()
				col2 = col2.Slice(0, col1Len)
				for i := 0; i < col1.Len(); i++ {
					var cmp bool
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEBytesBytesOp) Init() {
	p.input.Init()
}

type selGTBytesBytesConstOp struct {
	OneInputNode

	colIdx   int
	constArg []byte
}

func (p *selGTBytesBytesConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Bytes()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(int(i))

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col.Slice(0, int(n))
				for i := 0; i < col.Len(); i++ {
					var cmp bool
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(int(i))

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col.Slice(0, int(n))
				for i := 0; i < col.Len(); i++ {
					var cmp bool
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTBytesBytesConstOp) Init() {
	p.input.Init()
}

type selGTBytesBytesOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTBytesBytesOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Bytes()
		col2 := vec2.Bytes()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(int(i))
					arg2 := col2.Get(int(i))

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1.Slice(0, int(n))
				col1Len := col1.Len()
				col2 = col2.Slice(0, col1Len)
				for i := 0; i < col1.Len(); i++ {
					var cmp bool
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(int(i))
					arg2 := col2.Get(int(i))

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1.Slice(0, int(n))
				col1Len := col1.Len()
				col2 = col2.Slice(0, col1Len)
				for i := 0; i < col1.Len(); i++ {
					var cmp bool
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTBytesBytesOp) Init() {
	p.input.Init()
}

type selGEBytesBytesConstOp struct {
	OneInputNode

	colIdx   int
	constArg []byte
}

func (p *selGEBytesBytesConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Bytes()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(int(i))

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col.Slice(0, int(n))
				for i := 0; i < col.Len(); i++ {
					var cmp bool
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col.Get(int(i))

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col.Slice(0, int(n))
				for i := 0; i < col.Len(); i++ {
					var cmp bool
					arg := col.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg, p.constArg)
						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEBytesBytesConstOp) Init() {
	p.input.Init()
}

type selGEBytesBytesOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEBytesBytesOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Bytes()
		col2 := vec2.Bytes()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(int(i))
					arg2 := col2.Get(int(i))

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1.Slice(0, int(n))
				col1Len := col1.Len()
				col2 = col2.Slice(0, col1Len)
				for i := 0; i < col1.Len(); i++ {
					var cmp bool
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1.Get(int(i))
					arg2 := col2.Get(int(i))

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1.Slice(0, int(n))
				col1Len := col1.Len()
				col2 = col2.Slice(0, col1Len)
				for i := 0; i < col1.Len(); i++ {
					var cmp bool
					arg1 := col1.Get(i)
					arg2 := col2.Get(i)

					{
						var cmpResult int
						cmpResult = bytes.Compare(arg1, arg2)
						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEBytesBytesOp) Init() {
	p.input.Init()
}

type selEQDecimalDecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selEQDecimalDecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQDecimalDecimalConstOp) Init() {
	p.input.Init()
}

type selEQDecimalDecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQDecimalDecimalOp) Init() {
	p.input.Init()
}

type selNEDecimalDecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selNEDecimalDecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEDecimalDecimalConstOp) Init() {
	p.input.Init()
}

type selNEDecimalDecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEDecimalDecimalOp) Init() {
	p.input.Init()
}

type selLTDecimalDecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selLTDecimalDecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTDecimalDecimalConstOp) Init() {
	p.input.Init()
}

type selLTDecimalDecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTDecimalDecimalOp) Init() {
	p.input.Init()
}

type selLEDecimalDecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selLEDecimalDecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEDecimalDecimalConstOp) Init() {
	p.input.Init()
}

type selLEDecimalDecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEDecimalDecimalOp) Init() {
	p.input.Init()
}

type selGTDecimalDecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selGTDecimalDecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTDecimalDecimalConstOp) Init() {
	p.input.Init()
}

type selGTDecimalDecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTDecimalDecimalOp) Init() {
	p.input.Init()
}

type selGEDecimalDecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selGEDecimalDecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg, &p.constArg)
						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEDecimalDecimalConstOp) Init() {
	p.input.Init()
}

type selGEDecimalDecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEDecimalDecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int
						cmpResult = tree.CompareDecimals(&arg1, &arg2)
						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEDecimalDecimalOp) Init() {
	p.input.Init()
}

type selEQDecimalInt8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selEQDecimalInt8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQDecimalInt8ConstOp) Init() {
	p.input.Init()
}

type selEQDecimalInt8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQDecimalInt8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQDecimalInt8Op) Init() {
	p.input.Init()
}

type selNEDecimalInt8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selNEDecimalInt8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEDecimalInt8ConstOp) Init() {
	p.input.Init()
}

type selNEDecimalInt8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEDecimalInt8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEDecimalInt8Op) Init() {
	p.input.Init()
}

type selLTDecimalInt8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selLTDecimalInt8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTDecimalInt8ConstOp) Init() {
	p.input.Init()
}

type selLTDecimalInt8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTDecimalInt8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTDecimalInt8Op) Init() {
	p.input.Init()
}

type selLEDecimalInt8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selLEDecimalInt8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEDecimalInt8ConstOp) Init() {
	p.input.Init()
}

type selLEDecimalInt8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEDecimalInt8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEDecimalInt8Op) Init() {
	p.input.Init()
}

type selGTDecimalInt8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selGTDecimalInt8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTDecimalInt8ConstOp) Init() {
	p.input.Init()
}

type selGTDecimalInt8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTDecimalInt8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTDecimalInt8Op) Init() {
	p.input.Init()
}

type selGEDecimalInt8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selGEDecimalInt8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEDecimalInt8ConstOp) Init() {
	p.input.Init()
}

type selGEDecimalInt8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEDecimalInt8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEDecimalInt8Op) Init() {
	p.input.Init()
}

type selEQDecimalInt16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selEQDecimalInt16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQDecimalInt16ConstOp) Init() {
	p.input.Init()
}

type selEQDecimalInt16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQDecimalInt16Op) Init() {
	p.input.Init()
}

type selNEDecimalInt16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selNEDecimalInt16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEDecimalInt16ConstOp) Init() {
	p.input.Init()
}

type selNEDecimalInt16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEDecimalInt16Op) Init() {
	p.input.Init()
}

type selLTDecimalInt16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selLTDecimalInt16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTDecimalInt16ConstOp) Init() {
	p.input.Init()
}

type selLTDecimalInt16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTDecimalInt16Op) Init() {
	p.input.Init()
}

type selLEDecimalInt16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selLEDecimalInt16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEDecimalInt16ConstOp) Init() {
	p.input.Init()
}

type selLEDecimalInt16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEDecimalInt16Op) Init() {
	p.input.Init()
}

type selGTDecimalInt16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selGTDecimalInt16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTDecimalInt16ConstOp) Init() {
	p.input.Init()
}

type selGTDecimalInt16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTDecimalInt16Op) Init() {
	p.input.Init()
}

type selGEDecimalInt16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selGEDecimalInt16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEDecimalInt16ConstOp) Init() {
	p.input.Init()
}

type selGEDecimalInt16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEDecimalInt16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEDecimalInt16Op) Init() {
	p.input.Init()
}

type selEQDecimalInt32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selEQDecimalInt32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQDecimalInt32ConstOp) Init() {
	p.input.Init()
}

type selEQDecimalInt32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQDecimalInt32Op) Init() {
	p.input.Init()
}

type selNEDecimalInt32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selNEDecimalInt32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEDecimalInt32ConstOp) Init() {
	p.input.Init()
}

type selNEDecimalInt32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEDecimalInt32Op) Init() {
	p.input.Init()
}

type selLTDecimalInt32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selLTDecimalInt32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTDecimalInt32ConstOp) Init() {
	p.input.Init()
}

type selLTDecimalInt32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTDecimalInt32Op) Init() {
	p.input.Init()
}

type selLEDecimalInt32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selLEDecimalInt32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEDecimalInt32ConstOp) Init() {
	p.input.Init()
}

type selLEDecimalInt32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEDecimalInt32Op) Init() {
	p.input.Init()
}

type selGTDecimalInt32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selGTDecimalInt32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTDecimalInt32ConstOp) Init() {
	p.input.Init()
}

type selGTDecimalInt32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTDecimalInt32Op) Init() {
	p.input.Init()
}

type selGEDecimalInt32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selGEDecimalInt32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEDecimalInt32ConstOp) Init() {
	p.input.Init()
}

type selGEDecimalInt32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEDecimalInt32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEDecimalInt32Op) Init() {
	p.input.Init()
}

type selEQDecimalInt64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selEQDecimalInt64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQDecimalInt64ConstOp) Init() {
	p.input.Init()
}

type selEQDecimalInt64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQDecimalInt64Op) Init() {
	p.input.Init()
}

type selNEDecimalInt64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selNEDecimalInt64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEDecimalInt64ConstOp) Init() {
	p.input.Init()
}

type selNEDecimalInt64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEDecimalInt64Op) Init() {
	p.input.Init()
}

type selLTDecimalInt64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selLTDecimalInt64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTDecimalInt64ConstOp) Init() {
	p.input.Init()
}

type selLTDecimalInt64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTDecimalInt64Op) Init() {
	p.input.Init()
}

type selLEDecimalInt64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selLEDecimalInt64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEDecimalInt64ConstOp) Init() {
	p.input.Init()
}

type selLEDecimalInt64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEDecimalInt64Op) Init() {
	p.input.Init()
}

type selGTDecimalInt64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selGTDecimalInt64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTDecimalInt64ConstOp) Init() {
	p.input.Init()
}

type selGTDecimalInt64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTDecimalInt64Op) Init() {
	p.input.Init()
}

type selGEDecimalInt64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selGEDecimalInt64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(p.constArg), 0)
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEDecimalInt64ConstOp) Init() {
	p.input.Init()
}

type selGEDecimalInt64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEDecimalInt64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg2), 0)
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEDecimalInt64Op) Init() {
	p.input.Init()
}

type selEQDecimalFloat32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selEQDecimalFloat32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQDecimalFloat32ConstOp) Init() {
	p.input.Init()
}

type selEQDecimalFloat32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQDecimalFloat32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQDecimalFloat32Op) Init() {
	p.input.Init()
}

type selNEDecimalFloat32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selNEDecimalFloat32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEDecimalFloat32ConstOp) Init() {
	p.input.Init()
}

type selNEDecimalFloat32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEDecimalFloat32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEDecimalFloat32Op) Init() {
	p.input.Init()
}

type selLTDecimalFloat32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selLTDecimalFloat32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTDecimalFloat32ConstOp) Init() {
	p.input.Init()
}

type selLTDecimalFloat32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTDecimalFloat32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTDecimalFloat32Op) Init() {
	p.input.Init()
}

type selLEDecimalFloat32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selLEDecimalFloat32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEDecimalFloat32ConstOp) Init() {
	p.input.Init()
}

type selLEDecimalFloat32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEDecimalFloat32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEDecimalFloat32Op) Init() {
	p.input.Init()
}

type selGTDecimalFloat32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selGTDecimalFloat32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTDecimalFloat32ConstOp) Init() {
	p.input.Init()
}

type selGTDecimalFloat32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTDecimalFloat32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTDecimalFloat32Op) Init() {
	p.input.Init()
}

type selGEDecimalFloat32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selGEDecimalFloat32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEDecimalFloat32ConstOp) Init() {
	p.input.Init()
}

type selGEDecimalFloat32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEDecimalFloat32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEDecimalFloat32Op) Init() {
	p.input.Init()
}

type selEQDecimalFloat64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selEQDecimalFloat64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQDecimalFloat64ConstOp) Init() {
	p.input.Init()
}

type selEQDecimalFloat64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQDecimalFloat64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQDecimalFloat64Op) Init() {
	p.input.Init()
}

type selNEDecimalFloat64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selNEDecimalFloat64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEDecimalFloat64ConstOp) Init() {
	p.input.Init()
}

type selNEDecimalFloat64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEDecimalFloat64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEDecimalFloat64Op) Init() {
	p.input.Init()
}

type selLTDecimalFloat64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selLTDecimalFloat64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTDecimalFloat64ConstOp) Init() {
	p.input.Init()
}

type selLTDecimalFloat64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTDecimalFloat64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTDecimalFloat64Op) Init() {
	p.input.Init()
}

type selLEDecimalFloat64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selLEDecimalFloat64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEDecimalFloat64ConstOp) Init() {
	p.input.Init()
}

type selLEDecimalFloat64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEDecimalFloat64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEDecimalFloat64Op) Init() {
	p.input.Init()
}

type selGTDecimalFloat64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selGTDecimalFloat64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTDecimalFloat64ConstOp) Init() {
	p.input.Init()
}

type selGTDecimalFloat64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTDecimalFloat64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTDecimalFloat64Op) Init() {
	p.input.Init()
}

type selGEDecimalFloat64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selGEDecimalFloat64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Decimal()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(p.constArg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEDecimalFloat64ConstOp) Init() {
	p.input.Init()
}

type selGEDecimalFloat64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEDecimalFloat64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Decimal()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg2)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(&arg1, tmpDec)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEDecimalFloat64Op) Init() {
	p.input.Init()
}

type selEQInt8DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selEQInt8DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt8DecimalConstOp) Init() {
	p.input.Init()
}

type selEQInt8DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQInt8DecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt8DecimalOp) Init() {
	p.input.Init()
}

type selNEInt8DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selNEInt8DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt8DecimalConstOp) Init() {
	p.input.Init()
}

type selNEInt8DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEInt8DecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt8DecimalOp) Init() {
	p.input.Init()
}

type selLTInt8DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selLTInt8DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt8DecimalConstOp) Init() {
	p.input.Init()
}

type selLTInt8DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTInt8DecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt8DecimalOp) Init() {
	p.input.Init()
}

type selLEInt8DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selLEInt8DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt8DecimalConstOp) Init() {
	p.input.Init()
}

type selLEInt8DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEInt8DecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt8DecimalOp) Init() {
	p.input.Init()
}

type selGTInt8DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selGTInt8DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt8DecimalConstOp) Init() {
	p.input.Init()
}

type selGTInt8DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTInt8DecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt8DecimalOp) Init() {
	p.input.Init()
}

type selGEInt8DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selGEInt8DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt8DecimalConstOp) Init() {
	p.input.Init()
}

type selGEInt8DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEInt8DecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt8DecimalOp) Init() {
	p.input.Init()
}

type selEQInt8Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selEQInt8Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt8Int8ConstOp) Init() {
	p.input.Init()
}

type selEQInt8Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQInt8Int8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt8Int8Op) Init() {
	p.input.Init()
}

type selNEInt8Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selNEInt8Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt8Int8ConstOp) Init() {
	p.input.Init()
}

type selNEInt8Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEInt8Int8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt8Int8Op) Init() {
	p.input.Init()
}

type selLTInt8Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selLTInt8Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt8Int8ConstOp) Init() {
	p.input.Init()
}

type selLTInt8Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTInt8Int8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt8Int8Op) Init() {
	p.input.Init()
}

type selLEInt8Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selLEInt8Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt8Int8ConstOp) Init() {
	p.input.Init()
}

type selLEInt8Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEInt8Int8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt8Int8Op) Init() {
	p.input.Init()
}

type selGTInt8Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selGTInt8Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt8Int8ConstOp) Init() {
	p.input.Init()
}

type selGTInt8Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTInt8Int8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt8Int8Op) Init() {
	p.input.Init()
}

type selGEInt8Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selGEInt8Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt8Int8ConstOp) Init() {
	p.input.Init()
}

type selGEInt8Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEInt8Int8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt8Int8Op) Init() {
	p.input.Init()
}

type selEQInt8Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selEQInt8Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt8Int16ConstOp) Init() {
	p.input.Init()
}

type selEQInt8Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQInt8Int16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt8Int16Op) Init() {
	p.input.Init()
}

type selNEInt8Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selNEInt8Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt8Int16ConstOp) Init() {
	p.input.Init()
}

type selNEInt8Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEInt8Int16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt8Int16Op) Init() {
	p.input.Init()
}

type selLTInt8Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selLTInt8Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt8Int16ConstOp) Init() {
	p.input.Init()
}

type selLTInt8Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTInt8Int16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt8Int16Op) Init() {
	p.input.Init()
}

type selLEInt8Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selLEInt8Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt8Int16ConstOp) Init() {
	p.input.Init()
}

type selLEInt8Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEInt8Int16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt8Int16Op) Init() {
	p.input.Init()
}

type selGTInt8Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selGTInt8Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt8Int16ConstOp) Init() {
	p.input.Init()
}

type selGTInt8Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTInt8Int16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt8Int16Op) Init() {
	p.input.Init()
}

type selGEInt8Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selGEInt8Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt8Int16ConstOp) Init() {
	p.input.Init()
}

type selGEInt8Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEInt8Int16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt8Int16Op) Init() {
	p.input.Init()
}

type selEQInt8Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selEQInt8Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt8Int32ConstOp) Init() {
	p.input.Init()
}

type selEQInt8Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQInt8Int32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt8Int32Op) Init() {
	p.input.Init()
}

type selNEInt8Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selNEInt8Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt8Int32ConstOp) Init() {
	p.input.Init()
}

type selNEInt8Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEInt8Int32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt8Int32Op) Init() {
	p.input.Init()
}

type selLTInt8Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selLTInt8Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt8Int32ConstOp) Init() {
	p.input.Init()
}

type selLTInt8Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTInt8Int32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt8Int32Op) Init() {
	p.input.Init()
}

type selLEInt8Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selLEInt8Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt8Int32ConstOp) Init() {
	p.input.Init()
}

type selLEInt8Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEInt8Int32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt8Int32Op) Init() {
	p.input.Init()
}

type selGTInt8Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selGTInt8Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt8Int32ConstOp) Init() {
	p.input.Init()
}

type selGTInt8Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTInt8Int32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt8Int32Op) Init() {
	p.input.Init()
}

type selGEInt8Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selGEInt8Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt8Int32ConstOp) Init() {
	p.input.Init()
}

type selGEInt8Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEInt8Int32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt8Int32Op) Init() {
	p.input.Init()
}

type selEQInt8Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selEQInt8Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt8Int64ConstOp) Init() {
	p.input.Init()
}

type selEQInt8Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQInt8Int64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt8Int64Op) Init() {
	p.input.Init()
}

type selNEInt8Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selNEInt8Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt8Int64ConstOp) Init() {
	p.input.Init()
}

type selNEInt8Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEInt8Int64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt8Int64Op) Init() {
	p.input.Init()
}

type selLTInt8Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selLTInt8Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt8Int64ConstOp) Init() {
	p.input.Init()
}

type selLTInt8Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTInt8Int64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt8Int64Op) Init() {
	p.input.Init()
}

type selLEInt8Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selLEInt8Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt8Int64ConstOp) Init() {
	p.input.Init()
}

type selLEInt8Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEInt8Int64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt8Int64Op) Init() {
	p.input.Init()
}

type selGTInt8Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selGTInt8Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt8Int64ConstOp) Init() {
	p.input.Init()
}

type selGTInt8Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTInt8Int64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt8Int64Op) Init() {
	p.input.Init()
}

type selGEInt8Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selGEInt8Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt8Int64ConstOp) Init() {
	p.input.Init()
}

type selGEInt8Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEInt8Int64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt8Int64Op) Init() {
	p.input.Init()
}

type selEQInt8Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selEQInt8Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt8Float32ConstOp) Init() {
	p.input.Init()
}

type selEQInt8Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQInt8Float32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt8Float32Op) Init() {
	p.input.Init()
}

type selNEInt8Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selNEInt8Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt8Float32ConstOp) Init() {
	p.input.Init()
}

type selNEInt8Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEInt8Float32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt8Float32Op) Init() {
	p.input.Init()
}

type selLTInt8Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selLTInt8Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt8Float32ConstOp) Init() {
	p.input.Init()
}

type selLTInt8Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTInt8Float32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt8Float32Op) Init() {
	p.input.Init()
}

type selLEInt8Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selLEInt8Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt8Float32ConstOp) Init() {
	p.input.Init()
}

type selLEInt8Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEInt8Float32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt8Float32Op) Init() {
	p.input.Init()
}

type selGTInt8Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selGTInt8Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt8Float32ConstOp) Init() {
	p.input.Init()
}

type selGTInt8Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTInt8Float32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt8Float32Op) Init() {
	p.input.Init()
}

type selGEInt8Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selGEInt8Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt8Float32ConstOp) Init() {
	p.input.Init()
}

type selGEInt8Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEInt8Float32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt8Float32Op) Init() {
	p.input.Init()
}

type selEQInt8Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selEQInt8Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt8Float64ConstOp) Init() {
	p.input.Init()
}

type selEQInt8Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQInt8Float64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt8Float64Op) Init() {
	p.input.Init()
}

type selNEInt8Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selNEInt8Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt8Float64ConstOp) Init() {
	p.input.Init()
}

type selNEInt8Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEInt8Float64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt8Float64Op) Init() {
	p.input.Init()
}

type selLTInt8Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selLTInt8Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt8Float64ConstOp) Init() {
	p.input.Init()
}

type selLTInt8Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTInt8Float64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt8Float64Op) Init() {
	p.input.Init()
}

type selLEInt8Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selLEInt8Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt8Float64ConstOp) Init() {
	p.input.Init()
}

type selLEInt8Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEInt8Float64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt8Float64Op) Init() {
	p.input.Init()
}

type selGTInt8Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selGTInt8Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt8Float64ConstOp) Init() {
	p.input.Init()
}

type selGTInt8Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTInt8Float64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt8Float64Op) Init() {
	p.input.Init()
}

type selGEInt8Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selGEInt8Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int8()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt8Float64ConstOp) Init() {
	p.input.Init()
}

type selGEInt8Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEInt8Float64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int8()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt8Float64Op) Init() {
	p.input.Init()
}

type selEQInt16DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selEQInt16DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt16DecimalConstOp) Init() {
	p.input.Init()
}

type selEQInt16DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt16DecimalOp) Init() {
	p.input.Init()
}

type selNEInt16DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selNEInt16DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt16DecimalConstOp) Init() {
	p.input.Init()
}

type selNEInt16DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt16DecimalOp) Init() {
	p.input.Init()
}

type selLTInt16DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selLTInt16DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt16DecimalConstOp) Init() {
	p.input.Init()
}

type selLTInt16DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt16DecimalOp) Init() {
	p.input.Init()
}

type selLEInt16DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selLEInt16DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt16DecimalConstOp) Init() {
	p.input.Init()
}

type selLEInt16DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt16DecimalOp) Init() {
	p.input.Init()
}

type selGTInt16DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selGTInt16DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt16DecimalConstOp) Init() {
	p.input.Init()
}

type selGTInt16DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt16DecimalOp) Init() {
	p.input.Init()
}

type selGEInt16DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selGEInt16DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt16DecimalConstOp) Init() {
	p.input.Init()
}

type selGEInt16DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEInt16DecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt16DecimalOp) Init() {
	p.input.Init()
}

type selEQInt16Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selEQInt16Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt16Int8ConstOp) Init() {
	p.input.Init()
}

type selEQInt16Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQInt16Int8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt16Int8Op) Init() {
	p.input.Init()
}

type selNEInt16Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selNEInt16Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt16Int8ConstOp) Init() {
	p.input.Init()
}

type selNEInt16Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEInt16Int8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt16Int8Op) Init() {
	p.input.Init()
}

type selLTInt16Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selLTInt16Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt16Int8ConstOp) Init() {
	p.input.Init()
}

type selLTInt16Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTInt16Int8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt16Int8Op) Init() {
	p.input.Init()
}

type selLEInt16Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selLEInt16Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt16Int8ConstOp) Init() {
	p.input.Init()
}

type selLEInt16Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEInt16Int8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt16Int8Op) Init() {
	p.input.Init()
}

type selGTInt16Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selGTInt16Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt16Int8ConstOp) Init() {
	p.input.Init()
}

type selGTInt16Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTInt16Int8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt16Int8Op) Init() {
	p.input.Init()
}

type selGEInt16Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selGEInt16Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt16Int8ConstOp) Init() {
	p.input.Init()
}

type selGEInt16Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEInt16Int8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt16Int8Op) Init() {
	p.input.Init()
}

type selEQInt16Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selEQInt16Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt16Int16ConstOp) Init() {
	p.input.Init()
}

type selEQInt16Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt16Int16Op) Init() {
	p.input.Init()
}

type selNEInt16Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selNEInt16Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt16Int16ConstOp) Init() {
	p.input.Init()
}

type selNEInt16Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt16Int16Op) Init() {
	p.input.Init()
}

type selLTInt16Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selLTInt16Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt16Int16ConstOp) Init() {
	p.input.Init()
}

type selLTInt16Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt16Int16Op) Init() {
	p.input.Init()
}

type selLEInt16Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selLEInt16Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt16Int16ConstOp) Init() {
	p.input.Init()
}

type selLEInt16Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt16Int16Op) Init() {
	p.input.Init()
}

type selGTInt16Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selGTInt16Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt16Int16ConstOp) Init() {
	p.input.Init()
}

type selGTInt16Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt16Int16Op) Init() {
	p.input.Init()
}

type selGEInt16Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selGEInt16Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt16Int16ConstOp) Init() {
	p.input.Init()
}

type selGEInt16Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEInt16Int16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt16Int16Op) Init() {
	p.input.Init()
}

type selEQInt16Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selEQInt16Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt16Int32ConstOp) Init() {
	p.input.Init()
}

type selEQInt16Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt16Int32Op) Init() {
	p.input.Init()
}

type selNEInt16Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selNEInt16Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt16Int32ConstOp) Init() {
	p.input.Init()
}

type selNEInt16Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt16Int32Op) Init() {
	p.input.Init()
}

type selLTInt16Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selLTInt16Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt16Int32ConstOp) Init() {
	p.input.Init()
}

type selLTInt16Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt16Int32Op) Init() {
	p.input.Init()
}

type selLEInt16Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selLEInt16Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt16Int32ConstOp) Init() {
	p.input.Init()
}

type selLEInt16Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt16Int32Op) Init() {
	p.input.Init()
}

type selGTInt16Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selGTInt16Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt16Int32ConstOp) Init() {
	p.input.Init()
}

type selGTInt16Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt16Int32Op) Init() {
	p.input.Init()
}

type selGEInt16Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selGEInt16Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt16Int32ConstOp) Init() {
	p.input.Init()
}

type selGEInt16Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEInt16Int32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt16Int32Op) Init() {
	p.input.Init()
}

type selEQInt16Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selEQInt16Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt16Int64ConstOp) Init() {
	p.input.Init()
}

type selEQInt16Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt16Int64Op) Init() {
	p.input.Init()
}

type selNEInt16Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selNEInt16Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt16Int64ConstOp) Init() {
	p.input.Init()
}

type selNEInt16Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt16Int64Op) Init() {
	p.input.Init()
}

type selLTInt16Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selLTInt16Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt16Int64ConstOp) Init() {
	p.input.Init()
}

type selLTInt16Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt16Int64Op) Init() {
	p.input.Init()
}

type selLEInt16Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selLEInt16Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt16Int64ConstOp) Init() {
	p.input.Init()
}

type selLEInt16Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt16Int64Op) Init() {
	p.input.Init()
}

type selGTInt16Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selGTInt16Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt16Int64ConstOp) Init() {
	p.input.Init()
}

type selGTInt16Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt16Int64Op) Init() {
	p.input.Init()
}

type selGEInt16Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selGEInt16Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt16Int64ConstOp) Init() {
	p.input.Init()
}

type selGEInt16Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEInt16Int64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt16Int64Op) Init() {
	p.input.Init()
}

type selEQInt16Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selEQInt16Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt16Float32ConstOp) Init() {
	p.input.Init()
}

type selEQInt16Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQInt16Float32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt16Float32Op) Init() {
	p.input.Init()
}

type selNEInt16Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selNEInt16Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt16Float32ConstOp) Init() {
	p.input.Init()
}

type selNEInt16Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEInt16Float32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt16Float32Op) Init() {
	p.input.Init()
}

type selLTInt16Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selLTInt16Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt16Float32ConstOp) Init() {
	p.input.Init()
}

type selLTInt16Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTInt16Float32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt16Float32Op) Init() {
	p.input.Init()
}

type selLEInt16Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selLEInt16Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt16Float32ConstOp) Init() {
	p.input.Init()
}

type selLEInt16Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEInt16Float32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt16Float32Op) Init() {
	p.input.Init()
}

type selGTInt16Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selGTInt16Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt16Float32ConstOp) Init() {
	p.input.Init()
}

type selGTInt16Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTInt16Float32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt16Float32Op) Init() {
	p.input.Init()
}

type selGEInt16Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selGEInt16Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt16Float32ConstOp) Init() {
	p.input.Init()
}

type selGEInt16Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEInt16Float32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt16Float32Op) Init() {
	p.input.Init()
}

type selEQInt16Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selEQInt16Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt16Float64ConstOp) Init() {
	p.input.Init()
}

type selEQInt16Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQInt16Float64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt16Float64Op) Init() {
	p.input.Init()
}

type selNEInt16Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selNEInt16Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt16Float64ConstOp) Init() {
	p.input.Init()
}

type selNEInt16Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEInt16Float64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt16Float64Op) Init() {
	p.input.Init()
}

type selLTInt16Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selLTInt16Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt16Float64ConstOp) Init() {
	p.input.Init()
}

type selLTInt16Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTInt16Float64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt16Float64Op) Init() {
	p.input.Init()
}

type selLEInt16Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selLEInt16Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt16Float64ConstOp) Init() {
	p.input.Init()
}

type selLEInt16Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEInt16Float64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt16Float64Op) Init() {
	p.input.Init()
}

type selGTInt16Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selGTInt16Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt16Float64ConstOp) Init() {
	p.input.Init()
}

type selGTInt16Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTInt16Float64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt16Float64Op) Init() {
	p.input.Init()
}

type selGEInt16Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selGEInt16Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int16()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt16Float64ConstOp) Init() {
	p.input.Init()
}

type selGEInt16Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEInt16Float64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int16()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt16Float64Op) Init() {
	p.input.Init()
}

type selEQInt32DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selEQInt32DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt32DecimalConstOp) Init() {
	p.input.Init()
}

type selEQInt32DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt32DecimalOp) Init() {
	p.input.Init()
}

type selNEInt32DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selNEInt32DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt32DecimalConstOp) Init() {
	p.input.Init()
}

type selNEInt32DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt32DecimalOp) Init() {
	p.input.Init()
}

type selLTInt32DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selLTInt32DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt32DecimalConstOp) Init() {
	p.input.Init()
}

type selLTInt32DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt32DecimalOp) Init() {
	p.input.Init()
}

type selLEInt32DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selLEInt32DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt32DecimalConstOp) Init() {
	p.input.Init()
}

type selLEInt32DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt32DecimalOp) Init() {
	p.input.Init()
}

type selGTInt32DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selGTInt32DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt32DecimalConstOp) Init() {
	p.input.Init()
}

type selGTInt32DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt32DecimalOp) Init() {
	p.input.Init()
}

type selGEInt32DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selGEInt32DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt32DecimalConstOp) Init() {
	p.input.Init()
}

type selGEInt32DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEInt32DecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt32DecimalOp) Init() {
	p.input.Init()
}

type selEQInt32Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selEQInt32Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt32Int8ConstOp) Init() {
	p.input.Init()
}

type selEQInt32Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQInt32Int8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt32Int8Op) Init() {
	p.input.Init()
}

type selNEInt32Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selNEInt32Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt32Int8ConstOp) Init() {
	p.input.Init()
}

type selNEInt32Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEInt32Int8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt32Int8Op) Init() {
	p.input.Init()
}

type selLTInt32Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selLTInt32Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt32Int8ConstOp) Init() {
	p.input.Init()
}

type selLTInt32Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTInt32Int8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt32Int8Op) Init() {
	p.input.Init()
}

type selLEInt32Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selLEInt32Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt32Int8ConstOp) Init() {
	p.input.Init()
}

type selLEInt32Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEInt32Int8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt32Int8Op) Init() {
	p.input.Init()
}

type selGTInt32Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selGTInt32Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt32Int8ConstOp) Init() {
	p.input.Init()
}

type selGTInt32Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTInt32Int8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt32Int8Op) Init() {
	p.input.Init()
}

type selGEInt32Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selGEInt32Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt32Int8ConstOp) Init() {
	p.input.Init()
}

type selGEInt32Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEInt32Int8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt32Int8Op) Init() {
	p.input.Init()
}

type selEQInt32Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selEQInt32Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt32Int16ConstOp) Init() {
	p.input.Init()
}

type selEQInt32Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt32Int16Op) Init() {
	p.input.Init()
}

type selNEInt32Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selNEInt32Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt32Int16ConstOp) Init() {
	p.input.Init()
}

type selNEInt32Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt32Int16Op) Init() {
	p.input.Init()
}

type selLTInt32Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selLTInt32Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt32Int16ConstOp) Init() {
	p.input.Init()
}

type selLTInt32Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt32Int16Op) Init() {
	p.input.Init()
}

type selLEInt32Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selLEInt32Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt32Int16ConstOp) Init() {
	p.input.Init()
}

type selLEInt32Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt32Int16Op) Init() {
	p.input.Init()
}

type selGTInt32Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selGTInt32Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt32Int16ConstOp) Init() {
	p.input.Init()
}

type selGTInt32Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt32Int16Op) Init() {
	p.input.Init()
}

type selGEInt32Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selGEInt32Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt32Int16ConstOp) Init() {
	p.input.Init()
}

type selGEInt32Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEInt32Int16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt32Int16Op) Init() {
	p.input.Init()
}

type selEQInt32Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selEQInt32Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt32Int32ConstOp) Init() {
	p.input.Init()
}

type selEQInt32Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt32Int32Op) Init() {
	p.input.Init()
}

type selNEInt32Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selNEInt32Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt32Int32ConstOp) Init() {
	p.input.Init()
}

type selNEInt32Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt32Int32Op) Init() {
	p.input.Init()
}

type selLTInt32Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selLTInt32Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt32Int32ConstOp) Init() {
	p.input.Init()
}

type selLTInt32Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt32Int32Op) Init() {
	p.input.Init()
}

type selLEInt32Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selLEInt32Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt32Int32ConstOp) Init() {
	p.input.Init()
}

type selLEInt32Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt32Int32Op) Init() {
	p.input.Init()
}

type selGTInt32Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selGTInt32Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt32Int32ConstOp) Init() {
	p.input.Init()
}

type selGTInt32Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt32Int32Op) Init() {
	p.input.Init()
}

type selGEInt32Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selGEInt32Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt32Int32ConstOp) Init() {
	p.input.Init()
}

type selGEInt32Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEInt32Int32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt32Int32Op) Init() {
	p.input.Init()
}

type selEQInt32Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selEQInt32Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt32Int64ConstOp) Init() {
	p.input.Init()
}

type selEQInt32Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt32Int64Op) Init() {
	p.input.Init()
}

type selNEInt32Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selNEInt32Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt32Int64ConstOp) Init() {
	p.input.Init()
}

type selNEInt32Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt32Int64Op) Init() {
	p.input.Init()
}

type selLTInt32Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selLTInt32Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt32Int64ConstOp) Init() {
	p.input.Init()
}

type selLTInt32Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt32Int64Op) Init() {
	p.input.Init()
}

type selLEInt32Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selLEInt32Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt32Int64ConstOp) Init() {
	p.input.Init()
}

type selLEInt32Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt32Int64Op) Init() {
	p.input.Init()
}

type selGTInt32Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selGTInt32Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt32Int64ConstOp) Init() {
	p.input.Init()
}

type selGTInt32Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt32Int64Op) Init() {
	p.input.Init()
}

type selGEInt32Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selGEInt32Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt32Int64ConstOp) Init() {
	p.input.Init()
}

type selGEInt32Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEInt32Int64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt32Int64Op) Init() {
	p.input.Init()
}

type selEQInt32Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selEQInt32Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt32Float32ConstOp) Init() {
	p.input.Init()
}

type selEQInt32Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQInt32Float32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt32Float32Op) Init() {
	p.input.Init()
}

type selNEInt32Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selNEInt32Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt32Float32ConstOp) Init() {
	p.input.Init()
}

type selNEInt32Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEInt32Float32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt32Float32Op) Init() {
	p.input.Init()
}

type selLTInt32Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selLTInt32Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt32Float32ConstOp) Init() {
	p.input.Init()
}

type selLTInt32Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTInt32Float32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt32Float32Op) Init() {
	p.input.Init()
}

type selLEInt32Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selLEInt32Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt32Float32ConstOp) Init() {
	p.input.Init()
}

type selLEInt32Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEInt32Float32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt32Float32Op) Init() {
	p.input.Init()
}

type selGTInt32Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selGTInt32Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt32Float32ConstOp) Init() {
	p.input.Init()
}

type selGTInt32Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTInt32Float32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt32Float32Op) Init() {
	p.input.Init()
}

type selGEInt32Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selGEInt32Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt32Float32ConstOp) Init() {
	p.input.Init()
}

type selGEInt32Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEInt32Float32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt32Float32Op) Init() {
	p.input.Init()
}

type selEQInt32Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selEQInt32Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt32Float64ConstOp) Init() {
	p.input.Init()
}

type selEQInt32Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQInt32Float64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt32Float64Op) Init() {
	p.input.Init()
}

type selNEInt32Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selNEInt32Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt32Float64ConstOp) Init() {
	p.input.Init()
}

type selNEInt32Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEInt32Float64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt32Float64Op) Init() {
	p.input.Init()
}

type selLTInt32Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selLTInt32Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt32Float64ConstOp) Init() {
	p.input.Init()
}

type selLTInt32Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTInt32Float64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt32Float64Op) Init() {
	p.input.Init()
}

type selLEInt32Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selLEInt32Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt32Float64ConstOp) Init() {
	p.input.Init()
}

type selLEInt32Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEInt32Float64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt32Float64Op) Init() {
	p.input.Init()
}

type selGTInt32Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selGTInt32Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt32Float64ConstOp) Init() {
	p.input.Init()
}

type selGTInt32Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTInt32Float64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt32Float64Op) Init() {
	p.input.Init()
}

type selGEInt32Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selGEInt32Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt32Float64ConstOp) Init() {
	p.input.Init()
}

type selGEInt32Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEInt32Float64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int32()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt32Float64Op) Init() {
	p.input.Init()
}

type selEQInt64DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selEQInt64DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt64DecimalConstOp) Init() {
	p.input.Init()
}

type selEQInt64DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt64DecimalOp) Init() {
	p.input.Init()
}

type selNEInt64DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selNEInt64DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt64DecimalConstOp) Init() {
	p.input.Init()
}

type selNEInt64DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt64DecimalOp) Init() {
	p.input.Init()
}

type selLTInt64DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selLTInt64DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt64DecimalConstOp) Init() {
	p.input.Init()
}

type selLTInt64DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt64DecimalOp) Init() {
	p.input.Init()
}

type selLEInt64DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selLEInt64DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt64DecimalConstOp) Init() {
	p.input.Init()
}

type selLEInt64DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt64DecimalOp) Init() {
	p.input.Init()
}

type selGTInt64DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selGTInt64DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt64DecimalConstOp) Init() {
	p.input.Init()
}

type selGTInt64DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt64DecimalOp) Init() {
	p.input.Init()
}

type selGEInt64DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selGEInt64DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt64DecimalConstOp) Init() {
	p.input.Init()
}

type selGEInt64DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEInt64DecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							tmpDec.SetFinite(int64(arg1), 0)
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt64DecimalOp) Init() {
	p.input.Init()
}

type selEQInt64Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selEQInt64Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt64Int8ConstOp) Init() {
	p.input.Init()
}

type selEQInt64Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQInt64Int8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt64Int8Op) Init() {
	p.input.Init()
}

type selNEInt64Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selNEInt64Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt64Int8ConstOp) Init() {
	p.input.Init()
}

type selNEInt64Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEInt64Int8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt64Int8Op) Init() {
	p.input.Init()
}

type selLTInt64Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selLTInt64Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt64Int8ConstOp) Init() {
	p.input.Init()
}

type selLTInt64Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTInt64Int8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt64Int8Op) Init() {
	p.input.Init()
}

type selLEInt64Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selLEInt64Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt64Int8ConstOp) Init() {
	p.input.Init()
}

type selLEInt64Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEInt64Int8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt64Int8Op) Init() {
	p.input.Init()
}

type selGTInt64Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selGTInt64Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt64Int8ConstOp) Init() {
	p.input.Init()
}

type selGTInt64Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTInt64Int8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt64Int8Op) Init() {
	p.input.Init()
}

type selGEInt64Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selGEInt64Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt64Int8ConstOp) Init() {
	p.input.Init()
}

type selGEInt64Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEInt64Int8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt64Int8Op) Init() {
	p.input.Init()
}

type selEQInt64Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selEQInt64Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt64Int16ConstOp) Init() {
	p.input.Init()
}

type selEQInt64Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt64Int16Op) Init() {
	p.input.Init()
}

type selNEInt64Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selNEInt64Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt64Int16ConstOp) Init() {
	p.input.Init()
}

type selNEInt64Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt64Int16Op) Init() {
	p.input.Init()
}

type selLTInt64Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selLTInt64Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt64Int16ConstOp) Init() {
	p.input.Init()
}

type selLTInt64Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt64Int16Op) Init() {
	p.input.Init()
}

type selLEInt64Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selLEInt64Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt64Int16ConstOp) Init() {
	p.input.Init()
}

type selLEInt64Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt64Int16Op) Init() {
	p.input.Init()
}

type selGTInt64Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selGTInt64Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt64Int16ConstOp) Init() {
	p.input.Init()
}

type selGTInt64Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt64Int16Op) Init() {
	p.input.Init()
}

type selGEInt64Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selGEInt64Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt64Int16ConstOp) Init() {
	p.input.Init()
}

type selGEInt64Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEInt64Int16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt64Int16Op) Init() {
	p.input.Init()
}

type selEQInt64Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selEQInt64Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt64Int32ConstOp) Init() {
	p.input.Init()
}

type selEQInt64Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt64Int32Op) Init() {
	p.input.Init()
}

type selNEInt64Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selNEInt64Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt64Int32ConstOp) Init() {
	p.input.Init()
}

type selNEInt64Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt64Int32Op) Init() {
	p.input.Init()
}

type selLTInt64Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selLTInt64Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt64Int32ConstOp) Init() {
	p.input.Init()
}

type selLTInt64Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt64Int32Op) Init() {
	p.input.Init()
}

type selLEInt64Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selLEInt64Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt64Int32ConstOp) Init() {
	p.input.Init()
}

type selLEInt64Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt64Int32Op) Init() {
	p.input.Init()
}

type selGTInt64Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selGTInt64Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt64Int32ConstOp) Init() {
	p.input.Init()
}

type selGTInt64Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt64Int32Op) Init() {
	p.input.Init()
}

type selGEInt64Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selGEInt64Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt64Int32ConstOp) Init() {
	p.input.Init()
}

type selGEInt64Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEInt64Int32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt64Int32Op) Init() {
	p.input.Init()
}

type selEQInt64Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selEQInt64Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt64Int64ConstOp) Init() {
	p.input.Init()
}

type selEQInt64Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt64Int64Op) Init() {
	p.input.Init()
}

type selNEInt64Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selNEInt64Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt64Int64ConstOp) Init() {
	p.input.Init()
}

type selNEInt64Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt64Int64Op) Init() {
	p.input.Init()
}

type selLTInt64Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selLTInt64Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt64Int64ConstOp) Init() {
	p.input.Init()
}

type selLTInt64Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt64Int64Op) Init() {
	p.input.Init()
}

type selLEInt64Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selLEInt64Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt64Int64ConstOp) Init() {
	p.input.Init()
}

type selLEInt64Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt64Int64Op) Init() {
	p.input.Init()
}

type selGTInt64Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selGTInt64Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt64Int64ConstOp) Init() {
	p.input.Init()
}

type selGTInt64Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt64Int64Op) Init() {
	p.input.Init()
}

type selGEInt64Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selGEInt64Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := int64(arg), int64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt64Int64ConstOp) Init() {
	p.input.Init()
}

type selGEInt64Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEInt64Int64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := int64(arg1), int64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else {
								cmpResult = 0
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt64Int64Op) Init() {
	p.input.Init()
}

type selEQInt64Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selEQInt64Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt64Float32ConstOp) Init() {
	p.input.Init()
}

type selEQInt64Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQInt64Float32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt64Float32Op) Init() {
	p.input.Init()
}

type selNEInt64Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selNEInt64Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt64Float32ConstOp) Init() {
	p.input.Init()
}

type selNEInt64Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEInt64Float32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt64Float32Op) Init() {
	p.input.Init()
}

type selLTInt64Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selLTInt64Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt64Float32ConstOp) Init() {
	p.input.Init()
}

type selLTInt64Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTInt64Float32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt64Float32Op) Init() {
	p.input.Init()
}

type selLEInt64Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selLEInt64Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt64Float32ConstOp) Init() {
	p.input.Init()
}

type selLEInt64Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEInt64Float32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt64Float32Op) Init() {
	p.input.Init()
}

type selGTInt64Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selGTInt64Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt64Float32ConstOp) Init() {
	p.input.Init()
}

type selGTInt64Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTInt64Float32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt64Float32Op) Init() {
	p.input.Init()
}

type selGEInt64Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selGEInt64Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt64Float32ConstOp) Init() {
	p.input.Init()
}

type selGEInt64Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEInt64Float32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt64Float32Op) Init() {
	p.input.Init()
}

type selEQInt64Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selEQInt64Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt64Float64ConstOp) Init() {
	p.input.Init()
}

type selEQInt64Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQInt64Float64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQInt64Float64Op) Init() {
	p.input.Init()
}

type selNEInt64Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selNEInt64Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt64Float64ConstOp) Init() {
	p.input.Init()
}

type selNEInt64Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEInt64Float64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEInt64Float64Op) Init() {
	p.input.Init()
}

type selLTInt64Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selLTInt64Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt64Float64ConstOp) Init() {
	p.input.Init()
}

type selLTInt64Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTInt64Float64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTInt64Float64Op) Init() {
	p.input.Init()
}

type selLEInt64Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selLEInt64Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt64Float64ConstOp) Init() {
	p.input.Init()
}

type selLEInt64Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEInt64Float64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEInt64Float64Op) Init() {
	p.input.Init()
}

type selGTInt64Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selGTInt64Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt64Float64ConstOp) Init() {
	p.input.Init()
}

type selGTInt64Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTInt64Float64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTInt64Float64Op) Init() {
	p.input.Init()
}

type selGEInt64Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selGEInt64Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Int64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt64Float64ConstOp) Init() {
	p.input.Init()
}

type selGEInt64Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEInt64Float64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Int64()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if false {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEInt64Float64Op) Init() {
	p.input.Init()
}

type selEQFloat32DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selEQFloat32DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQFloat32DecimalConstOp) Init() {
	p.input.Init()
}

type selEQFloat32DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQFloat32DecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQFloat32DecimalOp) Init() {
	p.input.Init()
}

type selNEFloat32DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selNEFloat32DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEFloat32DecimalConstOp) Init() {
	p.input.Init()
}

type selNEFloat32DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEFloat32DecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEFloat32DecimalOp) Init() {
	p.input.Init()
}

type selLTFloat32DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selLTFloat32DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTFloat32DecimalConstOp) Init() {
	p.input.Init()
}

type selLTFloat32DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTFloat32DecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTFloat32DecimalOp) Init() {
	p.input.Init()
}

type selLEFloat32DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selLEFloat32DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEFloat32DecimalConstOp) Init() {
	p.input.Init()
}

type selLEFloat32DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEFloat32DecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEFloat32DecimalOp) Init() {
	p.input.Init()
}

type selGTFloat32DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selGTFloat32DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTFloat32DecimalConstOp) Init() {
	p.input.Init()
}

type selGTFloat32DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTFloat32DecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTFloat32DecimalOp) Init() {
	p.input.Init()
}

type selGEFloat32DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selGEFloat32DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEFloat32DecimalConstOp) Init() {
	p.input.Init()
}

type selGEFloat32DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEFloat32DecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEFloat32DecimalOp) Init() {
	p.input.Init()
}

type selEQFloat32Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selEQFloat32Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQFloat32Int8ConstOp) Init() {
	p.input.Init()
}

type selEQFloat32Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQFloat32Int8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQFloat32Int8Op) Init() {
	p.input.Init()
}

type selNEFloat32Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selNEFloat32Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEFloat32Int8ConstOp) Init() {
	p.input.Init()
}

type selNEFloat32Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEFloat32Int8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEFloat32Int8Op) Init() {
	p.input.Init()
}

type selLTFloat32Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selLTFloat32Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTFloat32Int8ConstOp) Init() {
	p.input.Init()
}

type selLTFloat32Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTFloat32Int8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTFloat32Int8Op) Init() {
	p.input.Init()
}

type selLEFloat32Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selLEFloat32Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEFloat32Int8ConstOp) Init() {
	p.input.Init()
}

type selLEFloat32Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEFloat32Int8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEFloat32Int8Op) Init() {
	p.input.Init()
}

type selGTFloat32Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selGTFloat32Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTFloat32Int8ConstOp) Init() {
	p.input.Init()
}

type selGTFloat32Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTFloat32Int8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTFloat32Int8Op) Init() {
	p.input.Init()
}

type selGEFloat32Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selGEFloat32Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEFloat32Int8ConstOp) Init() {
	p.input.Init()
}

type selGEFloat32Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEFloat32Int8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEFloat32Int8Op) Init() {
	p.input.Init()
}

type selEQFloat32Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selEQFloat32Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQFloat32Int16ConstOp) Init() {
	p.input.Init()
}

type selEQFloat32Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQFloat32Int16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQFloat32Int16Op) Init() {
	p.input.Init()
}

type selNEFloat32Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selNEFloat32Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEFloat32Int16ConstOp) Init() {
	p.input.Init()
}

type selNEFloat32Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEFloat32Int16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEFloat32Int16Op) Init() {
	p.input.Init()
}

type selLTFloat32Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selLTFloat32Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTFloat32Int16ConstOp) Init() {
	p.input.Init()
}

type selLTFloat32Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTFloat32Int16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTFloat32Int16Op) Init() {
	p.input.Init()
}

type selLEFloat32Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selLEFloat32Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEFloat32Int16ConstOp) Init() {
	p.input.Init()
}

type selLEFloat32Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEFloat32Int16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEFloat32Int16Op) Init() {
	p.input.Init()
}

type selGTFloat32Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selGTFloat32Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTFloat32Int16ConstOp) Init() {
	p.input.Init()
}

type selGTFloat32Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTFloat32Int16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTFloat32Int16Op) Init() {
	p.input.Init()
}

type selGEFloat32Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selGEFloat32Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEFloat32Int16ConstOp) Init() {
	p.input.Init()
}

type selGEFloat32Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEFloat32Int16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEFloat32Int16Op) Init() {
	p.input.Init()
}

type selEQFloat32Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selEQFloat32Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQFloat32Int32ConstOp) Init() {
	p.input.Init()
}

type selEQFloat32Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQFloat32Int32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQFloat32Int32Op) Init() {
	p.input.Init()
}

type selNEFloat32Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selNEFloat32Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEFloat32Int32ConstOp) Init() {
	p.input.Init()
}

type selNEFloat32Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEFloat32Int32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEFloat32Int32Op) Init() {
	p.input.Init()
}

type selLTFloat32Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selLTFloat32Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTFloat32Int32ConstOp) Init() {
	p.input.Init()
}

type selLTFloat32Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTFloat32Int32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTFloat32Int32Op) Init() {
	p.input.Init()
}

type selLEFloat32Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selLEFloat32Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEFloat32Int32ConstOp) Init() {
	p.input.Init()
}

type selLEFloat32Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEFloat32Int32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEFloat32Int32Op) Init() {
	p.input.Init()
}

type selGTFloat32Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selGTFloat32Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTFloat32Int32ConstOp) Init() {
	p.input.Init()
}

type selGTFloat32Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTFloat32Int32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTFloat32Int32Op) Init() {
	p.input.Init()
}

type selGEFloat32Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selGEFloat32Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEFloat32Int32ConstOp) Init() {
	p.input.Init()
}

type selGEFloat32Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEFloat32Int32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEFloat32Int32Op) Init() {
	p.input.Init()
}

type selEQFloat32Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selEQFloat32Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQFloat32Int64ConstOp) Init() {
	p.input.Init()
}

type selEQFloat32Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQFloat32Int64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQFloat32Int64Op) Init() {
	p.input.Init()
}

type selNEFloat32Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selNEFloat32Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEFloat32Int64ConstOp) Init() {
	p.input.Init()
}

type selNEFloat32Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEFloat32Int64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEFloat32Int64Op) Init() {
	p.input.Init()
}

type selLTFloat32Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selLTFloat32Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTFloat32Int64ConstOp) Init() {
	p.input.Init()
}

type selLTFloat32Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTFloat32Int64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTFloat32Int64Op) Init() {
	p.input.Init()
}

type selLEFloat32Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selLEFloat32Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEFloat32Int64ConstOp) Init() {
	p.input.Init()
}

type selLEFloat32Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEFloat32Int64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEFloat32Int64Op) Init() {
	p.input.Init()
}

type selGTFloat32Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selGTFloat32Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTFloat32Int64ConstOp) Init() {
	p.input.Init()
}

type selGTFloat32Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTFloat32Int64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTFloat32Int64Op) Init() {
	p.input.Init()
}

type selGEFloat32Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selGEFloat32Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEFloat32Int64ConstOp) Init() {
	p.input.Init()
}

type selGEFloat32Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEFloat32Int64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEFloat32Int64Op) Init() {
	p.input.Init()
}

type selEQFloat32Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selEQFloat32Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type selEQFloat32Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQFloat32Float32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQFloat32Float32Op) Init() {
	p.input.Init()
}

type selNEFloat32Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selNEFloat32Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type selNEFloat32Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEFloat32Float32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEFloat32Float32Op) Init() {
	p.input.Init()
}

type selLTFloat32Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selLTFloat32Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type selLTFloat32Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTFloat32Float32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTFloat32Float32Op) Init() {
	p.input.Init()
}

type selLEFloat32Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selLEFloat32Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type selLEFloat32Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEFloat32Float32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEFloat32Float32Op) Init() {
	p.input.Init()
}

type selGTFloat32Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selGTFloat32Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type selGTFloat32Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTFloat32Float32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTFloat32Float32Op) Init() {
	p.input.Init()
}

type selGEFloat32Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selGEFloat32Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEFloat32Float32ConstOp) Init() {
	p.input.Init()
}

type selGEFloat32Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEFloat32Float32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEFloat32Float32Op) Init() {
	p.input.Init()
}

type selEQFloat32Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selEQFloat32Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQFloat32Float64ConstOp) Init() {
	p.input.Init()
}

type selEQFloat32Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQFloat32Float64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQFloat32Float64Op) Init() {
	p.input.Init()
}

type selNEFloat32Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selNEFloat32Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEFloat32Float64ConstOp) Init() {
	p.input.Init()
}

type selNEFloat32Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEFloat32Float64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEFloat32Float64Op) Init() {
	p.input.Init()
}

type selLTFloat32Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selLTFloat32Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTFloat32Float64ConstOp) Init() {
	p.input.Init()
}

type selLTFloat32Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTFloat32Float64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTFloat32Float64Op) Init() {
	p.input.Init()
}

type selLEFloat32Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selLEFloat32Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEFloat32Float64ConstOp) Init() {
	p.input.Init()
}

type selLEFloat32Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEFloat32Float64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEFloat32Float64Op) Init() {
	p.input.Init()
}

type selGTFloat32Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selGTFloat32Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTFloat32Float64ConstOp) Init() {
	p.input.Init()
}

type selGTFloat32Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTFloat32Float64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTFloat32Float64Op) Init() {
	p.input.Init()
}

type selGEFloat32Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selGEFloat32Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float32()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEFloat32Float64ConstOp) Init() {
	p.input.Init()
}

type selGEFloat32Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEFloat32Float64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float32()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEFloat32Float64Op) Init() {
	p.input.Init()
}

type selEQFloat64DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selEQFloat64DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQFloat64DecimalConstOp) Init() {
	p.input.Init()
}

type selEQFloat64DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQFloat64DecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQFloat64DecimalOp) Init() {
	p.input.Init()
}

type selNEFloat64DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selNEFloat64DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEFloat64DecimalConstOp) Init() {
	p.input.Init()
}

type selNEFloat64DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEFloat64DecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEFloat64DecimalOp) Init() {
	p.input.Init()
}

type selLTFloat64DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selLTFloat64DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTFloat64DecimalConstOp) Init() {
	p.input.Init()
}

type selLTFloat64DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTFloat64DecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTFloat64DecimalOp) Init() {
	p.input.Init()
}

type selLEFloat64DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selLEFloat64DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEFloat64DecimalConstOp) Init() {
	p.input.Init()
}

type selLEFloat64DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEFloat64DecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEFloat64DecimalOp) Init() {
	p.input.Init()
}

type selGTFloat64DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selGTFloat64DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTFloat64DecimalConstOp) Init() {
	p.input.Init()
}

type selGTFloat64DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTFloat64DecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTFloat64DecimalOp) Init() {
	p.input.Init()
}

type selGEFloat64DecimalConstOp struct {
	OneInputNode

	colIdx   int
	constArg apd.Decimal
}

func (p *selGEFloat64DecimalConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &p.constArg)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEFloat64DecimalConstOp) Init() {
	p.input.Init()
}

type selGEFloat64DecimalOp struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEFloat64DecimalOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Decimal()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							tmpDec := &apd.Decimal{}
							if _, err := tmpDec.SetFloat64(float64(arg1)); err != nil {
								execerror.NonVectorizedPanic(err)
							}
							cmpResult = tree.CompareDecimals(tmpDec, &arg2)
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEFloat64DecimalOp) Init() {
	p.input.Init()
}

type selEQFloat64Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selEQFloat64Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQFloat64Int8ConstOp) Init() {
	p.input.Init()
}

type selEQFloat64Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQFloat64Int8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQFloat64Int8Op) Init() {
	p.input.Init()
}

type selNEFloat64Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selNEFloat64Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEFloat64Int8ConstOp) Init() {
	p.input.Init()
}

type selNEFloat64Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEFloat64Int8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEFloat64Int8Op) Init() {
	p.input.Init()
}

type selLTFloat64Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selLTFloat64Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTFloat64Int8ConstOp) Init() {
	p.input.Init()
}

type selLTFloat64Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTFloat64Int8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTFloat64Int8Op) Init() {
	p.input.Init()
}

type selLEFloat64Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selLEFloat64Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEFloat64Int8ConstOp) Init() {
	p.input.Init()
}

type selLEFloat64Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEFloat64Int8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEFloat64Int8Op) Init() {
	p.input.Init()
}

type selGTFloat64Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selGTFloat64Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTFloat64Int8ConstOp) Init() {
	p.input.Init()
}

type selGTFloat64Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTFloat64Int8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTFloat64Int8Op) Init() {
	p.input.Init()
}

type selGEFloat64Int8ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int8
}

func (p *selGEFloat64Int8ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEFloat64Int8ConstOp) Init() {
	p.input.Init()
}

type selGEFloat64Int8Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEFloat64Int8Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int8()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEFloat64Int8Op) Init() {
	p.input.Init()
}

type selEQFloat64Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selEQFloat64Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQFloat64Int16ConstOp) Init() {
	p.input.Init()
}

type selEQFloat64Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQFloat64Int16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQFloat64Int16Op) Init() {
	p.input.Init()
}

type selNEFloat64Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selNEFloat64Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEFloat64Int16ConstOp) Init() {
	p.input.Init()
}

type selNEFloat64Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEFloat64Int16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEFloat64Int16Op) Init() {
	p.input.Init()
}

type selLTFloat64Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selLTFloat64Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTFloat64Int16ConstOp) Init() {
	p.input.Init()
}

type selLTFloat64Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTFloat64Int16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTFloat64Int16Op) Init() {
	p.input.Init()
}

type selLEFloat64Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selLEFloat64Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEFloat64Int16ConstOp) Init() {
	p.input.Init()
}

type selLEFloat64Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEFloat64Int16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEFloat64Int16Op) Init() {
	p.input.Init()
}

type selGTFloat64Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selGTFloat64Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTFloat64Int16ConstOp) Init() {
	p.input.Init()
}

type selGTFloat64Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTFloat64Int16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTFloat64Int16Op) Init() {
	p.input.Init()
}

type selGEFloat64Int16ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int16
}

func (p *selGEFloat64Int16ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEFloat64Int16ConstOp) Init() {
	p.input.Init()
}

type selGEFloat64Int16Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEFloat64Int16Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int16()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEFloat64Int16Op) Init() {
	p.input.Init()
}

type selEQFloat64Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selEQFloat64Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQFloat64Int32ConstOp) Init() {
	p.input.Init()
}

type selEQFloat64Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQFloat64Int32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQFloat64Int32Op) Init() {
	p.input.Init()
}

type selNEFloat64Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selNEFloat64Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEFloat64Int32ConstOp) Init() {
	p.input.Init()
}

type selNEFloat64Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEFloat64Int32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEFloat64Int32Op) Init() {
	p.input.Init()
}

type selLTFloat64Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selLTFloat64Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTFloat64Int32ConstOp) Init() {
	p.input.Init()
}

type selLTFloat64Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTFloat64Int32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTFloat64Int32Op) Init() {
	p.input.Init()
}

type selLEFloat64Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selLEFloat64Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEFloat64Int32ConstOp) Init() {
	p.input.Init()
}

type selLEFloat64Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEFloat64Int32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEFloat64Int32Op) Init() {
	p.input.Init()
}

type selGTFloat64Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selGTFloat64Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTFloat64Int32ConstOp) Init() {
	p.input.Init()
}

type selGTFloat64Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTFloat64Int32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTFloat64Int32Op) Init() {
	p.input.Init()
}

type selGEFloat64Int32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int32
}

func (p *selGEFloat64Int32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEFloat64Int32ConstOp) Init() {
	p.input.Init()
}

type selGEFloat64Int32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEFloat64Int32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEFloat64Int32Op) Init() {
	p.input.Init()
}

type selEQFloat64Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selEQFloat64Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQFloat64Int64ConstOp) Init() {
	p.input.Init()
}

type selEQFloat64Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQFloat64Int64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQFloat64Int64Op) Init() {
	p.input.Init()
}

type selNEFloat64Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selNEFloat64Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEFloat64Int64ConstOp) Init() {
	p.input.Init()
}

type selNEFloat64Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEFloat64Int64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEFloat64Int64Op) Init() {
	p.input.Init()
}

type selLTFloat64Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selLTFloat64Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTFloat64Int64ConstOp) Init() {
	p.input.Init()
}

type selLTFloat64Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTFloat64Int64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTFloat64Int64Op) Init() {
	p.input.Init()
}

type selLEFloat64Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selLEFloat64Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEFloat64Int64ConstOp) Init() {
	p.input.Init()
}

type selLEFloat64Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEFloat64Int64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEFloat64Int64Op) Init() {
	p.input.Init()
}

type selGTFloat64Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selGTFloat64Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTFloat64Int64ConstOp) Init() {
	p.input.Init()
}

type selGTFloat64Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTFloat64Int64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTFloat64Int64Op) Init() {
	p.input.Init()
}

type selGEFloat64Int64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg int64
}

func (p *selGEFloat64Int64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEFloat64Int64ConstOp) Init() {
	p.input.Init()
}

type selGEFloat64Int64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEFloat64Int64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Int64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if false {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEFloat64Int64Op) Init() {
	p.input.Init()
}

type selEQFloat64Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selEQFloat64Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQFloat64Float32ConstOp) Init() {
	p.input.Init()
}

type selEQFloat64Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQFloat64Float32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQFloat64Float32Op) Init() {
	p.input.Init()
}

type selNEFloat64Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selNEFloat64Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEFloat64Float32ConstOp) Init() {
	p.input.Init()
}

type selNEFloat64Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEFloat64Float32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEFloat64Float32Op) Init() {
	p.input.Init()
}

type selLTFloat64Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selLTFloat64Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTFloat64Float32ConstOp) Init() {
	p.input.Init()
}

type selLTFloat64Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTFloat64Float32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTFloat64Float32Op) Init() {
	p.input.Init()
}

type selLEFloat64Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selLEFloat64Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEFloat64Float32ConstOp) Init() {
	p.input.Init()
}

type selLEFloat64Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEFloat64Float32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEFloat64Float32Op) Init() {
	p.input.Init()
}

type selGTFloat64Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selGTFloat64Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTFloat64Float32ConstOp) Init() {
	p.input.Init()
}

type selGTFloat64Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTFloat64Float32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTFloat64Float32Op) Init() {
	p.input.Init()
}

type selGEFloat64Float32ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float32
}

func (p *selGEFloat64Float32ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEFloat64Float32ConstOp) Init() {
	p.input.Init()
}

type selGEFloat64Float32Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEFloat64Float32Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Float32()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEFloat64Float32Op) Init() {
	p.input.Init()
}

type selEQFloat64Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selEQFloat64Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type selEQFloat64Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selEQFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult == 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selEQFloat64Float64Op) Init() {
	p.input.Init()
}

type selNEFloat64Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selNEFloat64Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type selNEFloat64Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selNEFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult != 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNEFloat64Float64Op) Init() {
	p.input.Init()
}

type selLTFloat64Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selLTFloat64Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type selLTFloat64Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLTFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult < 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLTFloat64Float64Op) Init() {
	p.input.Init()
}

type selLEFloat64Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selLEFloat64Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type selLEFloat64Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selLEFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult <= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selLEFloat64Float64Op) Init() {
	p.input.Init()
}

type selGTFloat64Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selGTFloat64Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type selGTFloat64Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGTFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult > 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGTFloat64Float64Op) Init() {
	p.input.Init()
}

type selGEFloat64Float64ConstOp struct {
	OneInputNode

	colIdx   int
	constArg float64
}

func (p *selGEFloat64Float64ConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Float64()
		var idx uint16
		n := batch.Length()
		if vec.MaybeHasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg := col[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[0:int(n)]
				for i := range col {
					var cmp bool
					arg := col[i]

					{
						var cmpResult int

						{
							a, b := float64(arg), float64(p.constArg)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEFloat64Float64ConstOp) Init() {
	p.input.Init()
}

type selGEFloat64Float64Op struct {
	OneInputNode

	col1Idx int
	col2Idx int
}

func (p *selGEFloat64Float64Op) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec1 := batch.ColVec(p.col1Idx)
		vec2 := batch.ColVec(p.col2Idx)
		col1 := vec1.Float64()
		col2 := vec2.Float64()
		n := batch.Length()

		var idx uint16
		if vec1.MaybeHasNulls() || vec2.MaybeHasNulls() {
			nulls := vec1.Nulls().Or(vec2.Nulls())

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					arg1 := col1[int(i)]
					arg2 := col2[int(i)]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col1 = col1[0:int(n)]
				col1Len := len(col1)
				col2 = col2[0:col1Len]
				for i := range col1 {
					var cmp bool
					arg1 := col1[i]
					arg2 := col2[i]

					{
						var cmpResult int

						{
							a, b := float64(arg1), float64(arg2)
							if a < b {
								cmpResult = -1
							} else if a > b {
								cmpResult = 1
							} else if a == b {
								cmpResult = 0
							} else if math.IsNaN(a) {
								if math.IsNaN(b) {
									cmpResult = 0
								} else {
									cmpResult = -1
								}
							} else {
								cmpResult = 1
							}
						}

						cmp = cmpResult >= 0
					}

					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selGEFloat64Float64Op) Init() {
	p.input.Init()
}

// GetSelectionConstOperator returns the appropriate constant selection operator
// for the given left and right column types and comparison.
func GetSelectionConstOperator(
	leftColType *types.T,
	constColType *types.T,
	cmpOp tree.ComparisonOperator,
	input Operator,
	colIdx int,
	constArg tree.Datum,
) (Operator, error) {
	c, err := typeconv.GetDatumToPhysicalFn(constColType)(constArg)
	if err != nil {
		return nil, err
	}
	switch leftType := typeconv.FromColumnType(leftColType); leftType {

	case coltypes.Bool:
		switch rightType := typeconv.FromColumnType(constColType); rightType {

		case coltypes.Bool:
			switch cmpOp {

			case tree.EQ:
				return &selEQBoolBoolConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(bool),
				}, nil

			case tree.NE:
				return &selNEBoolBoolConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(bool),
				}, nil

			case tree.LT:
				return &selLTBoolBoolConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(bool),
				}, nil

			case tree.LE:
				return &selLEBoolBoolConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(bool),
				}, nil

			case tree.GT:
				return &selGTBoolBoolConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(bool),
				}, nil

			case tree.GE:
				return &selGEBoolBoolConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(bool),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	case coltypes.Bytes:
		switch rightType := typeconv.FromColumnType(constColType); rightType {

		case coltypes.Bytes:
			switch cmpOp {

			case tree.EQ:
				return &selEQBytesBytesConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.([]byte),
				}, nil

			case tree.NE:
				return &selNEBytesBytesConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.([]byte),
				}, nil

			case tree.LT:
				return &selLTBytesBytesConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.([]byte),
				}, nil

			case tree.LE:
				return &selLEBytesBytesConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.([]byte),
				}, nil

			case tree.GT:
				return &selGTBytesBytesConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.([]byte),
				}, nil

			case tree.GE:
				return &selGEBytesBytesConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.([]byte),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	case coltypes.Decimal:
		switch rightType := typeconv.FromColumnType(constColType); rightType {

		case coltypes.Decimal:
			switch cmpOp {

			case tree.EQ:
				return &selEQDecimalDecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			case tree.NE:
				return &selNEDecimalDecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			case tree.LT:
				return &selLTDecimalDecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			case tree.LE:
				return &selLEDecimalDecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			case tree.GT:
				return &selGTDecimalDecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			case tree.GE:
				return &selGEDecimalDecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int8:
			switch cmpOp {

			case tree.EQ:
				return &selEQDecimalInt8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			case tree.NE:
				return &selNEDecimalInt8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			case tree.LT:
				return &selLTDecimalInt8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			case tree.LE:
				return &selLEDecimalInt8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			case tree.GT:
				return &selGTDecimalInt8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			case tree.GE:
				return &selGEDecimalInt8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int16:
			switch cmpOp {

			case tree.EQ:
				return &selEQDecimalInt16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			case tree.NE:
				return &selNEDecimalInt16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			case tree.LT:
				return &selLTDecimalInt16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			case tree.LE:
				return &selLEDecimalInt16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			case tree.GT:
				return &selGTDecimalInt16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			case tree.GE:
				return &selGEDecimalInt16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int32:
			switch cmpOp {

			case tree.EQ:
				return &selEQDecimalInt32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			case tree.NE:
				return &selNEDecimalInt32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			case tree.LT:
				return &selLTDecimalInt32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			case tree.LE:
				return &selLEDecimalInt32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			case tree.GT:
				return &selGTDecimalInt32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			case tree.GE:
				return &selGEDecimalInt32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int64:
			switch cmpOp {

			case tree.EQ:
				return &selEQDecimalInt64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			case tree.NE:
				return &selNEDecimalInt64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			case tree.LT:
				return &selLTDecimalInt64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			case tree.LE:
				return &selLEDecimalInt64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			case tree.GT:
				return &selGTDecimalInt64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			case tree.GE:
				return &selGEDecimalInt64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Float32:
			switch cmpOp {

			case tree.EQ:
				return &selEQDecimalFloat32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			case tree.NE:
				return &selNEDecimalFloat32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			case tree.LT:
				return &selLTDecimalFloat32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			case tree.LE:
				return &selLEDecimalFloat32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			case tree.GT:
				return &selGTDecimalFloat32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			case tree.GE:
				return &selGEDecimalFloat32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Float64:
			switch cmpOp {

			case tree.EQ:
				return &selEQDecimalFloat64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			case tree.NE:
				return &selNEDecimalFloat64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			case tree.LT:
				return &selLTDecimalFloat64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			case tree.LE:
				return &selLEDecimalFloat64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			case tree.GT:
				return &selGTDecimalFloat64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			case tree.GE:
				return &selGEDecimalFloat64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	case coltypes.Int8:
		switch rightType := typeconv.FromColumnType(constColType); rightType {

		case coltypes.Decimal:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt8DecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			case tree.NE:
				return &selNEInt8DecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			case tree.LT:
				return &selLTInt8DecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			case tree.LE:
				return &selLEInt8DecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			case tree.GT:
				return &selGTInt8DecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			case tree.GE:
				return &selGEInt8DecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int8:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt8Int8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			case tree.NE:
				return &selNEInt8Int8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			case tree.LT:
				return &selLTInt8Int8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			case tree.LE:
				return &selLEInt8Int8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			case tree.GT:
				return &selGTInt8Int8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			case tree.GE:
				return &selGEInt8Int8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int16:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt8Int16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			case tree.NE:
				return &selNEInt8Int16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			case tree.LT:
				return &selLTInt8Int16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			case tree.LE:
				return &selLEInt8Int16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			case tree.GT:
				return &selGTInt8Int16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			case tree.GE:
				return &selGEInt8Int16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int32:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt8Int32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			case tree.NE:
				return &selNEInt8Int32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			case tree.LT:
				return &selLTInt8Int32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			case tree.LE:
				return &selLEInt8Int32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			case tree.GT:
				return &selGTInt8Int32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			case tree.GE:
				return &selGEInt8Int32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int64:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt8Int64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			case tree.NE:
				return &selNEInt8Int64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			case tree.LT:
				return &selLTInt8Int64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			case tree.LE:
				return &selLEInt8Int64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			case tree.GT:
				return &selGTInt8Int64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			case tree.GE:
				return &selGEInt8Int64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Float32:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt8Float32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			case tree.NE:
				return &selNEInt8Float32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			case tree.LT:
				return &selLTInt8Float32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			case tree.LE:
				return &selLEInt8Float32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			case tree.GT:
				return &selGTInt8Float32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			case tree.GE:
				return &selGEInt8Float32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Float64:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt8Float64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			case tree.NE:
				return &selNEInt8Float64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			case tree.LT:
				return &selLTInt8Float64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			case tree.LE:
				return &selLEInt8Float64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			case tree.GT:
				return &selGTInt8Float64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			case tree.GE:
				return &selGEInt8Float64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	case coltypes.Int16:
		switch rightType := typeconv.FromColumnType(constColType); rightType {

		case coltypes.Decimal:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt16DecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			case tree.NE:
				return &selNEInt16DecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			case tree.LT:
				return &selLTInt16DecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			case tree.LE:
				return &selLEInt16DecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			case tree.GT:
				return &selGTInt16DecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			case tree.GE:
				return &selGEInt16DecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int8:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt16Int8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			case tree.NE:
				return &selNEInt16Int8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			case tree.LT:
				return &selLTInt16Int8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			case tree.LE:
				return &selLEInt16Int8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			case tree.GT:
				return &selGTInt16Int8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			case tree.GE:
				return &selGEInt16Int8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int16:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt16Int16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			case tree.NE:
				return &selNEInt16Int16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			case tree.LT:
				return &selLTInt16Int16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			case tree.LE:
				return &selLEInt16Int16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			case tree.GT:
				return &selGTInt16Int16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			case tree.GE:
				return &selGEInt16Int16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int32:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt16Int32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			case tree.NE:
				return &selNEInt16Int32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			case tree.LT:
				return &selLTInt16Int32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			case tree.LE:
				return &selLEInt16Int32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			case tree.GT:
				return &selGTInt16Int32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			case tree.GE:
				return &selGEInt16Int32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int64:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt16Int64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			case tree.NE:
				return &selNEInt16Int64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			case tree.LT:
				return &selLTInt16Int64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			case tree.LE:
				return &selLEInt16Int64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			case tree.GT:
				return &selGTInt16Int64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			case tree.GE:
				return &selGEInt16Int64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Float32:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt16Float32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			case tree.NE:
				return &selNEInt16Float32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			case tree.LT:
				return &selLTInt16Float32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			case tree.LE:
				return &selLEInt16Float32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			case tree.GT:
				return &selGTInt16Float32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			case tree.GE:
				return &selGEInt16Float32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Float64:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt16Float64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			case tree.NE:
				return &selNEInt16Float64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			case tree.LT:
				return &selLTInt16Float64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			case tree.LE:
				return &selLEInt16Float64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			case tree.GT:
				return &selGTInt16Float64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			case tree.GE:
				return &selGEInt16Float64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	case coltypes.Int32:
		switch rightType := typeconv.FromColumnType(constColType); rightType {

		case coltypes.Decimal:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt32DecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			case tree.NE:
				return &selNEInt32DecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			case tree.LT:
				return &selLTInt32DecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			case tree.LE:
				return &selLEInt32DecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			case tree.GT:
				return &selGTInt32DecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			case tree.GE:
				return &selGEInt32DecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int8:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt32Int8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			case tree.NE:
				return &selNEInt32Int8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			case tree.LT:
				return &selLTInt32Int8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			case tree.LE:
				return &selLEInt32Int8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			case tree.GT:
				return &selGTInt32Int8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			case tree.GE:
				return &selGEInt32Int8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int16:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt32Int16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			case tree.NE:
				return &selNEInt32Int16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			case tree.LT:
				return &selLTInt32Int16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			case tree.LE:
				return &selLEInt32Int16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			case tree.GT:
				return &selGTInt32Int16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			case tree.GE:
				return &selGEInt32Int16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int32:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt32Int32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			case tree.NE:
				return &selNEInt32Int32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			case tree.LT:
				return &selLTInt32Int32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			case tree.LE:
				return &selLEInt32Int32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			case tree.GT:
				return &selGTInt32Int32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			case tree.GE:
				return &selGEInt32Int32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int64:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt32Int64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			case tree.NE:
				return &selNEInt32Int64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			case tree.LT:
				return &selLTInt32Int64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			case tree.LE:
				return &selLEInt32Int64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			case tree.GT:
				return &selGTInt32Int64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			case tree.GE:
				return &selGEInt32Int64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Float32:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt32Float32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			case tree.NE:
				return &selNEInt32Float32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			case tree.LT:
				return &selLTInt32Float32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			case tree.LE:
				return &selLEInt32Float32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			case tree.GT:
				return &selGTInt32Float32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			case tree.GE:
				return &selGEInt32Float32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Float64:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt32Float64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			case tree.NE:
				return &selNEInt32Float64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			case tree.LT:
				return &selLTInt32Float64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			case tree.LE:
				return &selLEInt32Float64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			case tree.GT:
				return &selGTInt32Float64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			case tree.GE:
				return &selGEInt32Float64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	case coltypes.Int64:
		switch rightType := typeconv.FromColumnType(constColType); rightType {

		case coltypes.Decimal:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt64DecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			case tree.NE:
				return &selNEInt64DecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			case tree.LT:
				return &selLTInt64DecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			case tree.LE:
				return &selLEInt64DecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			case tree.GT:
				return &selGTInt64DecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			case tree.GE:
				return &selGEInt64DecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int8:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt64Int8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			case tree.NE:
				return &selNEInt64Int8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			case tree.LT:
				return &selLTInt64Int8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			case tree.LE:
				return &selLEInt64Int8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			case tree.GT:
				return &selGTInt64Int8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			case tree.GE:
				return &selGEInt64Int8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int16:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt64Int16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			case tree.NE:
				return &selNEInt64Int16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			case tree.LT:
				return &selLTInt64Int16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			case tree.LE:
				return &selLEInt64Int16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			case tree.GT:
				return &selGTInt64Int16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			case tree.GE:
				return &selGEInt64Int16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int32:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt64Int32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			case tree.NE:
				return &selNEInt64Int32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			case tree.LT:
				return &selLTInt64Int32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			case tree.LE:
				return &selLEInt64Int32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			case tree.GT:
				return &selGTInt64Int32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			case tree.GE:
				return &selGEInt64Int32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int64:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt64Int64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			case tree.NE:
				return &selNEInt64Int64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			case tree.LT:
				return &selLTInt64Int64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			case tree.LE:
				return &selLEInt64Int64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			case tree.GT:
				return &selGTInt64Int64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			case tree.GE:
				return &selGEInt64Int64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Float32:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt64Float32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			case tree.NE:
				return &selNEInt64Float32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			case tree.LT:
				return &selLTInt64Float32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			case tree.LE:
				return &selLEInt64Float32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			case tree.GT:
				return &selGTInt64Float32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			case tree.GE:
				return &selGEInt64Float32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Float64:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt64Float64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			case tree.NE:
				return &selNEInt64Float64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			case tree.LT:
				return &selLTInt64Float64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			case tree.LE:
				return &selLEInt64Float64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			case tree.GT:
				return &selGTInt64Float64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			case tree.GE:
				return &selGEInt64Float64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	case coltypes.Float32:
		switch rightType := typeconv.FromColumnType(constColType); rightType {

		case coltypes.Decimal:
			switch cmpOp {

			case tree.EQ:
				return &selEQFloat32DecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			case tree.NE:
				return &selNEFloat32DecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			case tree.LT:
				return &selLTFloat32DecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			case tree.LE:
				return &selLEFloat32DecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			case tree.GT:
				return &selGTFloat32DecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			case tree.GE:
				return &selGEFloat32DecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int8:
			switch cmpOp {

			case tree.EQ:
				return &selEQFloat32Int8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			case tree.NE:
				return &selNEFloat32Int8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			case tree.LT:
				return &selLTFloat32Int8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			case tree.LE:
				return &selLEFloat32Int8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			case tree.GT:
				return &selGTFloat32Int8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			case tree.GE:
				return &selGEFloat32Int8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int16:
			switch cmpOp {

			case tree.EQ:
				return &selEQFloat32Int16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			case tree.NE:
				return &selNEFloat32Int16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			case tree.LT:
				return &selLTFloat32Int16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			case tree.LE:
				return &selLEFloat32Int16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			case tree.GT:
				return &selGTFloat32Int16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			case tree.GE:
				return &selGEFloat32Int16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int32:
			switch cmpOp {

			case tree.EQ:
				return &selEQFloat32Int32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			case tree.NE:
				return &selNEFloat32Int32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			case tree.LT:
				return &selLTFloat32Int32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			case tree.LE:
				return &selLEFloat32Int32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			case tree.GT:
				return &selGTFloat32Int32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			case tree.GE:
				return &selGEFloat32Int32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int64:
			switch cmpOp {

			case tree.EQ:
				return &selEQFloat32Int64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			case tree.NE:
				return &selNEFloat32Int64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			case tree.LT:
				return &selLTFloat32Int64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			case tree.LE:
				return &selLEFloat32Int64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			case tree.GT:
				return &selGTFloat32Int64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			case tree.GE:
				return &selGEFloat32Int64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Float32:
			switch cmpOp {

			case tree.EQ:
				return &selEQFloat32Float32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			case tree.NE:
				return &selNEFloat32Float32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			case tree.LT:
				return &selLTFloat32Float32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			case tree.LE:
				return &selLEFloat32Float32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			case tree.GT:
				return &selGTFloat32Float32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			case tree.GE:
				return &selGEFloat32Float32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Float64:
			switch cmpOp {

			case tree.EQ:
				return &selEQFloat32Float64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			case tree.NE:
				return &selNEFloat32Float64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			case tree.LT:
				return &selLTFloat32Float64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			case tree.LE:
				return &selLEFloat32Float64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			case tree.GT:
				return &selGTFloat32Float64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			case tree.GE:
				return &selGEFloat32Float64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	case coltypes.Float64:
		switch rightType := typeconv.FromColumnType(constColType); rightType {

		case coltypes.Decimal:
			switch cmpOp {

			case tree.EQ:
				return &selEQFloat64DecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			case tree.NE:
				return &selNEFloat64DecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			case tree.LT:
				return &selLTFloat64DecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			case tree.LE:
				return &selLEFloat64DecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			case tree.GT:
				return &selGTFloat64DecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			case tree.GE:
				return &selGEFloat64DecimalConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(apd.Decimal),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int8:
			switch cmpOp {

			case tree.EQ:
				return &selEQFloat64Int8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			case tree.NE:
				return &selNEFloat64Int8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			case tree.LT:
				return &selLTFloat64Int8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			case tree.LE:
				return &selLEFloat64Int8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			case tree.GT:
				return &selGTFloat64Int8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			case tree.GE:
				return &selGEFloat64Int8ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int8),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int16:
			switch cmpOp {

			case tree.EQ:
				return &selEQFloat64Int16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			case tree.NE:
				return &selNEFloat64Int16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			case tree.LT:
				return &selLTFloat64Int16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			case tree.LE:
				return &selLEFloat64Int16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			case tree.GT:
				return &selGTFloat64Int16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			case tree.GE:
				return &selGEFloat64Int16ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int16),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int32:
			switch cmpOp {

			case tree.EQ:
				return &selEQFloat64Int32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			case tree.NE:
				return &selNEFloat64Int32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			case tree.LT:
				return &selLTFloat64Int32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			case tree.LE:
				return &selLEFloat64Int32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			case tree.GT:
				return &selGTFloat64Int32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			case tree.GE:
				return &selGEFloat64Int32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int32),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int64:
			switch cmpOp {

			case tree.EQ:
				return &selEQFloat64Int64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			case tree.NE:
				return &selNEFloat64Int64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			case tree.LT:
				return &selLTFloat64Int64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			case tree.LE:
				return &selLEFloat64Int64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			case tree.GT:
				return &selGTFloat64Int64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			case tree.GE:
				return &selGEFloat64Int64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(int64),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Float32:
			switch cmpOp {

			case tree.EQ:
				return &selEQFloat64Float32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			case tree.NE:
				return &selNEFloat64Float32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			case tree.LT:
				return &selLTFloat64Float32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			case tree.LE:
				return &selLEFloat64Float32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			case tree.GT:
				return &selGTFloat64Float32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			case tree.GE:
				return &selGEFloat64Float32ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float32),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Float64:
			switch cmpOp {

			case tree.EQ:
				return &selEQFloat64Float64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			case tree.NE:
				return &selNEFloat64Float64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			case tree.LT:
				return &selLTFloat64Float64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			case tree.LE:
				return &selLEFloat64Float64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			case tree.GT:
				return &selGTFloat64Float64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			case tree.GE:
				return &selGEFloat64Float64ConstOp{
					OneInputNode: NewOneInputNode(input),
					colIdx:       colIdx,
					constArg:     c.(float64),
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	default:
		return nil, errors.Errorf("unhandled left type: %s", leftType)
	}
}

// GetSelectionOperator returns the appropriate two column selection operator
// for the given left and right column types and comparison.
func GetSelectionOperator(
	leftColType *types.T,
	rightColType *types.T,
	cmpOp tree.ComparisonOperator,
	input Operator,
	col1Idx int,
	col2Idx int,
) (Operator, error) {
	switch leftType := typeconv.FromColumnType(leftColType); leftType {

	case coltypes.Bool:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {

		case coltypes.Bool:
			switch cmpOp {

			case tree.EQ:
				return &selEQBoolBoolOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEBoolBoolOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTBoolBoolOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEBoolBoolOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTBoolBoolOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEBoolBoolOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	case coltypes.Bytes:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {

		case coltypes.Bytes:
			switch cmpOp {

			case tree.EQ:
				return &selEQBytesBytesOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEBytesBytesOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTBytesBytesOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEBytesBytesOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTBytesBytesOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEBytesBytesOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	case coltypes.Decimal:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {

		case coltypes.Decimal:
			switch cmpOp {

			case tree.EQ:
				return &selEQDecimalDecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEDecimalDecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTDecimalDecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEDecimalDecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTDecimalDecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEDecimalDecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int8:
			switch cmpOp {

			case tree.EQ:
				return &selEQDecimalInt8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEDecimalInt8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTDecimalInt8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEDecimalInt8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTDecimalInt8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEDecimalInt8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int16:
			switch cmpOp {

			case tree.EQ:
				return &selEQDecimalInt16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEDecimalInt16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTDecimalInt16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEDecimalInt16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTDecimalInt16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEDecimalInt16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int32:
			switch cmpOp {

			case tree.EQ:
				return &selEQDecimalInt32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEDecimalInt32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTDecimalInt32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEDecimalInt32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTDecimalInt32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEDecimalInt32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int64:
			switch cmpOp {

			case tree.EQ:
				return &selEQDecimalInt64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEDecimalInt64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTDecimalInt64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEDecimalInt64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTDecimalInt64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEDecimalInt64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Float32:
			switch cmpOp {

			case tree.EQ:
				return &selEQDecimalFloat32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEDecimalFloat32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTDecimalFloat32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEDecimalFloat32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTDecimalFloat32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEDecimalFloat32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Float64:
			switch cmpOp {

			case tree.EQ:
				return &selEQDecimalFloat64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEDecimalFloat64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTDecimalFloat64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEDecimalFloat64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTDecimalFloat64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEDecimalFloat64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	case coltypes.Int8:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {

		case coltypes.Decimal:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt8DecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEInt8DecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTInt8DecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEInt8DecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTInt8DecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEInt8DecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int8:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt8Int8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEInt8Int8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTInt8Int8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEInt8Int8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTInt8Int8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEInt8Int8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int16:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt8Int16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEInt8Int16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTInt8Int16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEInt8Int16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTInt8Int16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEInt8Int16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int32:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt8Int32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEInt8Int32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTInt8Int32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEInt8Int32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTInt8Int32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEInt8Int32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int64:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt8Int64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEInt8Int64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTInt8Int64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEInt8Int64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTInt8Int64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEInt8Int64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Float32:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt8Float32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEInt8Float32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTInt8Float32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEInt8Float32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTInt8Float32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEInt8Float32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Float64:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt8Float64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEInt8Float64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTInt8Float64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEInt8Float64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTInt8Float64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEInt8Float64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	case coltypes.Int16:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {

		case coltypes.Decimal:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt16DecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEInt16DecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTInt16DecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEInt16DecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTInt16DecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEInt16DecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int8:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt16Int8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEInt16Int8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTInt16Int8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEInt16Int8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTInt16Int8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEInt16Int8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int16:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt16Int16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEInt16Int16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTInt16Int16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEInt16Int16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTInt16Int16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEInt16Int16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int32:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt16Int32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEInt16Int32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTInt16Int32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEInt16Int32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTInt16Int32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEInt16Int32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int64:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt16Int64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEInt16Int64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTInt16Int64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEInt16Int64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTInt16Int64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEInt16Int64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Float32:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt16Float32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEInt16Float32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTInt16Float32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEInt16Float32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTInt16Float32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEInt16Float32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Float64:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt16Float64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEInt16Float64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTInt16Float64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEInt16Float64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTInt16Float64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEInt16Float64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	case coltypes.Int32:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {

		case coltypes.Decimal:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt32DecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEInt32DecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTInt32DecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEInt32DecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTInt32DecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEInt32DecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int8:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt32Int8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEInt32Int8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTInt32Int8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEInt32Int8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTInt32Int8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEInt32Int8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int16:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt32Int16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEInt32Int16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTInt32Int16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEInt32Int16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTInt32Int16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEInt32Int16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int32:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt32Int32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEInt32Int32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTInt32Int32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEInt32Int32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTInt32Int32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEInt32Int32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int64:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt32Int64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEInt32Int64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTInt32Int64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEInt32Int64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTInt32Int64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEInt32Int64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Float32:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt32Float32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEInt32Float32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTInt32Float32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEInt32Float32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTInt32Float32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEInt32Float32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Float64:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt32Float64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEInt32Float64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTInt32Float64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEInt32Float64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTInt32Float64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEInt32Float64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	case coltypes.Int64:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {

		case coltypes.Decimal:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt64DecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEInt64DecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTInt64DecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEInt64DecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTInt64DecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEInt64DecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int8:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt64Int8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEInt64Int8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTInt64Int8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEInt64Int8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTInt64Int8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEInt64Int8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int16:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt64Int16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEInt64Int16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTInt64Int16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEInt64Int16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTInt64Int16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEInt64Int16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int32:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt64Int32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEInt64Int32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTInt64Int32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEInt64Int32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTInt64Int32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEInt64Int32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int64:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt64Int64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEInt64Int64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTInt64Int64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEInt64Int64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTInt64Int64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEInt64Int64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Float32:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt64Float32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEInt64Float32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTInt64Float32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEInt64Float32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTInt64Float32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEInt64Float32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Float64:
			switch cmpOp {

			case tree.EQ:
				return &selEQInt64Float64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEInt64Float64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTInt64Float64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEInt64Float64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTInt64Float64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEInt64Float64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	case coltypes.Float32:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {

		case coltypes.Decimal:
			switch cmpOp {

			case tree.EQ:
				return &selEQFloat32DecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEFloat32DecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTFloat32DecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEFloat32DecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTFloat32DecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEFloat32DecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int8:
			switch cmpOp {

			case tree.EQ:
				return &selEQFloat32Int8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEFloat32Int8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTFloat32Int8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEFloat32Int8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTFloat32Int8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEFloat32Int8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int16:
			switch cmpOp {

			case tree.EQ:
				return &selEQFloat32Int16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEFloat32Int16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTFloat32Int16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEFloat32Int16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTFloat32Int16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEFloat32Int16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int32:
			switch cmpOp {

			case tree.EQ:
				return &selEQFloat32Int32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEFloat32Int32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTFloat32Int32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEFloat32Int32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTFloat32Int32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEFloat32Int32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int64:
			switch cmpOp {

			case tree.EQ:
				return &selEQFloat32Int64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEFloat32Int64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTFloat32Int64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEFloat32Int64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTFloat32Int64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEFloat32Int64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Float32:
			switch cmpOp {

			case tree.EQ:
				return &selEQFloat32Float32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEFloat32Float32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTFloat32Float32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEFloat32Float32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTFloat32Float32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEFloat32Float32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Float64:
			switch cmpOp {

			case tree.EQ:
				return &selEQFloat32Float64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEFloat32Float64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTFloat32Float64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEFloat32Float64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTFloat32Float64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEFloat32Float64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	case coltypes.Float64:
		switch rightType := typeconv.FromColumnType(rightColType); rightType {

		case coltypes.Decimal:
			switch cmpOp {

			case tree.EQ:
				return &selEQFloat64DecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEFloat64DecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTFloat64DecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEFloat64DecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTFloat64DecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEFloat64DecimalOp{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int8:
			switch cmpOp {

			case tree.EQ:
				return &selEQFloat64Int8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEFloat64Int8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTFloat64Int8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEFloat64Int8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTFloat64Int8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEFloat64Int8Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int16:
			switch cmpOp {

			case tree.EQ:
				return &selEQFloat64Int16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEFloat64Int16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTFloat64Int16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEFloat64Int16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTFloat64Int16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEFloat64Int16Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int32:
			switch cmpOp {

			case tree.EQ:
				return &selEQFloat64Int32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEFloat64Int32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTFloat64Int32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEFloat64Int32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTFloat64Int32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEFloat64Int32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Int64:
			switch cmpOp {

			case tree.EQ:
				return &selEQFloat64Int64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEFloat64Int64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTFloat64Int64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEFloat64Int64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTFloat64Int64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEFloat64Int64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Float32:
			switch cmpOp {

			case tree.EQ:
				return &selEQFloat64Float32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEFloat64Float32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTFloat64Float32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEFloat64Float32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTFloat64Float32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEFloat64Float32Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		case coltypes.Float64:
			switch cmpOp {

			case tree.EQ:
				return &selEQFloat64Float64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.NE:
				return &selNEFloat64Float64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LT:
				return &selLTFloat64Float64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.LE:
				return &selLEFloat64Float64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GT:
				return &selGTFloat64Float64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			case tree.GE:
				return &selGEFloat64Float64Op{
					OneInputNode: NewOneInputNode(input),
					col1Idx:      col1Idx,
					col2Idx:      col2Idx,
				}, nil

			default:
				return nil, errors.Errorf("unhandled comparison operator: %s", cmpOp)
			}

		default:
			return nil, errors.Errorf("unhandled right type: %s", rightType)
		}

	default:
		return nil, errors.Errorf("unhandled left type: %s", leftType)
	}
}
