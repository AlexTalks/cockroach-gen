// Code generated by execgen; DO NOT EDIT.
// Copyright 2018 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package coldata

import (
	"fmt"

	"github.com/cockroachdb/apd"
	"github.com/cockroachdb/cockroach/pkg/sql/exec/types"
)

func (m *memColumn) Append(args AppendArgs) {
	switch args.ColType {
	case types.Bool:
		fromCol := args.Src.Bool()
		toCol := m.Bool()
		numToAppend := args.SrcEndIdx - args.SrcStartIdx
		if args.Sel == nil {
			toCol = append(toCol[:args.DestIdx], fromCol[args.SrcStartIdx:args.SrcEndIdx]...)
			m.nulls.Extend(args.Src.Nulls(), args.DestIdx, args.SrcStartIdx, numToAppend)
		} else {
			sel := args.Sel[args.SrcStartIdx:args.SrcEndIdx]
			appendVals := make([]bool, len(sel))
			for i, selIdx := range sel {
				appendVals[i] = fromCol[selIdx]
			}
			toCol = append(toCol[:args.DestIdx], appendVals...)
			// TODO(asubiotto): Change Extend* signatures to allow callers to pass in
			// SrcEndIdx instead of numToAppend.
			m.nulls.ExtendWithSel(args.Src.Nulls(), args.DestIdx, args.SrcStartIdx, numToAppend, args.Sel)
		}
		m.col = toCol
	case types.Bytes:
		fromCol := args.Src.Bytes()
		toCol := m.Bytes()
		numToAppend := args.SrcEndIdx - args.SrcStartIdx
		if args.Sel == nil {
			toCol = append(toCol[:args.DestIdx], fromCol[args.SrcStartIdx:args.SrcEndIdx]...)
			m.nulls.Extend(args.Src.Nulls(), args.DestIdx, args.SrcStartIdx, numToAppend)
		} else {
			sel := args.Sel[args.SrcStartIdx:args.SrcEndIdx]
			appendVals := make([][]byte, len(sel))
			for i, selIdx := range sel {
				appendVals[i] = fromCol[selIdx]
			}
			toCol = append(toCol[:args.DestIdx], appendVals...)
			// TODO(asubiotto): Change Extend* signatures to allow callers to pass in
			// SrcEndIdx instead of numToAppend.
			m.nulls.ExtendWithSel(args.Src.Nulls(), args.DestIdx, args.SrcStartIdx, numToAppend, args.Sel)
		}
		m.col = toCol
	case types.Decimal:
		fromCol := args.Src.Decimal()
		toCol := m.Decimal()
		numToAppend := args.SrcEndIdx - args.SrcStartIdx
		if args.Sel == nil {
			toCol = append(toCol[:args.DestIdx], fromCol[args.SrcStartIdx:args.SrcEndIdx]...)
			m.nulls.Extend(args.Src.Nulls(), args.DestIdx, args.SrcStartIdx, numToAppend)
		} else {
			sel := args.Sel[args.SrcStartIdx:args.SrcEndIdx]
			appendVals := make([]apd.Decimal, len(sel))
			for i, selIdx := range sel {
				appendVals[i] = fromCol[selIdx]
			}
			toCol = append(toCol[:args.DestIdx], appendVals...)
			// TODO(asubiotto): Change Extend* signatures to allow callers to pass in
			// SrcEndIdx instead of numToAppend.
			m.nulls.ExtendWithSel(args.Src.Nulls(), args.DestIdx, args.SrcStartIdx, numToAppend, args.Sel)
		}
		m.col = toCol
	case types.Int8:
		fromCol := args.Src.Int8()
		toCol := m.Int8()
		numToAppend := args.SrcEndIdx - args.SrcStartIdx
		if args.Sel == nil {
			toCol = append(toCol[:args.DestIdx], fromCol[args.SrcStartIdx:args.SrcEndIdx]...)
			m.nulls.Extend(args.Src.Nulls(), args.DestIdx, args.SrcStartIdx, numToAppend)
		} else {
			sel := args.Sel[args.SrcStartIdx:args.SrcEndIdx]
			appendVals := make([]int8, len(sel))
			for i, selIdx := range sel {
				appendVals[i] = fromCol[selIdx]
			}
			toCol = append(toCol[:args.DestIdx], appendVals...)
			// TODO(asubiotto): Change Extend* signatures to allow callers to pass in
			// SrcEndIdx instead of numToAppend.
			m.nulls.ExtendWithSel(args.Src.Nulls(), args.DestIdx, args.SrcStartIdx, numToAppend, args.Sel)
		}
		m.col = toCol
	case types.Int16:
		fromCol := args.Src.Int16()
		toCol := m.Int16()
		numToAppend := args.SrcEndIdx - args.SrcStartIdx
		if args.Sel == nil {
			toCol = append(toCol[:args.DestIdx], fromCol[args.SrcStartIdx:args.SrcEndIdx]...)
			m.nulls.Extend(args.Src.Nulls(), args.DestIdx, args.SrcStartIdx, numToAppend)
		} else {
			sel := args.Sel[args.SrcStartIdx:args.SrcEndIdx]
			appendVals := make([]int16, len(sel))
			for i, selIdx := range sel {
				appendVals[i] = fromCol[selIdx]
			}
			toCol = append(toCol[:args.DestIdx], appendVals...)
			// TODO(asubiotto): Change Extend* signatures to allow callers to pass in
			// SrcEndIdx instead of numToAppend.
			m.nulls.ExtendWithSel(args.Src.Nulls(), args.DestIdx, args.SrcStartIdx, numToAppend, args.Sel)
		}
		m.col = toCol
	case types.Int32:
		fromCol := args.Src.Int32()
		toCol := m.Int32()
		numToAppend := args.SrcEndIdx - args.SrcStartIdx
		if args.Sel == nil {
			toCol = append(toCol[:args.DestIdx], fromCol[args.SrcStartIdx:args.SrcEndIdx]...)
			m.nulls.Extend(args.Src.Nulls(), args.DestIdx, args.SrcStartIdx, numToAppend)
		} else {
			sel := args.Sel[args.SrcStartIdx:args.SrcEndIdx]
			appendVals := make([]int32, len(sel))
			for i, selIdx := range sel {
				appendVals[i] = fromCol[selIdx]
			}
			toCol = append(toCol[:args.DestIdx], appendVals...)
			// TODO(asubiotto): Change Extend* signatures to allow callers to pass in
			// SrcEndIdx instead of numToAppend.
			m.nulls.ExtendWithSel(args.Src.Nulls(), args.DestIdx, args.SrcStartIdx, numToAppend, args.Sel)
		}
		m.col = toCol
	case types.Int64:
		fromCol := args.Src.Int64()
		toCol := m.Int64()
		numToAppend := args.SrcEndIdx - args.SrcStartIdx
		if args.Sel == nil {
			toCol = append(toCol[:args.DestIdx], fromCol[args.SrcStartIdx:args.SrcEndIdx]...)
			m.nulls.Extend(args.Src.Nulls(), args.DestIdx, args.SrcStartIdx, numToAppend)
		} else {
			sel := args.Sel[args.SrcStartIdx:args.SrcEndIdx]
			appendVals := make([]int64, len(sel))
			for i, selIdx := range sel {
				appendVals[i] = fromCol[selIdx]
			}
			toCol = append(toCol[:args.DestIdx], appendVals...)
			// TODO(asubiotto): Change Extend* signatures to allow callers to pass in
			// SrcEndIdx instead of numToAppend.
			m.nulls.ExtendWithSel(args.Src.Nulls(), args.DestIdx, args.SrcStartIdx, numToAppend, args.Sel)
		}
		m.col = toCol
	case types.Float32:
		fromCol := args.Src.Float32()
		toCol := m.Float32()
		numToAppend := args.SrcEndIdx - args.SrcStartIdx
		if args.Sel == nil {
			toCol = append(toCol[:args.DestIdx], fromCol[args.SrcStartIdx:args.SrcEndIdx]...)
			m.nulls.Extend(args.Src.Nulls(), args.DestIdx, args.SrcStartIdx, numToAppend)
		} else {
			sel := args.Sel[args.SrcStartIdx:args.SrcEndIdx]
			appendVals := make([]float32, len(sel))
			for i, selIdx := range sel {
				appendVals[i] = fromCol[selIdx]
			}
			toCol = append(toCol[:args.DestIdx], appendVals...)
			// TODO(asubiotto): Change Extend* signatures to allow callers to pass in
			// SrcEndIdx instead of numToAppend.
			m.nulls.ExtendWithSel(args.Src.Nulls(), args.DestIdx, args.SrcStartIdx, numToAppend, args.Sel)
		}
		m.col = toCol
	case types.Float64:
		fromCol := args.Src.Float64()
		toCol := m.Float64()
		numToAppend := args.SrcEndIdx - args.SrcStartIdx
		if args.Sel == nil {
			toCol = append(toCol[:args.DestIdx], fromCol[args.SrcStartIdx:args.SrcEndIdx]...)
			m.nulls.Extend(args.Src.Nulls(), args.DestIdx, args.SrcStartIdx, numToAppend)
		} else {
			sel := args.Sel[args.SrcStartIdx:args.SrcEndIdx]
			appendVals := make([]float64, len(sel))
			for i, selIdx := range sel {
				appendVals[i] = fromCol[selIdx]
			}
			toCol = append(toCol[:args.DestIdx], appendVals...)
			// TODO(asubiotto): Change Extend* signatures to allow callers to pass in
			// SrcEndIdx instead of numToAppend.
			m.nulls.ExtendWithSel(args.Src.Nulls(), args.DestIdx, args.SrcStartIdx, numToAppend, args.Sel)
		}
		m.col = toCol
	default:
		panic(fmt.Sprintf("unhandled type %s", args.ColType))
	}
}

func (m *memColumn) Copy(src Vec, srcStartIdx, srcEndIdx uint64, typ types.T) {
	m.CopyAt(src, 0, srcStartIdx, srcEndIdx, typ)
}

func (m *memColumn) CopyAt(src Vec, destStartIdx, srcStartIdx, srcEndIdx uint64, typ types.T) {
	switch typ {
	case types.Bool:
		copy(m.Bool()[destStartIdx:], src.Bool()[srcStartIdx:srcEndIdx])
		// TODO(asubiotto): Improve this, there are cases where we don't need to
		// allocate a new bitmap.
		srcBitmap := src.Nulls().NullBitmap()
		m.nulls.nulls = make([]byte, len(srcBitmap))
		m.nulls.UnsetNulls()
		if !src.HasNulls() {
			return
		}
		if destStartIdx == 0 {
			m.nulls.hasNulls = true
			copy(m.nulls.nulls, srcBitmap)
		} else {
			// The above strategy to just copy will not work. Fall back to a loop.
			// TODO(asubiotto): This can be improved as well.
			srcNulls := src.Nulls()
			for curDestIdx, curSrcIdx := destStartIdx, srcStartIdx; curSrcIdx < srcEndIdx; curDestIdx, curSrcIdx = curDestIdx+1, curSrcIdx+1 {
				if srcNulls.NullAt64(curSrcIdx) {
					m.nulls.SetNull64(curDestIdx)
				}
			}
		}
	case types.Bytes:
		copy(m.Bytes()[destStartIdx:], src.Bytes()[srcStartIdx:srcEndIdx])
		// TODO(asubiotto): Improve this, there are cases where we don't need to
		// allocate a new bitmap.
		srcBitmap := src.Nulls().NullBitmap()
		m.nulls.nulls = make([]byte, len(srcBitmap))
		m.nulls.UnsetNulls()
		if !src.HasNulls() {
			return
		}
		if destStartIdx == 0 {
			m.nulls.hasNulls = true
			copy(m.nulls.nulls, srcBitmap)
		} else {
			// The above strategy to just copy will not work. Fall back to a loop.
			// TODO(asubiotto): This can be improved as well.
			srcNulls := src.Nulls()
			for curDestIdx, curSrcIdx := destStartIdx, srcStartIdx; curSrcIdx < srcEndIdx; curDestIdx, curSrcIdx = curDestIdx+1, curSrcIdx+1 {
				if srcNulls.NullAt64(curSrcIdx) {
					m.nulls.SetNull64(curDestIdx)
				}
			}
		}
	case types.Decimal:
		copy(m.Decimal()[destStartIdx:], src.Decimal()[srcStartIdx:srcEndIdx])
		// TODO(asubiotto): Improve this, there are cases where we don't need to
		// allocate a new bitmap.
		srcBitmap := src.Nulls().NullBitmap()
		m.nulls.nulls = make([]byte, len(srcBitmap))
		m.nulls.UnsetNulls()
		if !src.HasNulls() {
			return
		}
		if destStartIdx == 0 {
			m.nulls.hasNulls = true
			copy(m.nulls.nulls, srcBitmap)
		} else {
			// The above strategy to just copy will not work. Fall back to a loop.
			// TODO(asubiotto): This can be improved as well.
			srcNulls := src.Nulls()
			for curDestIdx, curSrcIdx := destStartIdx, srcStartIdx; curSrcIdx < srcEndIdx; curDestIdx, curSrcIdx = curDestIdx+1, curSrcIdx+1 {
				if srcNulls.NullAt64(curSrcIdx) {
					m.nulls.SetNull64(curDestIdx)
				}
			}
		}
	case types.Int8:
		copy(m.Int8()[destStartIdx:], src.Int8()[srcStartIdx:srcEndIdx])
		// TODO(asubiotto): Improve this, there are cases where we don't need to
		// allocate a new bitmap.
		srcBitmap := src.Nulls().NullBitmap()
		m.nulls.nulls = make([]byte, len(srcBitmap))
		m.nulls.UnsetNulls()
		if !src.HasNulls() {
			return
		}
		if destStartIdx == 0 {
			m.nulls.hasNulls = true
			copy(m.nulls.nulls, srcBitmap)
		} else {
			// The above strategy to just copy will not work. Fall back to a loop.
			// TODO(asubiotto): This can be improved as well.
			srcNulls := src.Nulls()
			for curDestIdx, curSrcIdx := destStartIdx, srcStartIdx; curSrcIdx < srcEndIdx; curDestIdx, curSrcIdx = curDestIdx+1, curSrcIdx+1 {
				if srcNulls.NullAt64(curSrcIdx) {
					m.nulls.SetNull64(curDestIdx)
				}
			}
		}
	case types.Int16:
		copy(m.Int16()[destStartIdx:], src.Int16()[srcStartIdx:srcEndIdx])
		// TODO(asubiotto): Improve this, there are cases where we don't need to
		// allocate a new bitmap.
		srcBitmap := src.Nulls().NullBitmap()
		m.nulls.nulls = make([]byte, len(srcBitmap))
		m.nulls.UnsetNulls()
		if !src.HasNulls() {
			return
		}
		if destStartIdx == 0 {
			m.nulls.hasNulls = true
			copy(m.nulls.nulls, srcBitmap)
		} else {
			// The above strategy to just copy will not work. Fall back to a loop.
			// TODO(asubiotto): This can be improved as well.
			srcNulls := src.Nulls()
			for curDestIdx, curSrcIdx := destStartIdx, srcStartIdx; curSrcIdx < srcEndIdx; curDestIdx, curSrcIdx = curDestIdx+1, curSrcIdx+1 {
				if srcNulls.NullAt64(curSrcIdx) {
					m.nulls.SetNull64(curDestIdx)
				}
			}
		}
	case types.Int32:
		copy(m.Int32()[destStartIdx:], src.Int32()[srcStartIdx:srcEndIdx])
		// TODO(asubiotto): Improve this, there are cases where we don't need to
		// allocate a new bitmap.
		srcBitmap := src.Nulls().NullBitmap()
		m.nulls.nulls = make([]byte, len(srcBitmap))
		m.nulls.UnsetNulls()
		if !src.HasNulls() {
			return
		}
		if destStartIdx == 0 {
			m.nulls.hasNulls = true
			copy(m.nulls.nulls, srcBitmap)
		} else {
			// The above strategy to just copy will not work. Fall back to a loop.
			// TODO(asubiotto): This can be improved as well.
			srcNulls := src.Nulls()
			for curDestIdx, curSrcIdx := destStartIdx, srcStartIdx; curSrcIdx < srcEndIdx; curDestIdx, curSrcIdx = curDestIdx+1, curSrcIdx+1 {
				if srcNulls.NullAt64(curSrcIdx) {
					m.nulls.SetNull64(curDestIdx)
				}
			}
		}
	case types.Int64:
		copy(m.Int64()[destStartIdx:], src.Int64()[srcStartIdx:srcEndIdx])
		// TODO(asubiotto): Improve this, there are cases where we don't need to
		// allocate a new bitmap.
		srcBitmap := src.Nulls().NullBitmap()
		m.nulls.nulls = make([]byte, len(srcBitmap))
		m.nulls.UnsetNulls()
		if !src.HasNulls() {
			return
		}
		if destStartIdx == 0 {
			m.nulls.hasNulls = true
			copy(m.nulls.nulls, srcBitmap)
		} else {
			// The above strategy to just copy will not work. Fall back to a loop.
			// TODO(asubiotto): This can be improved as well.
			srcNulls := src.Nulls()
			for curDestIdx, curSrcIdx := destStartIdx, srcStartIdx; curSrcIdx < srcEndIdx; curDestIdx, curSrcIdx = curDestIdx+1, curSrcIdx+1 {
				if srcNulls.NullAt64(curSrcIdx) {
					m.nulls.SetNull64(curDestIdx)
				}
			}
		}
	case types.Float32:
		copy(m.Float32()[destStartIdx:], src.Float32()[srcStartIdx:srcEndIdx])
		// TODO(asubiotto): Improve this, there are cases where we don't need to
		// allocate a new bitmap.
		srcBitmap := src.Nulls().NullBitmap()
		m.nulls.nulls = make([]byte, len(srcBitmap))
		m.nulls.UnsetNulls()
		if !src.HasNulls() {
			return
		}
		if destStartIdx == 0 {
			m.nulls.hasNulls = true
			copy(m.nulls.nulls, srcBitmap)
		} else {
			// The above strategy to just copy will not work. Fall back to a loop.
			// TODO(asubiotto): This can be improved as well.
			srcNulls := src.Nulls()
			for curDestIdx, curSrcIdx := destStartIdx, srcStartIdx; curSrcIdx < srcEndIdx; curDestIdx, curSrcIdx = curDestIdx+1, curSrcIdx+1 {
				if srcNulls.NullAt64(curSrcIdx) {
					m.nulls.SetNull64(curDestIdx)
				}
			}
		}
	case types.Float64:
		copy(m.Float64()[destStartIdx:], src.Float64()[srcStartIdx:srcEndIdx])
		// TODO(asubiotto): Improve this, there are cases where we don't need to
		// allocate a new bitmap.
		srcBitmap := src.Nulls().NullBitmap()
		m.nulls.nulls = make([]byte, len(srcBitmap))
		m.nulls.UnsetNulls()
		if !src.HasNulls() {
			return
		}
		if destStartIdx == 0 {
			m.nulls.hasNulls = true
			copy(m.nulls.nulls, srcBitmap)
		} else {
			// The above strategy to just copy will not work. Fall back to a loop.
			// TODO(asubiotto): This can be improved as well.
			srcNulls := src.Nulls()
			for curDestIdx, curSrcIdx := destStartIdx, srcStartIdx; curSrcIdx < srcEndIdx; curDestIdx, curSrcIdx = curDestIdx+1, curSrcIdx+1 {
				if srcNulls.NullAt64(curSrcIdx) {
					m.nulls.SetNull64(curDestIdx)
				}
			}
		}
	default:
		panic(fmt.Sprintf("unhandled type %d", typ))
	}
}

func (m *memColumn) CopyWithSelInt64(vec Vec, sel []uint64, nSel uint16, colType types.T) {
	m.nulls.UnsetNulls()

	// todo (changangela): handle the case when nSel > BatchSize
	switch colType {
	case types.Bool:
		toCol := m.Bool()
		fromCol := vec.Bool()

		if vec.HasNulls() {
			for i := uint16(0); i < nSel; i++ {
				if vec.Nulls().NullAt64(sel[i]) {
					m.nulls.SetNull(i)
				} else {
					toCol[i] = fromCol[sel[i]]
				}
			}
		} else {
			for i := uint16(0); i < nSel; i++ {
				toCol[i] = fromCol[sel[i]]
			}
		}
	case types.Bytes:
		toCol := m.Bytes()
		fromCol := vec.Bytes()

		if vec.HasNulls() {
			for i := uint16(0); i < nSel; i++ {
				if vec.Nulls().NullAt64(sel[i]) {
					m.nulls.SetNull(i)
				} else {
					toCol[i] = fromCol[sel[i]]
				}
			}
		} else {
			for i := uint16(0); i < nSel; i++ {
				toCol[i] = fromCol[sel[i]]
			}
		}
	case types.Decimal:
		toCol := m.Decimal()
		fromCol := vec.Decimal()

		if vec.HasNulls() {
			for i := uint16(0); i < nSel; i++ {
				if vec.Nulls().NullAt64(sel[i]) {
					m.nulls.SetNull(i)
				} else {
					toCol[i] = fromCol[sel[i]]
				}
			}
		} else {
			for i := uint16(0); i < nSel; i++ {
				toCol[i] = fromCol[sel[i]]
			}
		}
	case types.Int8:
		toCol := m.Int8()
		fromCol := vec.Int8()

		if vec.HasNulls() {
			for i := uint16(0); i < nSel; i++ {
				if vec.Nulls().NullAt64(sel[i]) {
					m.nulls.SetNull(i)
				} else {
					toCol[i] = fromCol[sel[i]]
				}
			}
		} else {
			for i := uint16(0); i < nSel; i++ {
				toCol[i] = fromCol[sel[i]]
			}
		}
	case types.Int16:
		toCol := m.Int16()
		fromCol := vec.Int16()

		if vec.HasNulls() {
			for i := uint16(0); i < nSel; i++ {
				if vec.Nulls().NullAt64(sel[i]) {
					m.nulls.SetNull(i)
				} else {
					toCol[i] = fromCol[sel[i]]
				}
			}
		} else {
			for i := uint16(0); i < nSel; i++ {
				toCol[i] = fromCol[sel[i]]
			}
		}
	case types.Int32:
		toCol := m.Int32()
		fromCol := vec.Int32()

		if vec.HasNulls() {
			for i := uint16(0); i < nSel; i++ {
				if vec.Nulls().NullAt64(sel[i]) {
					m.nulls.SetNull(i)
				} else {
					toCol[i] = fromCol[sel[i]]
				}
			}
		} else {
			for i := uint16(0); i < nSel; i++ {
				toCol[i] = fromCol[sel[i]]
			}
		}
	case types.Int64:
		toCol := m.Int64()
		fromCol := vec.Int64()

		if vec.HasNulls() {
			for i := uint16(0); i < nSel; i++ {
				if vec.Nulls().NullAt64(sel[i]) {
					m.nulls.SetNull(i)
				} else {
					toCol[i] = fromCol[sel[i]]
				}
			}
		} else {
			for i := uint16(0); i < nSel; i++ {
				toCol[i] = fromCol[sel[i]]
			}
		}
	case types.Float32:
		toCol := m.Float32()
		fromCol := vec.Float32()

		if vec.HasNulls() {
			for i := uint16(0); i < nSel; i++ {
				if vec.Nulls().NullAt64(sel[i]) {
					m.nulls.SetNull(i)
				} else {
					toCol[i] = fromCol[sel[i]]
				}
			}
		} else {
			for i := uint16(0); i < nSel; i++ {
				toCol[i] = fromCol[sel[i]]
			}
		}
	case types.Float64:
		toCol := m.Float64()
		fromCol := vec.Float64()

		if vec.HasNulls() {
			for i := uint16(0); i < nSel; i++ {
				if vec.Nulls().NullAt64(sel[i]) {
					m.nulls.SetNull(i)
				} else {
					toCol[i] = fromCol[sel[i]]
				}
			}
		} else {
			for i := uint16(0); i < nSel; i++ {
				toCol[i] = fromCol[sel[i]]
			}
		}
	default:
		panic(fmt.Sprintf("unhandled type %d", colType))
	}
}

func (m *memColumn) CopyWithSelInt16(vec Vec, sel []uint16, nSel uint16, colType types.T) {
	m.nulls.UnsetNulls()

	switch colType {
	case types.Bool:
		toCol := m.Bool()
		fromCol := vec.Bool()

		if vec.HasNulls() {
			for i := uint16(0); i < nSel; i++ {
				if vec.Nulls().NullAt(sel[i]) {
					m.nulls.SetNull(i)
				} else {
					toCol[i] = fromCol[sel[i]]
				}
			}
		} else {
			for i := uint16(0); i < nSel; i++ {
				toCol[i] = fromCol[sel[i]]
			}
		}
	case types.Bytes:
		toCol := m.Bytes()
		fromCol := vec.Bytes()

		if vec.HasNulls() {
			for i := uint16(0); i < nSel; i++ {
				if vec.Nulls().NullAt(sel[i]) {
					m.nulls.SetNull(i)
				} else {
					toCol[i] = fromCol[sel[i]]
				}
			}
		} else {
			for i := uint16(0); i < nSel; i++ {
				toCol[i] = fromCol[sel[i]]
			}
		}
	case types.Decimal:
		toCol := m.Decimal()
		fromCol := vec.Decimal()

		if vec.HasNulls() {
			for i := uint16(0); i < nSel; i++ {
				if vec.Nulls().NullAt(sel[i]) {
					m.nulls.SetNull(i)
				} else {
					toCol[i] = fromCol[sel[i]]
				}
			}
		} else {
			for i := uint16(0); i < nSel; i++ {
				toCol[i] = fromCol[sel[i]]
			}
		}
	case types.Int8:
		toCol := m.Int8()
		fromCol := vec.Int8()

		if vec.HasNulls() {
			for i := uint16(0); i < nSel; i++ {
				if vec.Nulls().NullAt(sel[i]) {
					m.nulls.SetNull(i)
				} else {
					toCol[i] = fromCol[sel[i]]
				}
			}
		} else {
			for i := uint16(0); i < nSel; i++ {
				toCol[i] = fromCol[sel[i]]
			}
		}
	case types.Int16:
		toCol := m.Int16()
		fromCol := vec.Int16()

		if vec.HasNulls() {
			for i := uint16(0); i < nSel; i++ {
				if vec.Nulls().NullAt(sel[i]) {
					m.nulls.SetNull(i)
				} else {
					toCol[i] = fromCol[sel[i]]
				}
			}
		} else {
			for i := uint16(0); i < nSel; i++ {
				toCol[i] = fromCol[sel[i]]
			}
		}
	case types.Int32:
		toCol := m.Int32()
		fromCol := vec.Int32()

		if vec.HasNulls() {
			for i := uint16(0); i < nSel; i++ {
				if vec.Nulls().NullAt(sel[i]) {
					m.nulls.SetNull(i)
				} else {
					toCol[i] = fromCol[sel[i]]
				}
			}
		} else {
			for i := uint16(0); i < nSel; i++ {
				toCol[i] = fromCol[sel[i]]
			}
		}
	case types.Int64:
		toCol := m.Int64()
		fromCol := vec.Int64()

		if vec.HasNulls() {
			for i := uint16(0); i < nSel; i++ {
				if vec.Nulls().NullAt(sel[i]) {
					m.nulls.SetNull(i)
				} else {
					toCol[i] = fromCol[sel[i]]
				}
			}
		} else {
			for i := uint16(0); i < nSel; i++ {
				toCol[i] = fromCol[sel[i]]
			}
		}
	case types.Float32:
		toCol := m.Float32()
		fromCol := vec.Float32()

		if vec.HasNulls() {
			for i := uint16(0); i < nSel; i++ {
				if vec.Nulls().NullAt(sel[i]) {
					m.nulls.SetNull(i)
				} else {
					toCol[i] = fromCol[sel[i]]
				}
			}
		} else {
			for i := uint16(0); i < nSel; i++ {
				toCol[i] = fromCol[sel[i]]
			}
		}
	case types.Float64:
		toCol := m.Float64()
		fromCol := vec.Float64()

		if vec.HasNulls() {
			for i := uint16(0); i < nSel; i++ {
				if vec.Nulls().NullAt(sel[i]) {
					m.nulls.SetNull(i)
				} else {
					toCol[i] = fromCol[sel[i]]
				}
			}
		} else {
			for i := uint16(0); i < nSel; i++ {
				toCol[i] = fromCol[sel[i]]
			}
		}
	default:
		panic(fmt.Sprintf("unhandled type %d", colType))
	}
}

func (m *memColumn) CopyWithSelAndNilsInt64(
	vec Vec, sel []uint64, nSel uint16, nils []bool, colType types.T,
) {
	m.nulls.UnsetNulls()

	switch colType {
	case types.Bool:
		toCol := m.Bool()
		fromCol := vec.Bool()

		if vec.HasNulls() {
			// TODO(jordan): copy the null arrays in batch.
			for i := uint16(0); i < nSel; i++ {
				if nils[i] {
					m.nulls.SetNull(i)
				} else {
					if vec.Nulls().NullAt64(sel[i]) {
						m.nulls.SetNull(i)
					} else {
						toCol[i] = fromCol[sel[i]]
					}
				}
			}
		} else {
			for i := uint16(0); i < nSel; i++ {
				if nils[i] {
					m.nulls.SetNull(i)
				} else {
					toCol[i] = fromCol[sel[i]]
				}
			}
		}
	case types.Bytes:
		toCol := m.Bytes()
		fromCol := vec.Bytes()

		if vec.HasNulls() {
			// TODO(jordan): copy the null arrays in batch.
			for i := uint16(0); i < nSel; i++ {
				if nils[i] {
					m.nulls.SetNull(i)
				} else {
					if vec.Nulls().NullAt64(sel[i]) {
						m.nulls.SetNull(i)
					} else {
						toCol[i] = fromCol[sel[i]]
					}
				}
			}
		} else {
			for i := uint16(0); i < nSel; i++ {
				if nils[i] {
					m.nulls.SetNull(i)
				} else {
					toCol[i] = fromCol[sel[i]]
				}
			}
		}
	case types.Decimal:
		toCol := m.Decimal()
		fromCol := vec.Decimal()

		if vec.HasNulls() {
			// TODO(jordan): copy the null arrays in batch.
			for i := uint16(0); i < nSel; i++ {
				if nils[i] {
					m.nulls.SetNull(i)
				} else {
					if vec.Nulls().NullAt64(sel[i]) {
						m.nulls.SetNull(i)
					} else {
						toCol[i] = fromCol[sel[i]]
					}
				}
			}
		} else {
			for i := uint16(0); i < nSel; i++ {
				if nils[i] {
					m.nulls.SetNull(i)
				} else {
					toCol[i] = fromCol[sel[i]]
				}
			}
		}
	case types.Int8:
		toCol := m.Int8()
		fromCol := vec.Int8()

		if vec.HasNulls() {
			// TODO(jordan): copy the null arrays in batch.
			for i := uint16(0); i < nSel; i++ {
				if nils[i] {
					m.nulls.SetNull(i)
				} else {
					if vec.Nulls().NullAt64(sel[i]) {
						m.nulls.SetNull(i)
					} else {
						toCol[i] = fromCol[sel[i]]
					}
				}
			}
		} else {
			for i := uint16(0); i < nSel; i++ {
				if nils[i] {
					m.nulls.SetNull(i)
				} else {
					toCol[i] = fromCol[sel[i]]
				}
			}
		}
	case types.Int16:
		toCol := m.Int16()
		fromCol := vec.Int16()

		if vec.HasNulls() {
			// TODO(jordan): copy the null arrays in batch.
			for i := uint16(0); i < nSel; i++ {
				if nils[i] {
					m.nulls.SetNull(i)
				} else {
					if vec.Nulls().NullAt64(sel[i]) {
						m.nulls.SetNull(i)
					} else {
						toCol[i] = fromCol[sel[i]]
					}
				}
			}
		} else {
			for i := uint16(0); i < nSel; i++ {
				if nils[i] {
					m.nulls.SetNull(i)
				} else {
					toCol[i] = fromCol[sel[i]]
				}
			}
		}
	case types.Int32:
		toCol := m.Int32()
		fromCol := vec.Int32()

		if vec.HasNulls() {
			// TODO(jordan): copy the null arrays in batch.
			for i := uint16(0); i < nSel; i++ {
				if nils[i] {
					m.nulls.SetNull(i)
				} else {
					if vec.Nulls().NullAt64(sel[i]) {
						m.nulls.SetNull(i)
					} else {
						toCol[i] = fromCol[sel[i]]
					}
				}
			}
		} else {
			for i := uint16(0); i < nSel; i++ {
				if nils[i] {
					m.nulls.SetNull(i)
				} else {
					toCol[i] = fromCol[sel[i]]
				}
			}
		}
	case types.Int64:
		toCol := m.Int64()
		fromCol := vec.Int64()

		if vec.HasNulls() {
			// TODO(jordan): copy the null arrays in batch.
			for i := uint16(0); i < nSel; i++ {
				if nils[i] {
					m.nulls.SetNull(i)
				} else {
					if vec.Nulls().NullAt64(sel[i]) {
						m.nulls.SetNull(i)
					} else {
						toCol[i] = fromCol[sel[i]]
					}
				}
			}
		} else {
			for i := uint16(0); i < nSel; i++ {
				if nils[i] {
					m.nulls.SetNull(i)
				} else {
					toCol[i] = fromCol[sel[i]]
				}
			}
		}
	case types.Float32:
		toCol := m.Float32()
		fromCol := vec.Float32()

		if vec.HasNulls() {
			// TODO(jordan): copy the null arrays in batch.
			for i := uint16(0); i < nSel; i++ {
				if nils[i] {
					m.nulls.SetNull(i)
				} else {
					if vec.Nulls().NullAt64(sel[i]) {
						m.nulls.SetNull(i)
					} else {
						toCol[i] = fromCol[sel[i]]
					}
				}
			}
		} else {
			for i := uint16(0); i < nSel; i++ {
				if nils[i] {
					m.nulls.SetNull(i)
				} else {
					toCol[i] = fromCol[sel[i]]
				}
			}
		}
	case types.Float64:
		toCol := m.Float64()
		fromCol := vec.Float64()

		if vec.HasNulls() {
			// TODO(jordan): copy the null arrays in batch.
			for i := uint16(0); i < nSel; i++ {
				if nils[i] {
					m.nulls.SetNull(i)
				} else {
					if vec.Nulls().NullAt64(sel[i]) {
						m.nulls.SetNull(i)
					} else {
						toCol[i] = fromCol[sel[i]]
					}
				}
			}
		} else {
			for i := uint16(0); i < nSel; i++ {
				if nils[i] {
					m.nulls.SetNull(i)
				} else {
					toCol[i] = fromCol[sel[i]]
				}
			}
		}
	default:
		panic(fmt.Sprintf("unhandled type %d", colType))
	}
}

func (m *memColumn) Slice(colType types.T, start uint64, end uint64) Vec {
	switch colType {
	case types.Bool:
		col := m.Bool()
		return &memColumn{
			col:   col[start:end],
			nulls: m.nulls.Slice(start, end),
		}
	case types.Bytes:
		col := m.Bytes()
		return &memColumn{
			col:   col[start:end],
			nulls: m.nulls.Slice(start, end),
		}
	case types.Decimal:
		col := m.Decimal()
		return &memColumn{
			col:   col[start:end],
			nulls: m.nulls.Slice(start, end),
		}
	case types.Int8:
		col := m.Int8()
		return &memColumn{
			col:   col[start:end],
			nulls: m.nulls.Slice(start, end),
		}
	case types.Int16:
		col := m.Int16()
		return &memColumn{
			col:   col[start:end],
			nulls: m.nulls.Slice(start, end),
		}
	case types.Int32:
		col := m.Int32()
		return &memColumn{
			col:   col[start:end],
			nulls: m.nulls.Slice(start, end),
		}
	case types.Int64:
		col := m.Int64()
		return &memColumn{
			col:   col[start:end],
			nulls: m.nulls.Slice(start, end),
		}
	case types.Float32:
		col := m.Float32()
		return &memColumn{
			col:   col[start:end],
			nulls: m.nulls.Slice(start, end),
		}
	case types.Float64:
		col := m.Float64()
		return &memColumn{
			col:   col[start:end],
			nulls: m.nulls.Slice(start, end),
		}
	default:
		panic(fmt.Sprintf("unhandled type %d", colType))
	}
}

func (m *memColumn) PrettyValueAt(colIdx uint16, colType types.T) string {
	if m.nulls.NullAt(colIdx) {
		return "NULL"
	}
	switch colType {
	case types.Bool:
		return fmt.Sprintf("%v", m.Bool()[colIdx])
	case types.Bytes:
		return fmt.Sprintf("%v", m.Bytes()[colIdx])
	case types.Decimal:
		return fmt.Sprintf("%v", m.Decimal()[colIdx])
	case types.Int8:
		return fmt.Sprintf("%v", m.Int8()[colIdx])
	case types.Int16:
		return fmt.Sprintf("%v", m.Int16()[colIdx])
	case types.Int32:
		return fmt.Sprintf("%v", m.Int32()[colIdx])
	case types.Int64:
		return fmt.Sprintf("%v", m.Int64()[colIdx])
	case types.Float32:
		return fmt.Sprintf("%v", m.Float32()[colIdx])
	case types.Float64:
		return fmt.Sprintf("%v", m.Float64()[colIdx])
	default:
		panic(fmt.Sprintf("unhandled type %d", colType))
	}
}
