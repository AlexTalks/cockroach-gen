// Code generated by execgen; DO NOT EDIT.

package exec

import (
	"bytes"
	"context"
	"regexp"

	"github.com/cockroachdb/cockroach/pkg/sql/exec/coldata"
)

type selPrefixBytesBytesConstOp struct {
	input Operator

	colIdx   int
	constArg []byte
}

func (p *selPrefixBytesBytesConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Bytes()[:coldata.BatchSize]
		var idx uint16
		n := batch.Length()
		if vec.HasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					cmp = bytes.HasPrefix(col[i], p.constArg)
					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					var cmp bool
					cmp = bytes.HasPrefix(col[i], p.constArg)
					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					cmp = bytes.HasPrefix(col[i], p.constArg)
					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					var cmp bool
					cmp = bytes.HasPrefix(col[i], p.constArg)
					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selPrefixBytesBytesConstOp) Init() {
	p.input.Init()
}

type selSuffixBytesBytesConstOp struct {
	input Operator

	colIdx   int
	constArg []byte
}

func (p *selSuffixBytesBytesConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Bytes()[:coldata.BatchSize]
		var idx uint16
		n := batch.Length()
		if vec.HasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					cmp = bytes.HasSuffix(col[i], p.constArg)
					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					var cmp bool
					cmp = bytes.HasSuffix(col[i], p.constArg)
					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					cmp = bytes.HasSuffix(col[i], p.constArg)
					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					var cmp bool
					cmp = bytes.HasSuffix(col[i], p.constArg)
					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selSuffixBytesBytesConstOp) Init() {
	p.input.Init()
}

type selRegexpBytesBytesConstOp struct {
	input Operator

	colIdx   int
	constArg *regexp.Regexp
}

func (p *selRegexpBytesBytesConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Bytes()[:coldata.BatchSize]
		var idx uint16
		n := batch.Length()
		if vec.HasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					cmp = p.constArg.Match(col[i])
					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					var cmp bool
					cmp = p.constArg.Match(col[i])
					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					cmp = p.constArg.Match(col[i])
					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					var cmp bool
					cmp = p.constArg.Match(col[i])
					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selRegexpBytesBytesConstOp) Init() {
	p.input.Init()
}

type selNotPrefixBytesBytesConstOp struct {
	input Operator

	colIdx   int
	constArg []byte
}

func (p *selNotPrefixBytesBytesConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Bytes()[:coldata.BatchSize]
		var idx uint16
		n := batch.Length()
		if vec.HasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					cmp = !bytes.HasPrefix(col[i], p.constArg)
					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					var cmp bool
					cmp = !bytes.HasPrefix(col[i], p.constArg)
					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					cmp = !bytes.HasPrefix(col[i], p.constArg)
					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					var cmp bool
					cmp = !bytes.HasPrefix(col[i], p.constArg)
					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNotPrefixBytesBytesConstOp) Init() {
	p.input.Init()
}

type selNotSuffixBytesBytesConstOp struct {
	input Operator

	colIdx   int
	constArg []byte
}

func (p *selNotSuffixBytesBytesConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Bytes()[:coldata.BatchSize]
		var idx uint16
		n := batch.Length()
		if vec.HasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					cmp = !bytes.HasSuffix(col[i], p.constArg)
					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					var cmp bool
					cmp = !bytes.HasSuffix(col[i], p.constArg)
					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					cmp = !bytes.HasSuffix(col[i], p.constArg)
					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					var cmp bool
					cmp = !bytes.HasSuffix(col[i], p.constArg)
					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNotSuffixBytesBytesConstOp) Init() {
	p.input.Init()
}

type selNotRegexpBytesBytesConstOp struct {
	input Operator

	colIdx   int
	constArg *regexp.Regexp
}

func (p *selNotRegexpBytesBytesConstOp) Next(ctx context.Context) coldata.Batch {
	for {
		batch := p.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(p.colIdx)
		col := vec.Bytes()[:coldata.BatchSize]
		var idx uint16
		n := batch.Length()
		if vec.HasNulls() {
			nulls := vec.Nulls()

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					cmp = !p.constArg.Match(col[i])
					if cmp && !nulls.NullAt(i) {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					var cmp bool
					cmp = !p.constArg.Match(col[i])
					if cmp && !nulls.NullAt(uint16(i)) {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		} else {

			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					var cmp bool
					cmp = !p.constArg.Match(col[i])
					if cmp {
						sel[idx] = i
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					var cmp bool
					cmp = !p.constArg.Match(col[i])
					if cmp {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}

		}
		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

func (p selNotRegexpBytesBytesConstOp) Init() {
	p.input.Init()
}
