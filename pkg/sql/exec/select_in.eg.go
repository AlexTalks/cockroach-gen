// Code generated by execgen; DO NOT EDIT.
// Copyright 2019 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package exec

import (
	"bytes"
	"context"

	"github.com/cockroachdb/apd"
	"github.com/cockroachdb/cockroach/pkg/sql/exec/coldata"
	"github.com/cockroachdb/cockroach/pkg/sql/exec/types"
	"github.com/cockroachdb/cockroach/pkg/sql/exec/types/conv"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	semtypes "github.com/cockroachdb/cockroach/pkg/sql/types"
	"github.com/pkg/errors"
)

// Enum used to represent comparison results
type comparisonResult int

const (
	siTrue comparisonResult = iota
	siFalse
	siNull
)

func GetInOperator(
	ct *semtypes.T, input Operator, colIdx int, datumTuple *tree.DTuple, negate bool,
) (Operator, error) {
	var err error
	switch t := conv.FromColumnType(ct); t {
	case types.Bool:
		obj := &selectInOpBool{
			input:  input,
			colIdx: colIdx,
			negate: negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowBool(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case types.Bytes:
		obj := &selectInOpBytes{
			input:  input,
			colIdx: colIdx,
			negate: negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowBytes(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case types.Decimal:
		obj := &selectInOpDecimal{
			input:  input,
			colIdx: colIdx,
			negate: negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowDecimal(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case types.Int8:
		obj := &selectInOpInt8{
			input:  input,
			colIdx: colIdx,
			negate: negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowInt8(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case types.Int16:
		obj := &selectInOpInt16{
			input:  input,
			colIdx: colIdx,
			negate: negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowInt16(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case types.Int32:
		obj := &selectInOpInt32{
			input:  input,
			colIdx: colIdx,
			negate: negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowInt32(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case types.Int64:
		obj := &selectInOpInt64{
			input:  input,
			colIdx: colIdx,
			negate: negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowInt64(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case types.Float32:
		obj := &selectInOpFloat32{
			input:  input,
			colIdx: colIdx,
			negate: negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowFloat32(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	case types.Float64:
		obj := &selectInOpFloat64{
			input:  input,
			colIdx: colIdx,
			negate: negate,
		}
		obj.filterRow, obj.hasNulls, err = fillDatumRowFloat64(ct, datumTuple)
		if err != nil {
			return nil, err
		}
		return obj, nil
	default:
		return nil, errors.Errorf("unhandled type: %s", t)
	}
}

type selectInOpBool struct {
	input     Operator
	colIdx    int
	filterRow []bool
	hasNulls  bool
	negate    bool
}

func fillDatumRowBool(ct *semtypes.T, datumTuple *tree.DTuple) ([]bool, bool, error) {
	conv := conv.GetDatumToPhysicalFn(ct)
	var result []bool
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw, err := conv(d)
			if err != nil {
				return nil, false, err
			}
			converted := convRaw.(bool)
			result = append(result, converted)
		}
	}
	return result, hasNulls, nil
}

func (si *selectInOpBool) cmpInBool(target bool) comparisonResult {
	for i := range si.filterRow {
		var cmp bool
		cmp = tree.CompareBools(target, si.filterRow[i]) == 0
		if cmp {
			return siTrue
		}
	}
	if si.hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpBool) Init() {
	si.input.Init()
}

func (si *selectInOpBool) Next(ctx context.Context) coldata.Batch {
	for {
		batch := si.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Bool()[:coldata.BatchSize]
		var idx uint16
		n := batch.Length()

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.HasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !nulls.NullAt(uint16(i)) && si.cmpInBool(col[i]) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					if !nulls.NullAt(uint16(i)) && si.cmpInBool(col[i]) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if si.cmpInBool(col[i]) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					if si.cmpInBool(col[i]) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

type selectInOpBytes struct {
	input     Operator
	colIdx    int
	filterRow [][]byte
	hasNulls  bool
	negate    bool
}

func fillDatumRowBytes(ct *semtypes.T, datumTuple *tree.DTuple) ([][]byte, bool, error) {
	conv := conv.GetDatumToPhysicalFn(ct)
	var result [][]byte
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw, err := conv(d)
			if err != nil {
				return nil, false, err
			}
			converted := convRaw.([]byte)
			result = append(result, converted)
		}
	}
	return result, hasNulls, nil
}

func (si *selectInOpBytes) cmpInBytes(target []byte) comparisonResult {
	for i := range si.filterRow {
		var cmp bool
		cmp = bytes.Compare(target, si.filterRow[i]) == 0
		if cmp {
			return siTrue
		}
	}
	if si.hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpBytes) Init() {
	si.input.Init()
}

func (si *selectInOpBytes) Next(ctx context.Context) coldata.Batch {
	for {
		batch := si.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Bytes()[:coldata.BatchSize]
		var idx uint16
		n := batch.Length()

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.HasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !nulls.NullAt(uint16(i)) && si.cmpInBytes(col[i]) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					if !nulls.NullAt(uint16(i)) && si.cmpInBytes(col[i]) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if si.cmpInBytes(col[i]) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					if si.cmpInBytes(col[i]) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

type selectInOpDecimal struct {
	input     Operator
	colIdx    int
	filterRow []apd.Decimal
	hasNulls  bool
	negate    bool
}

func fillDatumRowDecimal(ct *semtypes.T, datumTuple *tree.DTuple) ([]apd.Decimal, bool, error) {
	conv := conv.GetDatumToPhysicalFn(ct)
	var result []apd.Decimal
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw, err := conv(d)
			if err != nil {
				return nil, false, err
			}
			converted := convRaw.(apd.Decimal)
			result = append(result, converted)
		}
	}
	return result, hasNulls, nil
}

func (si *selectInOpDecimal) cmpInDecimal(target apd.Decimal) comparisonResult {
	for i := range si.filterRow {
		var cmp bool
		cmp = tree.CompareDecimals(&target, &si.filterRow[i]) == 0
		if cmp {
			return siTrue
		}
	}
	if si.hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpDecimal) Init() {
	si.input.Init()
}

func (si *selectInOpDecimal) Next(ctx context.Context) coldata.Batch {
	for {
		batch := si.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Decimal()[:coldata.BatchSize]
		var idx uint16
		n := batch.Length()

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.HasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !nulls.NullAt(uint16(i)) && si.cmpInDecimal(col[i]) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					if !nulls.NullAt(uint16(i)) && si.cmpInDecimal(col[i]) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if si.cmpInDecimal(col[i]) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					if si.cmpInDecimal(col[i]) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

type selectInOpInt8 struct {
	input     Operator
	colIdx    int
	filterRow []int8
	hasNulls  bool
	negate    bool
}

func fillDatumRowInt8(ct *semtypes.T, datumTuple *tree.DTuple) ([]int8, bool, error) {
	conv := conv.GetDatumToPhysicalFn(ct)
	var result []int8
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw, err := conv(d)
			if err != nil {
				return nil, false, err
			}
			converted := convRaw.(int8)
			result = append(result, converted)
		}
	}
	return result, hasNulls, nil
}

func (si *selectInOpInt8) cmpInInt8(target int8) comparisonResult {
	for i := range si.filterRow {
		var cmp bool
		cmp = target == si.filterRow[i]
		if cmp {
			return siTrue
		}
	}
	if si.hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpInt8) Init() {
	si.input.Init()
}

func (si *selectInOpInt8) Next(ctx context.Context) coldata.Batch {
	for {
		batch := si.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Int8()[:coldata.BatchSize]
		var idx uint16
		n := batch.Length()

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.HasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !nulls.NullAt(uint16(i)) && si.cmpInInt8(col[i]) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					if !nulls.NullAt(uint16(i)) && si.cmpInInt8(col[i]) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if si.cmpInInt8(col[i]) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					if si.cmpInInt8(col[i]) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

type selectInOpInt16 struct {
	input     Operator
	colIdx    int
	filterRow []int16
	hasNulls  bool
	negate    bool
}

func fillDatumRowInt16(ct *semtypes.T, datumTuple *tree.DTuple) ([]int16, bool, error) {
	conv := conv.GetDatumToPhysicalFn(ct)
	var result []int16
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw, err := conv(d)
			if err != nil {
				return nil, false, err
			}
			converted := convRaw.(int16)
			result = append(result, converted)
		}
	}
	return result, hasNulls, nil
}

func (si *selectInOpInt16) cmpInInt16(target int16) comparisonResult {
	for i := range si.filterRow {
		var cmp bool
		cmp = target == si.filterRow[i]
		if cmp {
			return siTrue
		}
	}
	if si.hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpInt16) Init() {
	si.input.Init()
}

func (si *selectInOpInt16) Next(ctx context.Context) coldata.Batch {
	for {
		batch := si.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Int16()[:coldata.BatchSize]
		var idx uint16
		n := batch.Length()

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.HasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !nulls.NullAt(uint16(i)) && si.cmpInInt16(col[i]) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					if !nulls.NullAt(uint16(i)) && si.cmpInInt16(col[i]) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if si.cmpInInt16(col[i]) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					if si.cmpInInt16(col[i]) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

type selectInOpInt32 struct {
	input     Operator
	colIdx    int
	filterRow []int32
	hasNulls  bool
	negate    bool
}

func fillDatumRowInt32(ct *semtypes.T, datumTuple *tree.DTuple) ([]int32, bool, error) {
	conv := conv.GetDatumToPhysicalFn(ct)
	var result []int32
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw, err := conv(d)
			if err != nil {
				return nil, false, err
			}
			converted := convRaw.(int32)
			result = append(result, converted)
		}
	}
	return result, hasNulls, nil
}

func (si *selectInOpInt32) cmpInInt32(target int32) comparisonResult {
	for i := range si.filterRow {
		var cmp bool
		cmp = target == si.filterRow[i]
		if cmp {
			return siTrue
		}
	}
	if si.hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpInt32) Init() {
	si.input.Init()
}

func (si *selectInOpInt32) Next(ctx context.Context) coldata.Batch {
	for {
		batch := si.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Int32()[:coldata.BatchSize]
		var idx uint16
		n := batch.Length()

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.HasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !nulls.NullAt(uint16(i)) && si.cmpInInt32(col[i]) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					if !nulls.NullAt(uint16(i)) && si.cmpInInt32(col[i]) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if si.cmpInInt32(col[i]) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					if si.cmpInInt32(col[i]) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

type selectInOpInt64 struct {
	input     Operator
	colIdx    int
	filterRow []int64
	hasNulls  bool
	negate    bool
}

func fillDatumRowInt64(ct *semtypes.T, datumTuple *tree.DTuple) ([]int64, bool, error) {
	conv := conv.GetDatumToPhysicalFn(ct)
	var result []int64
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw, err := conv(d)
			if err != nil {
				return nil, false, err
			}
			converted := convRaw.(int64)
			result = append(result, converted)
		}
	}
	return result, hasNulls, nil
}

func (si *selectInOpInt64) cmpInInt64(target int64) comparisonResult {
	for i := range si.filterRow {
		var cmp bool
		cmp = target == si.filterRow[i]
		if cmp {
			return siTrue
		}
	}
	if si.hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpInt64) Init() {
	si.input.Init()
}

func (si *selectInOpInt64) Next(ctx context.Context) coldata.Batch {
	for {
		batch := si.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Int64()[:coldata.BatchSize]
		var idx uint16
		n := batch.Length()

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.HasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !nulls.NullAt(uint16(i)) && si.cmpInInt64(col[i]) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					if !nulls.NullAt(uint16(i)) && si.cmpInInt64(col[i]) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if si.cmpInInt64(col[i]) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					if si.cmpInInt64(col[i]) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

type selectInOpFloat32 struct {
	input     Operator
	colIdx    int
	filterRow []float32
	hasNulls  bool
	negate    bool
}

func fillDatumRowFloat32(ct *semtypes.T, datumTuple *tree.DTuple) ([]float32, bool, error) {
	conv := conv.GetDatumToPhysicalFn(ct)
	var result []float32
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw, err := conv(d)
			if err != nil {
				return nil, false, err
			}
			converted := convRaw.(float32)
			result = append(result, converted)
		}
	}
	return result, hasNulls, nil
}

func (si *selectInOpFloat32) cmpInFloat32(target float32) comparisonResult {
	for i := range si.filterRow {
		var cmp bool
		cmp = target == si.filterRow[i]
		if cmp {
			return siTrue
		}
	}
	if si.hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpFloat32) Init() {
	si.input.Init()
}

func (si *selectInOpFloat32) Next(ctx context.Context) coldata.Batch {
	for {
		batch := si.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Float32()[:coldata.BatchSize]
		var idx uint16
		n := batch.Length()

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.HasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !nulls.NullAt(uint16(i)) && si.cmpInFloat32(col[i]) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					if !nulls.NullAt(uint16(i)) && si.cmpInFloat32(col[i]) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if si.cmpInFloat32(col[i]) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					if si.cmpInFloat32(col[i]) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}

type selectInOpFloat64 struct {
	input     Operator
	colIdx    int
	filterRow []float64
	hasNulls  bool
	negate    bool
}

func fillDatumRowFloat64(ct *semtypes.T, datumTuple *tree.DTuple) ([]float64, bool, error) {
	conv := conv.GetDatumToPhysicalFn(ct)
	var result []float64
	hasNulls := false
	for _, d := range datumTuple.D {
		if d == tree.DNull {
			hasNulls = true
		} else {
			convRaw, err := conv(d)
			if err != nil {
				return nil, false, err
			}
			converted := convRaw.(float64)
			result = append(result, converted)
		}
	}
	return result, hasNulls, nil
}

func (si *selectInOpFloat64) cmpInFloat64(target float64) comparisonResult {
	for i := range si.filterRow {
		var cmp bool
		cmp = target == si.filterRow[i]
		if cmp {
			return siTrue
		}
	}
	if si.hasNulls {
		return siNull
	} else {
		return siFalse
	}
}

func (si *selectInOpFloat64) Init() {
	si.input.Init()
}

func (si *selectInOpFloat64) Next(ctx context.Context) coldata.Batch {
	for {
		batch := si.input.Next(ctx)
		if batch.Length() == 0 {
			return batch
		}

		vec := batch.ColVec(si.colIdx)
		col := vec.Float64()[:coldata.BatchSize]
		var idx uint16
		n := batch.Length()

		compVal := siTrue
		if si.negate {
			compVal = siFalse
		}

		if vec.HasNulls() {
			nulls := vec.Nulls()
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if !nulls.NullAt(uint16(i)) && si.cmpInFloat64(col[i]) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					if !nulls.NullAt(uint16(i)) && si.cmpInFloat64(col[i]) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		} else {
			if sel := batch.Selection(); sel != nil {
				sel = sel[:n]
				for _, i := range sel {
					if si.cmpInFloat64(col[i]) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			} else {
				batch.SetSelection(true)
				sel := batch.Selection()
				col = col[:n]
				for i := range col {
					if si.cmpInFloat64(col[i]) == compVal {
						sel[idx] = uint16(i)
						idx++
					}
				}
			}
		}

		if idx > 0 {
			batch.SetLength(idx)
			return batch
		}
	}
}
