// Code generated by execgen; DO NOT EDIT.
// Copyright 2018 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package exec

import (
	"bytes"
	"context"
	"fmt"

	"github.com/cockroachdb/apd"
	"github.com/cockroachdb/cockroach/pkg/col/coldata"
	"github.com/cockroachdb/cockroach/pkg/col/coltypes"
	"github.com/cockroachdb/cockroach/pkg/sql/distsqlpb"
	"github.com/cockroachdb/cockroach/pkg/sql/exec/execerror"
	"github.com/cockroachdb/cockroach/pkg/sql/exec/execgen"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
)

// Use execgen package to remove unused import warning.
var _ interface{} = execgen.GET

func isSorterSupported(t coltypes.T, dir distsqlpb.Ordering_Column_Direction) bool {
	switch t {
	case coltypes.Bool:
		switch dir {
		case distsqlpb.Ordering_Column_ASC:
			return true
		case distsqlpb.Ordering_Column_DESC:
			return true
		default:
			return false
		}
	case coltypes.Bytes:
		switch dir {
		case distsqlpb.Ordering_Column_ASC:
			return true
		case distsqlpb.Ordering_Column_DESC:
			return true
		default:
			return false
		}
	case coltypes.Decimal:
		switch dir {
		case distsqlpb.Ordering_Column_ASC:
			return true
		case distsqlpb.Ordering_Column_DESC:
			return true
		default:
			return false
		}
	case coltypes.Int8:
		switch dir {
		case distsqlpb.Ordering_Column_ASC:
			return true
		case distsqlpb.Ordering_Column_DESC:
			return true
		default:
			return false
		}
	case coltypes.Int16:
		switch dir {
		case distsqlpb.Ordering_Column_ASC:
			return true
		case distsqlpb.Ordering_Column_DESC:
			return true
		default:
			return false
		}
	case coltypes.Int32:
		switch dir {
		case distsqlpb.Ordering_Column_ASC:
			return true
		case distsqlpb.Ordering_Column_DESC:
			return true
		default:
			return false
		}
	case coltypes.Int64:
		switch dir {
		case distsqlpb.Ordering_Column_ASC:
			return true
		case distsqlpb.Ordering_Column_DESC:
			return true
		default:
			return false
		}
	case coltypes.Float32:
		switch dir {
		case distsqlpb.Ordering_Column_ASC:
			return true
		case distsqlpb.Ordering_Column_DESC:
			return true
		default:
			return false
		}
	case coltypes.Float64:
		switch dir {
		case distsqlpb.Ordering_Column_ASC:
			return true
		case distsqlpb.Ordering_Column_DESC:
			return true
		default:
			return false
		}
	default:
		return false
	}
}

func newSingleSorter(
	t coltypes.T, dir distsqlpb.Ordering_Column_Direction, hasNulls bool,
) colSorter {
	switch t {
	case coltypes.Bool:
		switch hasNulls {
		case false:
			switch dir {
			case distsqlpb.Ordering_Column_ASC:
				return &sortBoolAscOp{}
			case distsqlpb.Ordering_Column_DESC:
				return &sortBoolDescOp{}
			default:
				execerror.VectorizedInternalPanic("nulls switch failed")
			}
		case true:
			switch dir {
			case distsqlpb.Ordering_Column_ASC:
				return &sortBoolAscWithNullsOp{}
			case distsqlpb.Ordering_Column_DESC:
				return &sortBoolDescWithNullsOp{}
			default:
				execerror.VectorizedInternalPanic("nulls switch failed")
			}
		default:
			execerror.VectorizedInternalPanic("nulls switch failed")
		}
	case coltypes.Bytes:
		switch hasNulls {
		case false:
			switch dir {
			case distsqlpb.Ordering_Column_ASC:
				return &sortBytesAscOp{}
			case distsqlpb.Ordering_Column_DESC:
				return &sortBytesDescOp{}
			default:
				execerror.VectorizedInternalPanic("nulls switch failed")
			}
		case true:
			switch dir {
			case distsqlpb.Ordering_Column_ASC:
				return &sortBytesAscWithNullsOp{}
			case distsqlpb.Ordering_Column_DESC:
				return &sortBytesDescWithNullsOp{}
			default:
				execerror.VectorizedInternalPanic("nulls switch failed")
			}
		default:
			execerror.VectorizedInternalPanic("nulls switch failed")
		}
	case coltypes.Decimal:
		switch hasNulls {
		case false:
			switch dir {
			case distsqlpb.Ordering_Column_ASC:
				return &sortDecimalAscOp{}
			case distsqlpb.Ordering_Column_DESC:
				return &sortDecimalDescOp{}
			default:
				execerror.VectorizedInternalPanic("nulls switch failed")
			}
		case true:
			switch dir {
			case distsqlpb.Ordering_Column_ASC:
				return &sortDecimalAscWithNullsOp{}
			case distsqlpb.Ordering_Column_DESC:
				return &sortDecimalDescWithNullsOp{}
			default:
				execerror.VectorizedInternalPanic("nulls switch failed")
			}
		default:
			execerror.VectorizedInternalPanic("nulls switch failed")
		}
	case coltypes.Int8:
		switch hasNulls {
		case false:
			switch dir {
			case distsqlpb.Ordering_Column_ASC:
				return &sortInt8AscOp{}
			case distsqlpb.Ordering_Column_DESC:
				return &sortInt8DescOp{}
			default:
				execerror.VectorizedInternalPanic("nulls switch failed")
			}
		case true:
			switch dir {
			case distsqlpb.Ordering_Column_ASC:
				return &sortInt8AscWithNullsOp{}
			case distsqlpb.Ordering_Column_DESC:
				return &sortInt8DescWithNullsOp{}
			default:
				execerror.VectorizedInternalPanic("nulls switch failed")
			}
		default:
			execerror.VectorizedInternalPanic("nulls switch failed")
		}
	case coltypes.Int16:
		switch hasNulls {
		case false:
			switch dir {
			case distsqlpb.Ordering_Column_ASC:
				return &sortInt16AscOp{}
			case distsqlpb.Ordering_Column_DESC:
				return &sortInt16DescOp{}
			default:
				execerror.VectorizedInternalPanic("nulls switch failed")
			}
		case true:
			switch dir {
			case distsqlpb.Ordering_Column_ASC:
				return &sortInt16AscWithNullsOp{}
			case distsqlpb.Ordering_Column_DESC:
				return &sortInt16DescWithNullsOp{}
			default:
				execerror.VectorizedInternalPanic("nulls switch failed")
			}
		default:
			execerror.VectorizedInternalPanic("nulls switch failed")
		}
	case coltypes.Int32:
		switch hasNulls {
		case false:
			switch dir {
			case distsqlpb.Ordering_Column_ASC:
				return &sortInt32AscOp{}
			case distsqlpb.Ordering_Column_DESC:
				return &sortInt32DescOp{}
			default:
				execerror.VectorizedInternalPanic("nulls switch failed")
			}
		case true:
			switch dir {
			case distsqlpb.Ordering_Column_ASC:
				return &sortInt32AscWithNullsOp{}
			case distsqlpb.Ordering_Column_DESC:
				return &sortInt32DescWithNullsOp{}
			default:
				execerror.VectorizedInternalPanic("nulls switch failed")
			}
		default:
			execerror.VectorizedInternalPanic("nulls switch failed")
		}
	case coltypes.Int64:
		switch hasNulls {
		case false:
			switch dir {
			case distsqlpb.Ordering_Column_ASC:
				return &sortInt64AscOp{}
			case distsqlpb.Ordering_Column_DESC:
				return &sortInt64DescOp{}
			default:
				execerror.VectorizedInternalPanic("nulls switch failed")
			}
		case true:
			switch dir {
			case distsqlpb.Ordering_Column_ASC:
				return &sortInt64AscWithNullsOp{}
			case distsqlpb.Ordering_Column_DESC:
				return &sortInt64DescWithNullsOp{}
			default:
				execerror.VectorizedInternalPanic("nulls switch failed")
			}
		default:
			execerror.VectorizedInternalPanic("nulls switch failed")
		}
	case coltypes.Float32:
		switch hasNulls {
		case false:
			switch dir {
			case distsqlpb.Ordering_Column_ASC:
				return &sortFloat32AscOp{}
			case distsqlpb.Ordering_Column_DESC:
				return &sortFloat32DescOp{}
			default:
				execerror.VectorizedInternalPanic("nulls switch failed")
			}
		case true:
			switch dir {
			case distsqlpb.Ordering_Column_ASC:
				return &sortFloat32AscWithNullsOp{}
			case distsqlpb.Ordering_Column_DESC:
				return &sortFloat32DescWithNullsOp{}
			default:
				execerror.VectorizedInternalPanic("nulls switch failed")
			}
		default:
			execerror.VectorizedInternalPanic("nulls switch failed")
		}
	case coltypes.Float64:
		switch hasNulls {
		case false:
			switch dir {
			case distsqlpb.Ordering_Column_ASC:
				return &sortFloat64AscOp{}
			case distsqlpb.Ordering_Column_DESC:
				return &sortFloat64DescOp{}
			default:
				execerror.VectorizedInternalPanic("nulls switch failed")
			}
		case true:
			switch dir {
			case distsqlpb.Ordering_Column_ASC:
				return &sortFloat64AscWithNullsOp{}
			case distsqlpb.Ordering_Column_DESC:
				return &sortFloat64DescWithNullsOp{}
			default:
				execerror.VectorizedInternalPanic("nulls switch failed")
			}
		default:
			execerror.VectorizedInternalPanic("nulls switch failed")
		}
	default:
		execerror.VectorizedInternalPanic("nulls switch failed")
	}
	// This code is unreachable, but the compiler cannot infer that.
	return nil
}

type sortBoolAscOp struct {
	sortCol       []bool
	nulls         *coldata.Nulls
	order         []uint64
	cancelChecker CancelChecker
}

func (s *sortBoolAscOp) init(col coldata.Vec, order []uint64) {
	s.sortCol = col.Bool()
	s.nulls = col.Nulls()
	s.order = order
}

func (s *sortBoolAscOp) sort(ctx context.Context) {
	n := len(s.sortCol)
	s.quickSort(ctx, 0, n, maxDepth(n))
}

func (s *sortBoolAscOp) sortPartitions(ctx context.Context, partitions []uint64) {
	if len(partitions) < 1 {
		execerror.VectorizedInternalPanic(fmt.Sprintf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd uint64
		if i == len(partitions)-1 {
			partitionEnd = uint64(len(order))
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := int(partitionEnd - partitionStart)
		s.quickSort(ctx, 0, n, maxDepth(n))
	}
}

func (s *sortBoolAscOp) Less(i, j int) bool {
	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol[int(s.order[i])]
	arg2 := s.sortCol[int(s.order[j])]
	lt = tree.CompareBools(arg1, arg2) < 0
	return lt
}

func (s *sortBoolAscOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortBoolAscOp) Len() int {
	return len(s.order)
}

type sortBoolDescOp struct {
	sortCol       []bool
	nulls         *coldata.Nulls
	order         []uint64
	cancelChecker CancelChecker
}

func (s *sortBoolDescOp) init(col coldata.Vec, order []uint64) {
	s.sortCol = col.Bool()
	s.nulls = col.Nulls()
	s.order = order
}

func (s *sortBoolDescOp) sort(ctx context.Context) {
	n := len(s.sortCol)
	s.quickSort(ctx, 0, n, maxDepth(n))
}

func (s *sortBoolDescOp) sortPartitions(ctx context.Context, partitions []uint64) {
	if len(partitions) < 1 {
		execerror.VectorizedInternalPanic(fmt.Sprintf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd uint64
		if i == len(partitions)-1 {
			partitionEnd = uint64(len(order))
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := int(partitionEnd - partitionStart)
		s.quickSort(ctx, 0, n, maxDepth(n))
	}
}

func (s *sortBoolDescOp) Less(i, j int) bool {
	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol[int(s.order[i])]
	arg2 := s.sortCol[int(s.order[j])]
	lt = tree.CompareBools(arg1, arg2) > 0
	return lt
}

func (s *sortBoolDescOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortBoolDescOp) Len() int {
	return len(s.order)
}

type sortBoolAscWithNullsOp struct {
	sortCol       []bool
	nulls         *coldata.Nulls
	order         []uint64
	cancelChecker CancelChecker
}

func (s *sortBoolAscWithNullsOp) init(col coldata.Vec, order []uint64) {
	s.sortCol = col.Bool()
	s.nulls = col.Nulls()
	s.order = order
}

func (s *sortBoolAscWithNullsOp) sort(ctx context.Context) {
	n := len(s.sortCol)
	s.quickSort(ctx, 0, n, maxDepth(n))
}

func (s *sortBoolAscWithNullsOp) sortPartitions(ctx context.Context, partitions []uint64) {
	if len(partitions) < 1 {
		execerror.VectorizedInternalPanic(fmt.Sprintf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd uint64
		if i == len(partitions)-1 {
			partitionEnd = uint64(len(order))
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := int(partitionEnd - partitionStart)
		s.quickSort(ctx, 0, n, maxDepth(n))
	}
}

func (s *sortBoolAscWithNullsOp) Less(i, j int) bool {
	n1 := s.nulls.MaybeHasNulls() && s.nulls.NullAt64(s.order[i])
	n2 := s.nulls.MaybeHasNulls() && s.nulls.NullAt64(s.order[j])
	// If ascending, nulls always sort first, so we encode that logic here.
	if n1 && n2 {
		return false
	} else if n1 {
		return true
	} else if n2 {
		return false
	}
	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol[int(s.order[i])]
	arg2 := s.sortCol[int(s.order[j])]
	lt = tree.CompareBools(arg1, arg2) < 0
	return lt
}

func (s *sortBoolAscWithNullsOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortBoolAscWithNullsOp) Len() int {
	return len(s.order)
}

type sortBoolDescWithNullsOp struct {
	sortCol       []bool
	nulls         *coldata.Nulls
	order         []uint64
	cancelChecker CancelChecker
}

func (s *sortBoolDescWithNullsOp) init(col coldata.Vec, order []uint64) {
	s.sortCol = col.Bool()
	s.nulls = col.Nulls()
	s.order = order
}

func (s *sortBoolDescWithNullsOp) sort(ctx context.Context) {
	n := len(s.sortCol)
	s.quickSort(ctx, 0, n, maxDepth(n))
}

func (s *sortBoolDescWithNullsOp) sortPartitions(ctx context.Context, partitions []uint64) {
	if len(partitions) < 1 {
		execerror.VectorizedInternalPanic(fmt.Sprintf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd uint64
		if i == len(partitions)-1 {
			partitionEnd = uint64(len(order))
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := int(partitionEnd - partitionStart)
		s.quickSort(ctx, 0, n, maxDepth(n))
	}
}

func (s *sortBoolDescWithNullsOp) Less(i, j int) bool {
	n1 := s.nulls.MaybeHasNulls() && s.nulls.NullAt64(s.order[i])
	n2 := s.nulls.MaybeHasNulls() && s.nulls.NullAt64(s.order[j])
	// If descending, nulls always sort last, so we encode that logic here.
	if n1 && n2 {
		return false
	} else if n1 {
		return false
	} else if n2 {
		return true
	}
	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol[int(s.order[i])]
	arg2 := s.sortCol[int(s.order[j])]
	lt = tree.CompareBools(arg1, arg2) > 0
	return lt
}

func (s *sortBoolDescWithNullsOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortBoolDescWithNullsOp) Len() int {
	return len(s.order)
}

type sortBytesAscOp struct {
	sortCol       *coldata.Bytes
	nulls         *coldata.Nulls
	order         []uint64
	cancelChecker CancelChecker
}

func (s *sortBytesAscOp) init(col coldata.Vec, order []uint64) {
	s.sortCol = col.Bytes()
	s.nulls = col.Nulls()
	s.order = order
}

func (s *sortBytesAscOp) sort(ctx context.Context) {
	n := s.sortCol.Len()
	s.quickSort(ctx, 0, n, maxDepth(n))
}

func (s *sortBytesAscOp) sortPartitions(ctx context.Context, partitions []uint64) {
	if len(partitions) < 1 {
		execerror.VectorizedInternalPanic(fmt.Sprintf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd uint64
		if i == len(partitions)-1 {
			partitionEnd = uint64(len(order))
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := int(partitionEnd - partitionStart)
		s.quickSort(ctx, 0, n, maxDepth(n))
	}
}

func (s *sortBytesAscOp) Less(i, j int) bool {
	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(int(s.order[i]))
	arg2 := s.sortCol.Get(int(s.order[j]))
	lt = bytes.Compare(arg1, arg2) < 0
	return lt
}

func (s *sortBytesAscOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortBytesAscOp) Len() int {
	return len(s.order)
}

type sortBytesDescOp struct {
	sortCol       *coldata.Bytes
	nulls         *coldata.Nulls
	order         []uint64
	cancelChecker CancelChecker
}

func (s *sortBytesDescOp) init(col coldata.Vec, order []uint64) {
	s.sortCol = col.Bytes()
	s.nulls = col.Nulls()
	s.order = order
}

func (s *sortBytesDescOp) sort(ctx context.Context) {
	n := s.sortCol.Len()
	s.quickSort(ctx, 0, n, maxDepth(n))
}

func (s *sortBytesDescOp) sortPartitions(ctx context.Context, partitions []uint64) {
	if len(partitions) < 1 {
		execerror.VectorizedInternalPanic(fmt.Sprintf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd uint64
		if i == len(partitions)-1 {
			partitionEnd = uint64(len(order))
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := int(partitionEnd - partitionStart)
		s.quickSort(ctx, 0, n, maxDepth(n))
	}
}

func (s *sortBytesDescOp) Less(i, j int) bool {
	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(int(s.order[i]))
	arg2 := s.sortCol.Get(int(s.order[j]))
	lt = bytes.Compare(arg1, arg2) > 0
	return lt
}

func (s *sortBytesDescOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortBytesDescOp) Len() int {
	return len(s.order)
}

type sortBytesAscWithNullsOp struct {
	sortCol       *coldata.Bytes
	nulls         *coldata.Nulls
	order         []uint64
	cancelChecker CancelChecker
}

func (s *sortBytesAscWithNullsOp) init(col coldata.Vec, order []uint64) {
	s.sortCol = col.Bytes()
	s.nulls = col.Nulls()
	s.order = order
}

func (s *sortBytesAscWithNullsOp) sort(ctx context.Context) {
	n := s.sortCol.Len()
	s.quickSort(ctx, 0, n, maxDepth(n))
}

func (s *sortBytesAscWithNullsOp) sortPartitions(ctx context.Context, partitions []uint64) {
	if len(partitions) < 1 {
		execerror.VectorizedInternalPanic(fmt.Sprintf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd uint64
		if i == len(partitions)-1 {
			partitionEnd = uint64(len(order))
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := int(partitionEnd - partitionStart)
		s.quickSort(ctx, 0, n, maxDepth(n))
	}
}

func (s *sortBytesAscWithNullsOp) Less(i, j int) bool {
	n1 := s.nulls.MaybeHasNulls() && s.nulls.NullAt64(s.order[i])
	n2 := s.nulls.MaybeHasNulls() && s.nulls.NullAt64(s.order[j])
	// If ascending, nulls always sort first, so we encode that logic here.
	if n1 && n2 {
		return false
	} else if n1 {
		return true
	} else if n2 {
		return false
	}
	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(int(s.order[i]))
	arg2 := s.sortCol.Get(int(s.order[j]))
	lt = bytes.Compare(arg1, arg2) < 0
	return lt
}

func (s *sortBytesAscWithNullsOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortBytesAscWithNullsOp) Len() int {
	return len(s.order)
}

type sortBytesDescWithNullsOp struct {
	sortCol       *coldata.Bytes
	nulls         *coldata.Nulls
	order         []uint64
	cancelChecker CancelChecker
}

func (s *sortBytesDescWithNullsOp) init(col coldata.Vec, order []uint64) {
	s.sortCol = col.Bytes()
	s.nulls = col.Nulls()
	s.order = order
}

func (s *sortBytesDescWithNullsOp) sort(ctx context.Context) {
	n := s.sortCol.Len()
	s.quickSort(ctx, 0, n, maxDepth(n))
}

func (s *sortBytesDescWithNullsOp) sortPartitions(ctx context.Context, partitions []uint64) {
	if len(partitions) < 1 {
		execerror.VectorizedInternalPanic(fmt.Sprintf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd uint64
		if i == len(partitions)-1 {
			partitionEnd = uint64(len(order))
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := int(partitionEnd - partitionStart)
		s.quickSort(ctx, 0, n, maxDepth(n))
	}
}

func (s *sortBytesDescWithNullsOp) Less(i, j int) bool {
	n1 := s.nulls.MaybeHasNulls() && s.nulls.NullAt64(s.order[i])
	n2 := s.nulls.MaybeHasNulls() && s.nulls.NullAt64(s.order[j])
	// If descending, nulls always sort last, so we encode that logic here.
	if n1 && n2 {
		return false
	} else if n1 {
		return false
	} else if n2 {
		return true
	}
	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol.Get(int(s.order[i]))
	arg2 := s.sortCol.Get(int(s.order[j]))
	lt = bytes.Compare(arg1, arg2) > 0
	return lt
}

func (s *sortBytesDescWithNullsOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortBytesDescWithNullsOp) Len() int {
	return len(s.order)
}

type sortDecimalAscOp struct {
	sortCol       []apd.Decimal
	nulls         *coldata.Nulls
	order         []uint64
	cancelChecker CancelChecker
}

func (s *sortDecimalAscOp) init(col coldata.Vec, order []uint64) {
	s.sortCol = col.Decimal()
	s.nulls = col.Nulls()
	s.order = order
}

func (s *sortDecimalAscOp) sort(ctx context.Context) {
	n := len(s.sortCol)
	s.quickSort(ctx, 0, n, maxDepth(n))
}

func (s *sortDecimalAscOp) sortPartitions(ctx context.Context, partitions []uint64) {
	if len(partitions) < 1 {
		execerror.VectorizedInternalPanic(fmt.Sprintf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd uint64
		if i == len(partitions)-1 {
			partitionEnd = uint64(len(order))
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := int(partitionEnd - partitionStart)
		s.quickSort(ctx, 0, n, maxDepth(n))
	}
}

func (s *sortDecimalAscOp) Less(i, j int) bool {
	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol[int(s.order[i])]
	arg2 := s.sortCol[int(s.order[j])]
	lt = tree.CompareDecimals(&arg1, &arg2) < 0
	return lt
}

func (s *sortDecimalAscOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortDecimalAscOp) Len() int {
	return len(s.order)
}

type sortDecimalDescOp struct {
	sortCol       []apd.Decimal
	nulls         *coldata.Nulls
	order         []uint64
	cancelChecker CancelChecker
}

func (s *sortDecimalDescOp) init(col coldata.Vec, order []uint64) {
	s.sortCol = col.Decimal()
	s.nulls = col.Nulls()
	s.order = order
}

func (s *sortDecimalDescOp) sort(ctx context.Context) {
	n := len(s.sortCol)
	s.quickSort(ctx, 0, n, maxDepth(n))
}

func (s *sortDecimalDescOp) sortPartitions(ctx context.Context, partitions []uint64) {
	if len(partitions) < 1 {
		execerror.VectorizedInternalPanic(fmt.Sprintf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd uint64
		if i == len(partitions)-1 {
			partitionEnd = uint64(len(order))
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := int(partitionEnd - partitionStart)
		s.quickSort(ctx, 0, n, maxDepth(n))
	}
}

func (s *sortDecimalDescOp) Less(i, j int) bool {
	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol[int(s.order[i])]
	arg2 := s.sortCol[int(s.order[j])]
	lt = tree.CompareDecimals(&arg1, &arg2) > 0
	return lt
}

func (s *sortDecimalDescOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortDecimalDescOp) Len() int {
	return len(s.order)
}

type sortDecimalAscWithNullsOp struct {
	sortCol       []apd.Decimal
	nulls         *coldata.Nulls
	order         []uint64
	cancelChecker CancelChecker
}

func (s *sortDecimalAscWithNullsOp) init(col coldata.Vec, order []uint64) {
	s.sortCol = col.Decimal()
	s.nulls = col.Nulls()
	s.order = order
}

func (s *sortDecimalAscWithNullsOp) sort(ctx context.Context) {
	n := len(s.sortCol)
	s.quickSort(ctx, 0, n, maxDepth(n))
}

func (s *sortDecimalAscWithNullsOp) sortPartitions(ctx context.Context, partitions []uint64) {
	if len(partitions) < 1 {
		execerror.VectorizedInternalPanic(fmt.Sprintf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd uint64
		if i == len(partitions)-1 {
			partitionEnd = uint64(len(order))
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := int(partitionEnd - partitionStart)
		s.quickSort(ctx, 0, n, maxDepth(n))
	}
}

func (s *sortDecimalAscWithNullsOp) Less(i, j int) bool {
	n1 := s.nulls.MaybeHasNulls() && s.nulls.NullAt64(s.order[i])
	n2 := s.nulls.MaybeHasNulls() && s.nulls.NullAt64(s.order[j])
	// If ascending, nulls always sort first, so we encode that logic here.
	if n1 && n2 {
		return false
	} else if n1 {
		return true
	} else if n2 {
		return false
	}
	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol[int(s.order[i])]
	arg2 := s.sortCol[int(s.order[j])]
	lt = tree.CompareDecimals(&arg1, &arg2) < 0
	return lt
}

func (s *sortDecimalAscWithNullsOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortDecimalAscWithNullsOp) Len() int {
	return len(s.order)
}

type sortDecimalDescWithNullsOp struct {
	sortCol       []apd.Decimal
	nulls         *coldata.Nulls
	order         []uint64
	cancelChecker CancelChecker
}

func (s *sortDecimalDescWithNullsOp) init(col coldata.Vec, order []uint64) {
	s.sortCol = col.Decimal()
	s.nulls = col.Nulls()
	s.order = order
}

func (s *sortDecimalDescWithNullsOp) sort(ctx context.Context) {
	n := len(s.sortCol)
	s.quickSort(ctx, 0, n, maxDepth(n))
}

func (s *sortDecimalDescWithNullsOp) sortPartitions(ctx context.Context, partitions []uint64) {
	if len(partitions) < 1 {
		execerror.VectorizedInternalPanic(fmt.Sprintf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd uint64
		if i == len(partitions)-1 {
			partitionEnd = uint64(len(order))
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := int(partitionEnd - partitionStart)
		s.quickSort(ctx, 0, n, maxDepth(n))
	}
}

func (s *sortDecimalDescWithNullsOp) Less(i, j int) bool {
	n1 := s.nulls.MaybeHasNulls() && s.nulls.NullAt64(s.order[i])
	n2 := s.nulls.MaybeHasNulls() && s.nulls.NullAt64(s.order[j])
	// If descending, nulls always sort last, so we encode that logic here.
	if n1 && n2 {
		return false
	} else if n1 {
		return false
	} else if n2 {
		return true
	}
	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol[int(s.order[i])]
	arg2 := s.sortCol[int(s.order[j])]
	lt = tree.CompareDecimals(&arg1, &arg2) > 0
	return lt
}

func (s *sortDecimalDescWithNullsOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortDecimalDescWithNullsOp) Len() int {
	return len(s.order)
}

type sortInt8AscOp struct {
	sortCol       []int8
	nulls         *coldata.Nulls
	order         []uint64
	cancelChecker CancelChecker
}

func (s *sortInt8AscOp) init(col coldata.Vec, order []uint64) {
	s.sortCol = col.Int8()
	s.nulls = col.Nulls()
	s.order = order
}

func (s *sortInt8AscOp) sort(ctx context.Context) {
	n := len(s.sortCol)
	s.quickSort(ctx, 0, n, maxDepth(n))
}

func (s *sortInt8AscOp) sortPartitions(ctx context.Context, partitions []uint64) {
	if len(partitions) < 1 {
		execerror.VectorizedInternalPanic(fmt.Sprintf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd uint64
		if i == len(partitions)-1 {
			partitionEnd = uint64(len(order))
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := int(partitionEnd - partitionStart)
		s.quickSort(ctx, 0, n, maxDepth(n))
	}
}

func (s *sortInt8AscOp) Less(i, j int) bool {
	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol[int(s.order[i])]
	arg2 := s.sortCol[int(s.order[j])]
	lt = arg1 < arg2
	return lt
}

func (s *sortInt8AscOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortInt8AscOp) Len() int {
	return len(s.order)
}

type sortInt8DescOp struct {
	sortCol       []int8
	nulls         *coldata.Nulls
	order         []uint64
	cancelChecker CancelChecker
}

func (s *sortInt8DescOp) init(col coldata.Vec, order []uint64) {
	s.sortCol = col.Int8()
	s.nulls = col.Nulls()
	s.order = order
}

func (s *sortInt8DescOp) sort(ctx context.Context) {
	n := len(s.sortCol)
	s.quickSort(ctx, 0, n, maxDepth(n))
}

func (s *sortInt8DescOp) sortPartitions(ctx context.Context, partitions []uint64) {
	if len(partitions) < 1 {
		execerror.VectorizedInternalPanic(fmt.Sprintf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd uint64
		if i == len(partitions)-1 {
			partitionEnd = uint64(len(order))
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := int(partitionEnd - partitionStart)
		s.quickSort(ctx, 0, n, maxDepth(n))
	}
}

func (s *sortInt8DescOp) Less(i, j int) bool {
	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol[int(s.order[i])]
	arg2 := s.sortCol[int(s.order[j])]
	lt = arg1 > arg2
	return lt
}

func (s *sortInt8DescOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortInt8DescOp) Len() int {
	return len(s.order)
}

type sortInt8AscWithNullsOp struct {
	sortCol       []int8
	nulls         *coldata.Nulls
	order         []uint64
	cancelChecker CancelChecker
}

func (s *sortInt8AscWithNullsOp) init(col coldata.Vec, order []uint64) {
	s.sortCol = col.Int8()
	s.nulls = col.Nulls()
	s.order = order
}

func (s *sortInt8AscWithNullsOp) sort(ctx context.Context) {
	n := len(s.sortCol)
	s.quickSort(ctx, 0, n, maxDepth(n))
}

func (s *sortInt8AscWithNullsOp) sortPartitions(ctx context.Context, partitions []uint64) {
	if len(partitions) < 1 {
		execerror.VectorizedInternalPanic(fmt.Sprintf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd uint64
		if i == len(partitions)-1 {
			partitionEnd = uint64(len(order))
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := int(partitionEnd - partitionStart)
		s.quickSort(ctx, 0, n, maxDepth(n))
	}
}

func (s *sortInt8AscWithNullsOp) Less(i, j int) bool {
	n1 := s.nulls.MaybeHasNulls() && s.nulls.NullAt64(s.order[i])
	n2 := s.nulls.MaybeHasNulls() && s.nulls.NullAt64(s.order[j])
	// If ascending, nulls always sort first, so we encode that logic here.
	if n1 && n2 {
		return false
	} else if n1 {
		return true
	} else if n2 {
		return false
	}
	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol[int(s.order[i])]
	arg2 := s.sortCol[int(s.order[j])]
	lt = arg1 < arg2
	return lt
}

func (s *sortInt8AscWithNullsOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortInt8AscWithNullsOp) Len() int {
	return len(s.order)
}

type sortInt8DescWithNullsOp struct {
	sortCol       []int8
	nulls         *coldata.Nulls
	order         []uint64
	cancelChecker CancelChecker
}

func (s *sortInt8DescWithNullsOp) init(col coldata.Vec, order []uint64) {
	s.sortCol = col.Int8()
	s.nulls = col.Nulls()
	s.order = order
}

func (s *sortInt8DescWithNullsOp) sort(ctx context.Context) {
	n := len(s.sortCol)
	s.quickSort(ctx, 0, n, maxDepth(n))
}

func (s *sortInt8DescWithNullsOp) sortPartitions(ctx context.Context, partitions []uint64) {
	if len(partitions) < 1 {
		execerror.VectorizedInternalPanic(fmt.Sprintf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd uint64
		if i == len(partitions)-1 {
			partitionEnd = uint64(len(order))
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := int(partitionEnd - partitionStart)
		s.quickSort(ctx, 0, n, maxDepth(n))
	}
}

func (s *sortInt8DescWithNullsOp) Less(i, j int) bool {
	n1 := s.nulls.MaybeHasNulls() && s.nulls.NullAt64(s.order[i])
	n2 := s.nulls.MaybeHasNulls() && s.nulls.NullAt64(s.order[j])
	// If descending, nulls always sort last, so we encode that logic here.
	if n1 && n2 {
		return false
	} else if n1 {
		return false
	} else if n2 {
		return true
	}
	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol[int(s.order[i])]
	arg2 := s.sortCol[int(s.order[j])]
	lt = arg1 > arg2
	return lt
}

func (s *sortInt8DescWithNullsOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortInt8DescWithNullsOp) Len() int {
	return len(s.order)
}

type sortInt16AscOp struct {
	sortCol       []int16
	nulls         *coldata.Nulls
	order         []uint64
	cancelChecker CancelChecker
}

func (s *sortInt16AscOp) init(col coldata.Vec, order []uint64) {
	s.sortCol = col.Int16()
	s.nulls = col.Nulls()
	s.order = order
}

func (s *sortInt16AscOp) sort(ctx context.Context) {
	n := len(s.sortCol)
	s.quickSort(ctx, 0, n, maxDepth(n))
}

func (s *sortInt16AscOp) sortPartitions(ctx context.Context, partitions []uint64) {
	if len(partitions) < 1 {
		execerror.VectorizedInternalPanic(fmt.Sprintf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd uint64
		if i == len(partitions)-1 {
			partitionEnd = uint64(len(order))
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := int(partitionEnd - partitionStart)
		s.quickSort(ctx, 0, n, maxDepth(n))
	}
}

func (s *sortInt16AscOp) Less(i, j int) bool {
	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol[int(s.order[i])]
	arg2 := s.sortCol[int(s.order[j])]
	lt = arg1 < arg2
	return lt
}

func (s *sortInt16AscOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortInt16AscOp) Len() int {
	return len(s.order)
}

type sortInt16DescOp struct {
	sortCol       []int16
	nulls         *coldata.Nulls
	order         []uint64
	cancelChecker CancelChecker
}

func (s *sortInt16DescOp) init(col coldata.Vec, order []uint64) {
	s.sortCol = col.Int16()
	s.nulls = col.Nulls()
	s.order = order
}

func (s *sortInt16DescOp) sort(ctx context.Context) {
	n := len(s.sortCol)
	s.quickSort(ctx, 0, n, maxDepth(n))
}

func (s *sortInt16DescOp) sortPartitions(ctx context.Context, partitions []uint64) {
	if len(partitions) < 1 {
		execerror.VectorizedInternalPanic(fmt.Sprintf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd uint64
		if i == len(partitions)-1 {
			partitionEnd = uint64(len(order))
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := int(partitionEnd - partitionStart)
		s.quickSort(ctx, 0, n, maxDepth(n))
	}
}

func (s *sortInt16DescOp) Less(i, j int) bool {
	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol[int(s.order[i])]
	arg2 := s.sortCol[int(s.order[j])]
	lt = arg1 > arg2
	return lt
}

func (s *sortInt16DescOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortInt16DescOp) Len() int {
	return len(s.order)
}

type sortInt16AscWithNullsOp struct {
	sortCol       []int16
	nulls         *coldata.Nulls
	order         []uint64
	cancelChecker CancelChecker
}

func (s *sortInt16AscWithNullsOp) init(col coldata.Vec, order []uint64) {
	s.sortCol = col.Int16()
	s.nulls = col.Nulls()
	s.order = order
}

func (s *sortInt16AscWithNullsOp) sort(ctx context.Context) {
	n := len(s.sortCol)
	s.quickSort(ctx, 0, n, maxDepth(n))
}

func (s *sortInt16AscWithNullsOp) sortPartitions(ctx context.Context, partitions []uint64) {
	if len(partitions) < 1 {
		execerror.VectorizedInternalPanic(fmt.Sprintf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd uint64
		if i == len(partitions)-1 {
			partitionEnd = uint64(len(order))
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := int(partitionEnd - partitionStart)
		s.quickSort(ctx, 0, n, maxDepth(n))
	}
}

func (s *sortInt16AscWithNullsOp) Less(i, j int) bool {
	n1 := s.nulls.MaybeHasNulls() && s.nulls.NullAt64(s.order[i])
	n2 := s.nulls.MaybeHasNulls() && s.nulls.NullAt64(s.order[j])
	// If ascending, nulls always sort first, so we encode that logic here.
	if n1 && n2 {
		return false
	} else if n1 {
		return true
	} else if n2 {
		return false
	}
	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol[int(s.order[i])]
	arg2 := s.sortCol[int(s.order[j])]
	lt = arg1 < arg2
	return lt
}

func (s *sortInt16AscWithNullsOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortInt16AscWithNullsOp) Len() int {
	return len(s.order)
}

type sortInt16DescWithNullsOp struct {
	sortCol       []int16
	nulls         *coldata.Nulls
	order         []uint64
	cancelChecker CancelChecker
}

func (s *sortInt16DescWithNullsOp) init(col coldata.Vec, order []uint64) {
	s.sortCol = col.Int16()
	s.nulls = col.Nulls()
	s.order = order
}

func (s *sortInt16DescWithNullsOp) sort(ctx context.Context) {
	n := len(s.sortCol)
	s.quickSort(ctx, 0, n, maxDepth(n))
}

func (s *sortInt16DescWithNullsOp) sortPartitions(ctx context.Context, partitions []uint64) {
	if len(partitions) < 1 {
		execerror.VectorizedInternalPanic(fmt.Sprintf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd uint64
		if i == len(partitions)-1 {
			partitionEnd = uint64(len(order))
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := int(partitionEnd - partitionStart)
		s.quickSort(ctx, 0, n, maxDepth(n))
	}
}

func (s *sortInt16DescWithNullsOp) Less(i, j int) bool {
	n1 := s.nulls.MaybeHasNulls() && s.nulls.NullAt64(s.order[i])
	n2 := s.nulls.MaybeHasNulls() && s.nulls.NullAt64(s.order[j])
	// If descending, nulls always sort last, so we encode that logic here.
	if n1 && n2 {
		return false
	} else if n1 {
		return false
	} else if n2 {
		return true
	}
	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol[int(s.order[i])]
	arg2 := s.sortCol[int(s.order[j])]
	lt = arg1 > arg2
	return lt
}

func (s *sortInt16DescWithNullsOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortInt16DescWithNullsOp) Len() int {
	return len(s.order)
}

type sortInt32AscOp struct {
	sortCol       []int32
	nulls         *coldata.Nulls
	order         []uint64
	cancelChecker CancelChecker
}

func (s *sortInt32AscOp) init(col coldata.Vec, order []uint64) {
	s.sortCol = col.Int32()
	s.nulls = col.Nulls()
	s.order = order
}

func (s *sortInt32AscOp) sort(ctx context.Context) {
	n := len(s.sortCol)
	s.quickSort(ctx, 0, n, maxDepth(n))
}

func (s *sortInt32AscOp) sortPartitions(ctx context.Context, partitions []uint64) {
	if len(partitions) < 1 {
		execerror.VectorizedInternalPanic(fmt.Sprintf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd uint64
		if i == len(partitions)-1 {
			partitionEnd = uint64(len(order))
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := int(partitionEnd - partitionStart)
		s.quickSort(ctx, 0, n, maxDepth(n))
	}
}

func (s *sortInt32AscOp) Less(i, j int) bool {
	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol[int(s.order[i])]
	arg2 := s.sortCol[int(s.order[j])]
	lt = arg1 < arg2
	return lt
}

func (s *sortInt32AscOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortInt32AscOp) Len() int {
	return len(s.order)
}

type sortInt32DescOp struct {
	sortCol       []int32
	nulls         *coldata.Nulls
	order         []uint64
	cancelChecker CancelChecker
}

func (s *sortInt32DescOp) init(col coldata.Vec, order []uint64) {
	s.sortCol = col.Int32()
	s.nulls = col.Nulls()
	s.order = order
}

func (s *sortInt32DescOp) sort(ctx context.Context) {
	n := len(s.sortCol)
	s.quickSort(ctx, 0, n, maxDepth(n))
}

func (s *sortInt32DescOp) sortPartitions(ctx context.Context, partitions []uint64) {
	if len(partitions) < 1 {
		execerror.VectorizedInternalPanic(fmt.Sprintf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd uint64
		if i == len(partitions)-1 {
			partitionEnd = uint64(len(order))
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := int(partitionEnd - partitionStart)
		s.quickSort(ctx, 0, n, maxDepth(n))
	}
}

func (s *sortInt32DescOp) Less(i, j int) bool {
	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol[int(s.order[i])]
	arg2 := s.sortCol[int(s.order[j])]
	lt = arg1 > arg2
	return lt
}

func (s *sortInt32DescOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortInt32DescOp) Len() int {
	return len(s.order)
}

type sortInt32AscWithNullsOp struct {
	sortCol       []int32
	nulls         *coldata.Nulls
	order         []uint64
	cancelChecker CancelChecker
}

func (s *sortInt32AscWithNullsOp) init(col coldata.Vec, order []uint64) {
	s.sortCol = col.Int32()
	s.nulls = col.Nulls()
	s.order = order
}

func (s *sortInt32AscWithNullsOp) sort(ctx context.Context) {
	n := len(s.sortCol)
	s.quickSort(ctx, 0, n, maxDepth(n))
}

func (s *sortInt32AscWithNullsOp) sortPartitions(ctx context.Context, partitions []uint64) {
	if len(partitions) < 1 {
		execerror.VectorizedInternalPanic(fmt.Sprintf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd uint64
		if i == len(partitions)-1 {
			partitionEnd = uint64(len(order))
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := int(partitionEnd - partitionStart)
		s.quickSort(ctx, 0, n, maxDepth(n))
	}
}

func (s *sortInt32AscWithNullsOp) Less(i, j int) bool {
	n1 := s.nulls.MaybeHasNulls() && s.nulls.NullAt64(s.order[i])
	n2 := s.nulls.MaybeHasNulls() && s.nulls.NullAt64(s.order[j])
	// If ascending, nulls always sort first, so we encode that logic here.
	if n1 && n2 {
		return false
	} else if n1 {
		return true
	} else if n2 {
		return false
	}
	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol[int(s.order[i])]
	arg2 := s.sortCol[int(s.order[j])]
	lt = arg1 < arg2
	return lt
}

func (s *sortInt32AscWithNullsOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortInt32AscWithNullsOp) Len() int {
	return len(s.order)
}

type sortInt32DescWithNullsOp struct {
	sortCol       []int32
	nulls         *coldata.Nulls
	order         []uint64
	cancelChecker CancelChecker
}

func (s *sortInt32DescWithNullsOp) init(col coldata.Vec, order []uint64) {
	s.sortCol = col.Int32()
	s.nulls = col.Nulls()
	s.order = order
}

func (s *sortInt32DescWithNullsOp) sort(ctx context.Context) {
	n := len(s.sortCol)
	s.quickSort(ctx, 0, n, maxDepth(n))
}

func (s *sortInt32DescWithNullsOp) sortPartitions(ctx context.Context, partitions []uint64) {
	if len(partitions) < 1 {
		execerror.VectorizedInternalPanic(fmt.Sprintf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd uint64
		if i == len(partitions)-1 {
			partitionEnd = uint64(len(order))
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := int(partitionEnd - partitionStart)
		s.quickSort(ctx, 0, n, maxDepth(n))
	}
}

func (s *sortInt32DescWithNullsOp) Less(i, j int) bool {
	n1 := s.nulls.MaybeHasNulls() && s.nulls.NullAt64(s.order[i])
	n2 := s.nulls.MaybeHasNulls() && s.nulls.NullAt64(s.order[j])
	// If descending, nulls always sort last, so we encode that logic here.
	if n1 && n2 {
		return false
	} else if n1 {
		return false
	} else if n2 {
		return true
	}
	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol[int(s.order[i])]
	arg2 := s.sortCol[int(s.order[j])]
	lt = arg1 > arg2
	return lt
}

func (s *sortInt32DescWithNullsOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortInt32DescWithNullsOp) Len() int {
	return len(s.order)
}

type sortInt64AscOp struct {
	sortCol       []int64
	nulls         *coldata.Nulls
	order         []uint64
	cancelChecker CancelChecker
}

func (s *sortInt64AscOp) init(col coldata.Vec, order []uint64) {
	s.sortCol = col.Int64()
	s.nulls = col.Nulls()
	s.order = order
}

func (s *sortInt64AscOp) sort(ctx context.Context) {
	n := len(s.sortCol)
	s.quickSort(ctx, 0, n, maxDepth(n))
}

func (s *sortInt64AscOp) sortPartitions(ctx context.Context, partitions []uint64) {
	if len(partitions) < 1 {
		execerror.VectorizedInternalPanic(fmt.Sprintf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd uint64
		if i == len(partitions)-1 {
			partitionEnd = uint64(len(order))
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := int(partitionEnd - partitionStart)
		s.quickSort(ctx, 0, n, maxDepth(n))
	}
}

func (s *sortInt64AscOp) Less(i, j int) bool {
	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol[int(s.order[i])]
	arg2 := s.sortCol[int(s.order[j])]
	lt = arg1 < arg2
	return lt
}

func (s *sortInt64AscOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortInt64AscOp) Len() int {
	return len(s.order)
}

type sortInt64DescOp struct {
	sortCol       []int64
	nulls         *coldata.Nulls
	order         []uint64
	cancelChecker CancelChecker
}

func (s *sortInt64DescOp) init(col coldata.Vec, order []uint64) {
	s.sortCol = col.Int64()
	s.nulls = col.Nulls()
	s.order = order
}

func (s *sortInt64DescOp) sort(ctx context.Context) {
	n := len(s.sortCol)
	s.quickSort(ctx, 0, n, maxDepth(n))
}

func (s *sortInt64DescOp) sortPartitions(ctx context.Context, partitions []uint64) {
	if len(partitions) < 1 {
		execerror.VectorizedInternalPanic(fmt.Sprintf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd uint64
		if i == len(partitions)-1 {
			partitionEnd = uint64(len(order))
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := int(partitionEnd - partitionStart)
		s.quickSort(ctx, 0, n, maxDepth(n))
	}
}

func (s *sortInt64DescOp) Less(i, j int) bool {
	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol[int(s.order[i])]
	arg2 := s.sortCol[int(s.order[j])]
	lt = arg1 > arg2
	return lt
}

func (s *sortInt64DescOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortInt64DescOp) Len() int {
	return len(s.order)
}

type sortInt64AscWithNullsOp struct {
	sortCol       []int64
	nulls         *coldata.Nulls
	order         []uint64
	cancelChecker CancelChecker
}

func (s *sortInt64AscWithNullsOp) init(col coldata.Vec, order []uint64) {
	s.sortCol = col.Int64()
	s.nulls = col.Nulls()
	s.order = order
}

func (s *sortInt64AscWithNullsOp) sort(ctx context.Context) {
	n := len(s.sortCol)
	s.quickSort(ctx, 0, n, maxDepth(n))
}

func (s *sortInt64AscWithNullsOp) sortPartitions(ctx context.Context, partitions []uint64) {
	if len(partitions) < 1 {
		execerror.VectorizedInternalPanic(fmt.Sprintf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd uint64
		if i == len(partitions)-1 {
			partitionEnd = uint64(len(order))
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := int(partitionEnd - partitionStart)
		s.quickSort(ctx, 0, n, maxDepth(n))
	}
}

func (s *sortInt64AscWithNullsOp) Less(i, j int) bool {
	n1 := s.nulls.MaybeHasNulls() && s.nulls.NullAt64(s.order[i])
	n2 := s.nulls.MaybeHasNulls() && s.nulls.NullAt64(s.order[j])
	// If ascending, nulls always sort first, so we encode that logic here.
	if n1 && n2 {
		return false
	} else if n1 {
		return true
	} else if n2 {
		return false
	}
	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol[int(s.order[i])]
	arg2 := s.sortCol[int(s.order[j])]
	lt = arg1 < arg2
	return lt
}

func (s *sortInt64AscWithNullsOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortInt64AscWithNullsOp) Len() int {
	return len(s.order)
}

type sortInt64DescWithNullsOp struct {
	sortCol       []int64
	nulls         *coldata.Nulls
	order         []uint64
	cancelChecker CancelChecker
}

func (s *sortInt64DescWithNullsOp) init(col coldata.Vec, order []uint64) {
	s.sortCol = col.Int64()
	s.nulls = col.Nulls()
	s.order = order
}

func (s *sortInt64DescWithNullsOp) sort(ctx context.Context) {
	n := len(s.sortCol)
	s.quickSort(ctx, 0, n, maxDepth(n))
}

func (s *sortInt64DescWithNullsOp) sortPartitions(ctx context.Context, partitions []uint64) {
	if len(partitions) < 1 {
		execerror.VectorizedInternalPanic(fmt.Sprintf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd uint64
		if i == len(partitions)-1 {
			partitionEnd = uint64(len(order))
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := int(partitionEnd - partitionStart)
		s.quickSort(ctx, 0, n, maxDepth(n))
	}
}

func (s *sortInt64DescWithNullsOp) Less(i, j int) bool {
	n1 := s.nulls.MaybeHasNulls() && s.nulls.NullAt64(s.order[i])
	n2 := s.nulls.MaybeHasNulls() && s.nulls.NullAt64(s.order[j])
	// If descending, nulls always sort last, so we encode that logic here.
	if n1 && n2 {
		return false
	} else if n1 {
		return false
	} else if n2 {
		return true
	}
	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol[int(s.order[i])]
	arg2 := s.sortCol[int(s.order[j])]
	lt = arg1 > arg2
	return lt
}

func (s *sortInt64DescWithNullsOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortInt64DescWithNullsOp) Len() int {
	return len(s.order)
}

type sortFloat32AscOp struct {
	sortCol       []float32
	nulls         *coldata.Nulls
	order         []uint64
	cancelChecker CancelChecker
}

func (s *sortFloat32AscOp) init(col coldata.Vec, order []uint64) {
	s.sortCol = col.Float32()
	s.nulls = col.Nulls()
	s.order = order
}

func (s *sortFloat32AscOp) sort(ctx context.Context) {
	n := len(s.sortCol)
	s.quickSort(ctx, 0, n, maxDepth(n))
}

func (s *sortFloat32AscOp) sortPartitions(ctx context.Context, partitions []uint64) {
	if len(partitions) < 1 {
		execerror.VectorizedInternalPanic(fmt.Sprintf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd uint64
		if i == len(partitions)-1 {
			partitionEnd = uint64(len(order))
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := int(partitionEnd - partitionStart)
		s.quickSort(ctx, 0, n, maxDepth(n))
	}
}

func (s *sortFloat32AscOp) Less(i, j int) bool {
	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol[int(s.order[i])]
	arg2 := s.sortCol[int(s.order[j])]
	lt = compareFloats(float64(arg1), float64(arg2)) < 0
	return lt
}

func (s *sortFloat32AscOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortFloat32AscOp) Len() int {
	return len(s.order)
}

type sortFloat32DescOp struct {
	sortCol       []float32
	nulls         *coldata.Nulls
	order         []uint64
	cancelChecker CancelChecker
}

func (s *sortFloat32DescOp) init(col coldata.Vec, order []uint64) {
	s.sortCol = col.Float32()
	s.nulls = col.Nulls()
	s.order = order
}

func (s *sortFloat32DescOp) sort(ctx context.Context) {
	n := len(s.sortCol)
	s.quickSort(ctx, 0, n, maxDepth(n))
}

func (s *sortFloat32DescOp) sortPartitions(ctx context.Context, partitions []uint64) {
	if len(partitions) < 1 {
		execerror.VectorizedInternalPanic(fmt.Sprintf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd uint64
		if i == len(partitions)-1 {
			partitionEnd = uint64(len(order))
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := int(partitionEnd - partitionStart)
		s.quickSort(ctx, 0, n, maxDepth(n))
	}
}

func (s *sortFloat32DescOp) Less(i, j int) bool {
	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol[int(s.order[i])]
	arg2 := s.sortCol[int(s.order[j])]
	lt = compareFloats(float64(arg1), float64(arg2)) > 0
	return lt
}

func (s *sortFloat32DescOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortFloat32DescOp) Len() int {
	return len(s.order)
}

type sortFloat32AscWithNullsOp struct {
	sortCol       []float32
	nulls         *coldata.Nulls
	order         []uint64
	cancelChecker CancelChecker
}

func (s *sortFloat32AscWithNullsOp) init(col coldata.Vec, order []uint64) {
	s.sortCol = col.Float32()
	s.nulls = col.Nulls()
	s.order = order
}

func (s *sortFloat32AscWithNullsOp) sort(ctx context.Context) {
	n := len(s.sortCol)
	s.quickSort(ctx, 0, n, maxDepth(n))
}

func (s *sortFloat32AscWithNullsOp) sortPartitions(ctx context.Context, partitions []uint64) {
	if len(partitions) < 1 {
		execerror.VectorizedInternalPanic(fmt.Sprintf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd uint64
		if i == len(partitions)-1 {
			partitionEnd = uint64(len(order))
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := int(partitionEnd - partitionStart)
		s.quickSort(ctx, 0, n, maxDepth(n))
	}
}

func (s *sortFloat32AscWithNullsOp) Less(i, j int) bool {
	n1 := s.nulls.MaybeHasNulls() && s.nulls.NullAt64(s.order[i])
	n2 := s.nulls.MaybeHasNulls() && s.nulls.NullAt64(s.order[j])
	// If ascending, nulls always sort first, so we encode that logic here.
	if n1 && n2 {
		return false
	} else if n1 {
		return true
	} else if n2 {
		return false
	}
	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol[int(s.order[i])]
	arg2 := s.sortCol[int(s.order[j])]
	lt = compareFloats(float64(arg1), float64(arg2)) < 0
	return lt
}

func (s *sortFloat32AscWithNullsOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortFloat32AscWithNullsOp) Len() int {
	return len(s.order)
}

type sortFloat32DescWithNullsOp struct {
	sortCol       []float32
	nulls         *coldata.Nulls
	order         []uint64
	cancelChecker CancelChecker
}

func (s *sortFloat32DescWithNullsOp) init(col coldata.Vec, order []uint64) {
	s.sortCol = col.Float32()
	s.nulls = col.Nulls()
	s.order = order
}

func (s *sortFloat32DescWithNullsOp) sort(ctx context.Context) {
	n := len(s.sortCol)
	s.quickSort(ctx, 0, n, maxDepth(n))
}

func (s *sortFloat32DescWithNullsOp) sortPartitions(ctx context.Context, partitions []uint64) {
	if len(partitions) < 1 {
		execerror.VectorizedInternalPanic(fmt.Sprintf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd uint64
		if i == len(partitions)-1 {
			partitionEnd = uint64(len(order))
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := int(partitionEnd - partitionStart)
		s.quickSort(ctx, 0, n, maxDepth(n))
	}
}

func (s *sortFloat32DescWithNullsOp) Less(i, j int) bool {
	n1 := s.nulls.MaybeHasNulls() && s.nulls.NullAt64(s.order[i])
	n2 := s.nulls.MaybeHasNulls() && s.nulls.NullAt64(s.order[j])
	// If descending, nulls always sort last, so we encode that logic here.
	if n1 && n2 {
		return false
	} else if n1 {
		return false
	} else if n2 {
		return true
	}
	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol[int(s.order[i])]
	arg2 := s.sortCol[int(s.order[j])]
	lt = compareFloats(float64(arg1), float64(arg2)) > 0
	return lt
}

func (s *sortFloat32DescWithNullsOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortFloat32DescWithNullsOp) Len() int {
	return len(s.order)
}

type sortFloat64AscOp struct {
	sortCol       []float64
	nulls         *coldata.Nulls
	order         []uint64
	cancelChecker CancelChecker
}

func (s *sortFloat64AscOp) init(col coldata.Vec, order []uint64) {
	s.sortCol = col.Float64()
	s.nulls = col.Nulls()
	s.order = order
}

func (s *sortFloat64AscOp) sort(ctx context.Context) {
	n := len(s.sortCol)
	s.quickSort(ctx, 0, n, maxDepth(n))
}

func (s *sortFloat64AscOp) sortPartitions(ctx context.Context, partitions []uint64) {
	if len(partitions) < 1 {
		execerror.VectorizedInternalPanic(fmt.Sprintf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd uint64
		if i == len(partitions)-1 {
			partitionEnd = uint64(len(order))
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := int(partitionEnd - partitionStart)
		s.quickSort(ctx, 0, n, maxDepth(n))
	}
}

func (s *sortFloat64AscOp) Less(i, j int) bool {
	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol[int(s.order[i])]
	arg2 := s.sortCol[int(s.order[j])]
	lt = compareFloats(float64(arg1), float64(arg2)) < 0
	return lt
}

func (s *sortFloat64AscOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortFloat64AscOp) Len() int {
	return len(s.order)
}

type sortFloat64DescOp struct {
	sortCol       []float64
	nulls         *coldata.Nulls
	order         []uint64
	cancelChecker CancelChecker
}

func (s *sortFloat64DescOp) init(col coldata.Vec, order []uint64) {
	s.sortCol = col.Float64()
	s.nulls = col.Nulls()
	s.order = order
}

func (s *sortFloat64DescOp) sort(ctx context.Context) {
	n := len(s.sortCol)
	s.quickSort(ctx, 0, n, maxDepth(n))
}

func (s *sortFloat64DescOp) sortPartitions(ctx context.Context, partitions []uint64) {
	if len(partitions) < 1 {
		execerror.VectorizedInternalPanic(fmt.Sprintf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd uint64
		if i == len(partitions)-1 {
			partitionEnd = uint64(len(order))
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := int(partitionEnd - partitionStart)
		s.quickSort(ctx, 0, n, maxDepth(n))
	}
}

func (s *sortFloat64DescOp) Less(i, j int) bool {
	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol[int(s.order[i])]
	arg2 := s.sortCol[int(s.order[j])]
	lt = compareFloats(float64(arg1), float64(arg2)) > 0
	return lt
}

func (s *sortFloat64DescOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortFloat64DescOp) Len() int {
	return len(s.order)
}

type sortFloat64AscWithNullsOp struct {
	sortCol       []float64
	nulls         *coldata.Nulls
	order         []uint64
	cancelChecker CancelChecker
}

func (s *sortFloat64AscWithNullsOp) init(col coldata.Vec, order []uint64) {
	s.sortCol = col.Float64()
	s.nulls = col.Nulls()
	s.order = order
}

func (s *sortFloat64AscWithNullsOp) sort(ctx context.Context) {
	n := len(s.sortCol)
	s.quickSort(ctx, 0, n, maxDepth(n))
}

func (s *sortFloat64AscWithNullsOp) sortPartitions(ctx context.Context, partitions []uint64) {
	if len(partitions) < 1 {
		execerror.VectorizedInternalPanic(fmt.Sprintf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd uint64
		if i == len(partitions)-1 {
			partitionEnd = uint64(len(order))
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := int(partitionEnd - partitionStart)
		s.quickSort(ctx, 0, n, maxDepth(n))
	}
}

func (s *sortFloat64AscWithNullsOp) Less(i, j int) bool {
	n1 := s.nulls.MaybeHasNulls() && s.nulls.NullAt64(s.order[i])
	n2 := s.nulls.MaybeHasNulls() && s.nulls.NullAt64(s.order[j])
	// If ascending, nulls always sort first, so we encode that logic here.
	if n1 && n2 {
		return false
	} else if n1 {
		return true
	} else if n2 {
		return false
	}
	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol[int(s.order[i])]
	arg2 := s.sortCol[int(s.order[j])]
	lt = compareFloats(float64(arg1), float64(arg2)) < 0
	return lt
}

func (s *sortFloat64AscWithNullsOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortFloat64AscWithNullsOp) Len() int {
	return len(s.order)
}

type sortFloat64DescWithNullsOp struct {
	sortCol       []float64
	nulls         *coldata.Nulls
	order         []uint64
	cancelChecker CancelChecker
}

func (s *sortFloat64DescWithNullsOp) init(col coldata.Vec, order []uint64) {
	s.sortCol = col.Float64()
	s.nulls = col.Nulls()
	s.order = order
}

func (s *sortFloat64DescWithNullsOp) sort(ctx context.Context) {
	n := len(s.sortCol)
	s.quickSort(ctx, 0, n, maxDepth(n))
}

func (s *sortFloat64DescWithNullsOp) sortPartitions(ctx context.Context, partitions []uint64) {
	if len(partitions) < 1 {
		execerror.VectorizedInternalPanic(fmt.Sprintf("invalid partitions list %v", partitions))
	}
	order := s.order
	for i, partitionStart := range partitions {
		var partitionEnd uint64
		if i == len(partitions)-1 {
			partitionEnd = uint64(len(order))
		} else {
			partitionEnd = partitions[i+1]
		}
		s.order = order[partitionStart:partitionEnd]
		n := int(partitionEnd - partitionStart)
		s.quickSort(ctx, 0, n, maxDepth(n))
	}
}

func (s *sortFloat64DescWithNullsOp) Less(i, j int) bool {
	n1 := s.nulls.MaybeHasNulls() && s.nulls.NullAt64(s.order[i])
	n2 := s.nulls.MaybeHasNulls() && s.nulls.NullAt64(s.order[j])
	// If descending, nulls always sort last, so we encode that logic here.
	if n1 && n2 {
		return false
	} else if n1 {
		return false
	} else if n2 {
		return true
	}
	var lt bool
	// We always indirect via the order vector.
	arg1 := s.sortCol[int(s.order[i])]
	arg2 := s.sortCol[int(s.order[j])]
	lt = compareFloats(float64(arg1), float64(arg2)) > 0
	return lt
}

func (s *sortFloat64DescWithNullsOp) Swap(i, j int) {
	// We don't physically swap the column - we merely edit the order vector.
	s.order[i], s.order[j] = s.order[j], s.order[i]
}

func (s *sortFloat64DescWithNullsOp) Len() int {
	return len(s.order)
}
