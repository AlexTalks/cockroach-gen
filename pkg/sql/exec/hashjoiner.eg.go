// Code generated by execgen; DO NOT EDIT.

package exec

import (
	"bytes"
	"fmt"
	"math"

	"github.com/cockroachdb/cockroach/pkg/sql/exec/types"
)

// rehash takes a element of a key (tuple representing a row of equality
// column values) at a given column and computes a new hash by applying a
// transformation to the existing hash.
func (ht *hashTable) rehash(
	buckets []uint64, keyIdx int, t types.T, col ColVec, nKeys uint64, sel []uint16,
) {
	switch t {

	case types.Bool:
		keys := col.Bool()
		if sel != nil {
			for i := uint64(0); i < nKeys; i++ {

				if keys[sel[i]] {
					buckets[i] = buckets[i]*31 + 1
				}

			}
		} else {
			for i := uint64(0); i < nKeys; i++ {

				if keys[i] {
					buckets[i] = buckets[i]*31 + 1
				}

			}
		}

	case types.Bytes:
		keys := col.Bytes()
		if sel != nil {
			for i := uint64(0); i < nKeys; i++ {

				hash := 1
				for b := range keys[sel[i]] {
					hash = hash*31 + b
				}
				buckets[i] = buckets[i]*31 + uint64(hash)

			}
		} else {
			for i := uint64(0); i < nKeys; i++ {

				hash := 1
				for b := range keys[i] {
					hash = hash*31 + b
				}
				buckets[i] = buckets[i]*31 + uint64(hash)

			}
		}

	case types.Decimal:
		keys := col.Decimal()
		if sel != nil {
			for i := uint64(0); i < nKeys; i++ {

				d, err := keys[sel[i]].Float64()
				if err != nil {
					panic(fmt.Sprintf("%v", err))
				}
				buckets[i] = buckets[i]*31 + math.Float64bits(d)

			}
		} else {
			for i := uint64(0); i < nKeys; i++ {

				d, err := keys[i].Float64()
				if err != nil {
					panic(fmt.Sprintf("%v", err))
				}
				buckets[i] = buckets[i]*31 + math.Float64bits(d)

			}
		}

	case types.Int8:
		keys := col.Int8()
		if sel != nil {
			for i := uint64(0); i < nKeys; i++ {

				buckets[i] = buckets[i]*31 + uint64(keys[sel[i]])

			}
		} else {
			for i := uint64(0); i < nKeys; i++ {

				buckets[i] = buckets[i]*31 + uint64(keys[i])

			}
		}

	case types.Int16:
		keys := col.Int16()
		if sel != nil {
			for i := uint64(0); i < nKeys; i++ {

				buckets[i] = buckets[i]*31 + uint64(keys[sel[i]])

			}
		} else {
			for i := uint64(0); i < nKeys; i++ {

				buckets[i] = buckets[i]*31 + uint64(keys[i])

			}
		}

	case types.Int32:
		keys := col.Int32()
		if sel != nil {
			for i := uint64(0); i < nKeys; i++ {

				buckets[i] = buckets[i]*31 + uint64(keys[sel[i]])

			}
		} else {
			for i := uint64(0); i < nKeys; i++ {

				buckets[i] = buckets[i]*31 + uint64(keys[i])

			}
		}

	case types.Int64:
		keys := col.Int64()
		if sel != nil {
			for i := uint64(0); i < nKeys; i++ {

				buckets[i] = buckets[i]*31 + uint64(keys[sel[i]])

			}
		} else {
			for i := uint64(0); i < nKeys; i++ {

				buckets[i] = buckets[i]*31 + uint64(keys[i])

			}
		}

	case types.Float32:
		keys := col.Float32()
		if sel != nil {
			for i := uint64(0); i < nKeys; i++ {

				buckets[i] = buckets[i]*31 + uint64(math.Float32bits(keys[sel[i]]))

			}
		} else {
			for i := uint64(0); i < nKeys; i++ {

				buckets[i] = buckets[i]*31 + uint64(math.Float32bits(keys[i]))

			}
		}

	case types.Float64:
		keys := col.Float64()
		if sel != nil {
			for i := uint64(0); i < nKeys; i++ {

				buckets[i] = buckets[i]*31 + math.Float64bits(keys[sel[i]])

			}
		} else {
			for i := uint64(0); i < nKeys; i++ {

				buckets[i] = buckets[i]*31 + math.Float64bits(keys[i])

			}
		}

	default:
		panic(fmt.Sprintf("unhandled type %d", t))
	}
}

// checkCol determines if the current key column in the groupID buckets matches
// the specified equality column key. If there is a match, then the key is added
// to differs. If the bucket has reached the end, the key is rejected. If any
// element in the key is null, then there is no match.
func (prober *hashJoinProber) checkCol(t types.T, keyColIdx int, nToCheck uint16, sel []uint16) {
	switch t {

	case types.Bool:
		buildVec := prober.ht.vals[prober.ht.keyCols[keyColIdx]]
		probeVec := prober.keys[keyColIdx]

		buildKeys := buildVec.Bool()
		probeKeys := probeVec.Bool()

		if sel != nil {
			for i := uint16(0); i < nToCheck; i++ {
				// keyID of 0 is reserved to represent the end of the next chain.
				if keyID := prober.groupID[prober.toCheck[i]]; keyID != 0 {
					// the build table key (calculated using keys[keyID - 1] = key) is
					// compared to the corresponding probe table to determine if a match is
					// found.

					if probeVec.NullAt(sel[prober.toCheck[i]]) {
						prober.groupID[prober.toCheck[i]] = 0
					} else if buildVec.NullAt64(keyID - 1) {
						prober.differs[prober.toCheck[i]] = true
					} else {

						if buildKeys[keyID-1] != probeKeys[sel[prober.toCheck[i]]] {
							prober.differs[prober.toCheck[i]] = true
						}

					}
				}
			}
		} else {
			for i := uint16(0); i < nToCheck; i++ {
				// keyID of 0 is reserved to represent the end of the next chain.
				if keyID := prober.groupID[prober.toCheck[i]]; keyID != 0 {
					// the build table key (calculated using keys[keyID - 1] = key) is
					// compared to the corresponding probe table to determine if a match is
					// found.

					if probeVec.NullAt(prober.toCheck[i]) {
						prober.groupID[prober.toCheck[i]] = 0
					} else if buildVec.NullAt64(keyID - 1) {
						prober.differs[prober.toCheck[i]] = true
					} else {

						if buildKeys[keyID-1] != probeKeys[prober.toCheck[i]] {
							prober.differs[prober.toCheck[i]] = true
						}

					}
				}
			}
		}

	case types.Bytes:
		buildVec := prober.ht.vals[prober.ht.keyCols[keyColIdx]]
		probeVec := prober.keys[keyColIdx]

		buildKeys := buildVec.Bytes()
		probeKeys := probeVec.Bytes()

		if sel != nil {
			for i := uint16(0); i < nToCheck; i++ {
				// keyID of 0 is reserved to represent the end of the next chain.
				if keyID := prober.groupID[prober.toCheck[i]]; keyID != 0 {
					// the build table key (calculated using keys[keyID - 1] = key) is
					// compared to the corresponding probe table to determine if a match is
					// found.

					if probeVec.NullAt(sel[prober.toCheck[i]]) {
						prober.groupID[prober.toCheck[i]] = 0
					} else if buildVec.NullAt64(keyID - 1) {
						prober.differs[prober.toCheck[i]] = true
					} else {

						if !bytes.Equal(buildKeys[keyID-1], probeKeys[sel[prober.toCheck[i]]]) {
							prober.differs[prober.toCheck[i]] = true
						}

					}
				}
			}
		} else {
			for i := uint16(0); i < nToCheck; i++ {
				// keyID of 0 is reserved to represent the end of the next chain.
				if keyID := prober.groupID[prober.toCheck[i]]; keyID != 0 {
					// the build table key (calculated using keys[keyID - 1] = key) is
					// compared to the corresponding probe table to determine if a match is
					// found.

					if probeVec.NullAt(prober.toCheck[i]) {
						prober.groupID[prober.toCheck[i]] = 0
					} else if buildVec.NullAt64(keyID - 1) {
						prober.differs[prober.toCheck[i]] = true
					} else {

						if !bytes.Equal(buildKeys[keyID-1], probeKeys[prober.toCheck[i]]) {
							prober.differs[prober.toCheck[i]] = true
						}

					}
				}
			}
		}

	case types.Decimal:
		buildVec := prober.ht.vals[prober.ht.keyCols[keyColIdx]]
		probeVec := prober.keys[keyColIdx]

		buildKeys := buildVec.Decimal()
		probeKeys := probeVec.Decimal()

		if sel != nil {
			for i := uint16(0); i < nToCheck; i++ {
				// keyID of 0 is reserved to represent the end of the next chain.
				if keyID := prober.groupID[prober.toCheck[i]]; keyID != 0 {
					// the build table key (calculated using keys[keyID - 1] = key) is
					// compared to the corresponding probe table to determine if a match is
					// found.

					if probeVec.NullAt(sel[prober.toCheck[i]]) {
						prober.groupID[prober.toCheck[i]] = 0
					} else if buildVec.NullAt64(keyID - 1) {
						prober.differs[prober.toCheck[i]] = true
					} else {

						if buildKeys[keyID-1].Cmp(&probeKeys[sel[prober.toCheck[i]]]) != 0 {
							prober.differs[prober.toCheck[i]] = true
						}

					}
				}
			}
		} else {
			for i := uint16(0); i < nToCheck; i++ {
				// keyID of 0 is reserved to represent the end of the next chain.
				if keyID := prober.groupID[prober.toCheck[i]]; keyID != 0 {
					// the build table key (calculated using keys[keyID - 1] = key) is
					// compared to the corresponding probe table to determine if a match is
					// found.

					if probeVec.NullAt(prober.toCheck[i]) {
						prober.groupID[prober.toCheck[i]] = 0
					} else if buildVec.NullAt64(keyID - 1) {
						prober.differs[prober.toCheck[i]] = true
					} else {

						if buildKeys[keyID-1].Cmp(&probeKeys[prober.toCheck[i]]) != 0 {
							prober.differs[prober.toCheck[i]] = true
						}

					}
				}
			}
		}

	case types.Int8:
		buildVec := prober.ht.vals[prober.ht.keyCols[keyColIdx]]
		probeVec := prober.keys[keyColIdx]

		buildKeys := buildVec.Int8()
		probeKeys := probeVec.Int8()

		if sel != nil {
			for i := uint16(0); i < nToCheck; i++ {
				// keyID of 0 is reserved to represent the end of the next chain.
				if keyID := prober.groupID[prober.toCheck[i]]; keyID != 0 {
					// the build table key (calculated using keys[keyID - 1] = key) is
					// compared to the corresponding probe table to determine if a match is
					// found.

					if probeVec.NullAt(sel[prober.toCheck[i]]) {
						prober.groupID[prober.toCheck[i]] = 0
					} else if buildVec.NullAt64(keyID - 1) {
						prober.differs[prober.toCheck[i]] = true
					} else {

						if buildKeys[keyID-1] != probeKeys[sel[prober.toCheck[i]]] {
							prober.differs[prober.toCheck[i]] = true
						}

					}
				}
			}
		} else {
			for i := uint16(0); i < nToCheck; i++ {
				// keyID of 0 is reserved to represent the end of the next chain.
				if keyID := prober.groupID[prober.toCheck[i]]; keyID != 0 {
					// the build table key (calculated using keys[keyID - 1] = key) is
					// compared to the corresponding probe table to determine if a match is
					// found.

					if probeVec.NullAt(prober.toCheck[i]) {
						prober.groupID[prober.toCheck[i]] = 0
					} else if buildVec.NullAt64(keyID - 1) {
						prober.differs[prober.toCheck[i]] = true
					} else {

						if buildKeys[keyID-1] != probeKeys[prober.toCheck[i]] {
							prober.differs[prober.toCheck[i]] = true
						}

					}
				}
			}
		}

	case types.Int16:
		buildVec := prober.ht.vals[prober.ht.keyCols[keyColIdx]]
		probeVec := prober.keys[keyColIdx]

		buildKeys := buildVec.Int16()
		probeKeys := probeVec.Int16()

		if sel != nil {
			for i := uint16(0); i < nToCheck; i++ {
				// keyID of 0 is reserved to represent the end of the next chain.
				if keyID := prober.groupID[prober.toCheck[i]]; keyID != 0 {
					// the build table key (calculated using keys[keyID - 1] = key) is
					// compared to the corresponding probe table to determine if a match is
					// found.

					if probeVec.NullAt(sel[prober.toCheck[i]]) {
						prober.groupID[prober.toCheck[i]] = 0
					} else if buildVec.NullAt64(keyID - 1) {
						prober.differs[prober.toCheck[i]] = true
					} else {

						if buildKeys[keyID-1] != probeKeys[sel[prober.toCheck[i]]] {
							prober.differs[prober.toCheck[i]] = true
						}

					}
				}
			}
		} else {
			for i := uint16(0); i < nToCheck; i++ {
				// keyID of 0 is reserved to represent the end of the next chain.
				if keyID := prober.groupID[prober.toCheck[i]]; keyID != 0 {
					// the build table key (calculated using keys[keyID - 1] = key) is
					// compared to the corresponding probe table to determine if a match is
					// found.

					if probeVec.NullAt(prober.toCheck[i]) {
						prober.groupID[prober.toCheck[i]] = 0
					} else if buildVec.NullAt64(keyID - 1) {
						prober.differs[prober.toCheck[i]] = true
					} else {

						if buildKeys[keyID-1] != probeKeys[prober.toCheck[i]] {
							prober.differs[prober.toCheck[i]] = true
						}

					}
				}
			}
		}

	case types.Int32:
		buildVec := prober.ht.vals[prober.ht.keyCols[keyColIdx]]
		probeVec := prober.keys[keyColIdx]

		buildKeys := buildVec.Int32()
		probeKeys := probeVec.Int32()

		if sel != nil {
			for i := uint16(0); i < nToCheck; i++ {
				// keyID of 0 is reserved to represent the end of the next chain.
				if keyID := prober.groupID[prober.toCheck[i]]; keyID != 0 {
					// the build table key (calculated using keys[keyID - 1] = key) is
					// compared to the corresponding probe table to determine if a match is
					// found.

					if probeVec.NullAt(sel[prober.toCheck[i]]) {
						prober.groupID[prober.toCheck[i]] = 0
					} else if buildVec.NullAt64(keyID - 1) {
						prober.differs[prober.toCheck[i]] = true
					} else {

						if buildKeys[keyID-1] != probeKeys[sel[prober.toCheck[i]]] {
							prober.differs[prober.toCheck[i]] = true
						}

					}
				}
			}
		} else {
			for i := uint16(0); i < nToCheck; i++ {
				// keyID of 0 is reserved to represent the end of the next chain.
				if keyID := prober.groupID[prober.toCheck[i]]; keyID != 0 {
					// the build table key (calculated using keys[keyID - 1] = key) is
					// compared to the corresponding probe table to determine if a match is
					// found.

					if probeVec.NullAt(prober.toCheck[i]) {
						prober.groupID[prober.toCheck[i]] = 0
					} else if buildVec.NullAt64(keyID - 1) {
						prober.differs[prober.toCheck[i]] = true
					} else {

						if buildKeys[keyID-1] != probeKeys[prober.toCheck[i]] {
							prober.differs[prober.toCheck[i]] = true
						}

					}
				}
			}
		}

	case types.Int64:
		buildVec := prober.ht.vals[prober.ht.keyCols[keyColIdx]]
		probeVec := prober.keys[keyColIdx]

		buildKeys := buildVec.Int64()
		probeKeys := probeVec.Int64()

		if sel != nil {
			for i := uint16(0); i < nToCheck; i++ {
				// keyID of 0 is reserved to represent the end of the next chain.
				if keyID := prober.groupID[prober.toCheck[i]]; keyID != 0 {
					// the build table key (calculated using keys[keyID - 1] = key) is
					// compared to the corresponding probe table to determine if a match is
					// found.

					if probeVec.NullAt(sel[prober.toCheck[i]]) {
						prober.groupID[prober.toCheck[i]] = 0
					} else if buildVec.NullAt64(keyID - 1) {
						prober.differs[prober.toCheck[i]] = true
					} else {

						if buildKeys[keyID-1] != probeKeys[sel[prober.toCheck[i]]] {
							prober.differs[prober.toCheck[i]] = true
						}

					}
				}
			}
		} else {
			for i := uint16(0); i < nToCheck; i++ {
				// keyID of 0 is reserved to represent the end of the next chain.
				if keyID := prober.groupID[prober.toCheck[i]]; keyID != 0 {
					// the build table key (calculated using keys[keyID - 1] = key) is
					// compared to the corresponding probe table to determine if a match is
					// found.

					if probeVec.NullAt(prober.toCheck[i]) {
						prober.groupID[prober.toCheck[i]] = 0
					} else if buildVec.NullAt64(keyID - 1) {
						prober.differs[prober.toCheck[i]] = true
					} else {

						if buildKeys[keyID-1] != probeKeys[prober.toCheck[i]] {
							prober.differs[prober.toCheck[i]] = true
						}

					}
				}
			}
		}

	case types.Float32:
		buildVec := prober.ht.vals[prober.ht.keyCols[keyColIdx]]
		probeVec := prober.keys[keyColIdx]

		buildKeys := buildVec.Float32()
		probeKeys := probeVec.Float32()

		if sel != nil {
			for i := uint16(0); i < nToCheck; i++ {
				// keyID of 0 is reserved to represent the end of the next chain.
				if keyID := prober.groupID[prober.toCheck[i]]; keyID != 0 {
					// the build table key (calculated using keys[keyID - 1] = key) is
					// compared to the corresponding probe table to determine if a match is
					// found.

					if probeVec.NullAt(sel[prober.toCheck[i]]) {
						prober.groupID[prober.toCheck[i]] = 0
					} else if buildVec.NullAt64(keyID - 1) {
						prober.differs[prober.toCheck[i]] = true
					} else {

						if buildKeys[keyID-1] != probeKeys[sel[prober.toCheck[i]]] {
							prober.differs[prober.toCheck[i]] = true
						}

					}
				}
			}
		} else {
			for i := uint16(0); i < nToCheck; i++ {
				// keyID of 0 is reserved to represent the end of the next chain.
				if keyID := prober.groupID[prober.toCheck[i]]; keyID != 0 {
					// the build table key (calculated using keys[keyID - 1] = key) is
					// compared to the corresponding probe table to determine if a match is
					// found.

					if probeVec.NullAt(prober.toCheck[i]) {
						prober.groupID[prober.toCheck[i]] = 0
					} else if buildVec.NullAt64(keyID - 1) {
						prober.differs[prober.toCheck[i]] = true
					} else {

						if buildKeys[keyID-1] != probeKeys[prober.toCheck[i]] {
							prober.differs[prober.toCheck[i]] = true
						}

					}
				}
			}
		}

	case types.Float64:
		buildVec := prober.ht.vals[prober.ht.keyCols[keyColIdx]]
		probeVec := prober.keys[keyColIdx]

		buildKeys := buildVec.Float64()
		probeKeys := probeVec.Float64()

		if sel != nil {
			for i := uint16(0); i < nToCheck; i++ {
				// keyID of 0 is reserved to represent the end of the next chain.
				if keyID := prober.groupID[prober.toCheck[i]]; keyID != 0 {
					// the build table key (calculated using keys[keyID - 1] = key) is
					// compared to the corresponding probe table to determine if a match is
					// found.

					if probeVec.NullAt(sel[prober.toCheck[i]]) {
						prober.groupID[prober.toCheck[i]] = 0
					} else if buildVec.NullAt64(keyID - 1) {
						prober.differs[prober.toCheck[i]] = true
					} else {

						if buildKeys[keyID-1] != probeKeys[sel[prober.toCheck[i]]] {
							prober.differs[prober.toCheck[i]] = true
						}

					}
				}
			}
		} else {
			for i := uint16(0); i < nToCheck; i++ {
				// keyID of 0 is reserved to represent the end of the next chain.
				if keyID := prober.groupID[prober.toCheck[i]]; keyID != 0 {
					// the build table key (calculated using keys[keyID - 1] = key) is
					// compared to the corresponding probe table to determine if a match is
					// found.

					if probeVec.NullAt(prober.toCheck[i]) {
						prober.groupID[prober.toCheck[i]] = 0
					} else if buildVec.NullAt64(keyID - 1) {
						prober.differs[prober.toCheck[i]] = true
					} else {

						if buildKeys[keyID-1] != probeKeys[prober.toCheck[i]] {
							prober.differs[prober.toCheck[i]] = true
						}

					}
				}
			}
		}

	default:
		panic(fmt.Sprintf("unhandled type %d", t))
	}
}
