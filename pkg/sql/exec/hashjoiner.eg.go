// Code generated by execgen; DO NOT EDIT.
// Copyright 2018 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package exec

import (
	"bytes"
	"context"
	"fmt"
	"reflect"
	"unsafe"

	"github.com/cockroachdb/cockroach/pkg/sql/exec/coldata"
	"github.com/cockroachdb/cockroach/pkg/sql/exec/execgen"
	"github.com/cockroachdb/cockroach/pkg/sql/exec/types"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
)

// Use execgen package to remove unused import warning.
var _ interface{} = execgen.GET

// rehash takes an element of a key (tuple representing a row of equality
// column values) at a given column and computes a new hash by applying a
// transformation to the existing hash.
func (ht *hashTable) rehash(
	ctx context.Context,
	buckets []uint64,
	keyIdx int,
	t types.T,
	col coldata.Vec,
	nKeys uint64,
	sel []uint16,
) {
	switch t {
	case types.Bool:
		keys, nulls := col.Bool(), col.Nulls()
		if col.MaybeHasNulls() {
			if sel != nil {

				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					if nulls.NullAt(uint16(sel[i])) {
						continue
					}
					selIdx := sel[i]
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					x := 0
					if v {
						x = 1
					}
					p = p*31 + uintptr(x)

					buckets[i] = uint64(p)
				}
			} else {

				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					if nulls.NullAt(uint16(i)) {
						continue
					}
					selIdx := i
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					x := 0
					if v {
						x = 1
					}
					p = p*31 + uintptr(x)

					buckets[i] = uint64(p)
				}
			}
		} else {
			if sel != nil {

				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := sel[i]
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					x := 0
					if v {
						x = 1
					}
					p = p*31 + uintptr(x)

					buckets[i] = uint64(p)
				}
			} else {

				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := i
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					x := 0
					if v {
						x = 1
					}
					p = p*31 + uintptr(x)

					buckets[i] = uint64(p)
				}
			}
		}

	case types.Bytes:
		keys, nulls := col.Bytes(), col.Nulls()
		if col.MaybeHasNulls() {
			if sel != nil {

				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					if nulls.NullAt(uint16(sel[i])) {
						continue
					}
					selIdx := sel[i]
					v := keys.Get(int(selIdx))
					p := uintptr(buckets[i])

					sh := (*reflect.SliceHeader)(unsafe.Pointer(&v))
					p = memhash(unsafe.Pointer(sh.Data), p, uintptr(len(v)))

					buckets[i] = uint64(p)
				}
			} else {

				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					if nulls.NullAt(uint16(i)) {
						continue
					}
					selIdx := i
					v := keys.Get(int(selIdx))
					p := uintptr(buckets[i])

					sh := (*reflect.SliceHeader)(unsafe.Pointer(&v))
					p = memhash(unsafe.Pointer(sh.Data), p, uintptr(len(v)))

					buckets[i] = uint64(p)
				}
			}
		} else {
			if sel != nil {

				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := sel[i]
					v := keys.Get(int(selIdx))
					p := uintptr(buckets[i])

					sh := (*reflect.SliceHeader)(unsafe.Pointer(&v))
					p = memhash(unsafe.Pointer(sh.Data), p, uintptr(len(v)))

					buckets[i] = uint64(p)
				}
			} else {

				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := i
					v := keys.Get(int(selIdx))
					p := uintptr(buckets[i])

					sh := (*reflect.SliceHeader)(unsafe.Pointer(&v))
					p = memhash(unsafe.Pointer(sh.Data), p, uintptr(len(v)))

					buckets[i] = uint64(p)
				}
			}
		}

	case types.Decimal:
		keys, nulls := col.Decimal(), col.Nulls()
		if col.MaybeHasNulls() {
			if sel != nil {

				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					if nulls.NullAt(uint16(sel[i])) {
						continue
					}
					selIdx := sel[i]
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					d, err := v.Float64()
					if err != nil {
						panic(fmt.Sprintf("%v", err))
					}

					p = f64hash(noescape(unsafe.Pointer(&d)), p)

					buckets[i] = uint64(p)
				}
			} else {

				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					if nulls.NullAt(uint16(i)) {
						continue
					}
					selIdx := i
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					d, err := v.Float64()
					if err != nil {
						panic(fmt.Sprintf("%v", err))
					}

					p = f64hash(noescape(unsafe.Pointer(&d)), p)

					buckets[i] = uint64(p)
				}
			}
		} else {
			if sel != nil {

				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := sel[i]
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					d, err := v.Float64()
					if err != nil {
						panic(fmt.Sprintf("%v", err))
					}

					p = f64hash(noescape(unsafe.Pointer(&d)), p)

					buckets[i] = uint64(p)
				}
			} else {

				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := i
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])

					d, err := v.Float64()
					if err != nil {
						panic(fmt.Sprintf("%v", err))
					}

					p = f64hash(noescape(unsafe.Pointer(&d)), p)

					buckets[i] = uint64(p)
				}
			}
		}

	case types.Int8:
		keys, nulls := col.Int8(), col.Nulls()
		if col.MaybeHasNulls() {
			if sel != nil {

				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					if nulls.NullAt(uint16(sel[i])) {
						continue
					}
					selIdx := sel[i]
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					p = memhash8(noescape(unsafe.Pointer(&v)), p)
					buckets[i] = uint64(p)
				}
			} else {

				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					if nulls.NullAt(uint16(i)) {
						continue
					}
					selIdx := i
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					p = memhash8(noescape(unsafe.Pointer(&v)), p)
					buckets[i] = uint64(p)
				}
			}
		} else {
			if sel != nil {

				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := sel[i]
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					p = memhash8(noescape(unsafe.Pointer(&v)), p)
					buckets[i] = uint64(p)
				}
			} else {

				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := i
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					p = memhash8(noescape(unsafe.Pointer(&v)), p)
					buckets[i] = uint64(p)
				}
			}
		}

	case types.Int16:
		keys, nulls := col.Int16(), col.Nulls()
		if col.MaybeHasNulls() {
			if sel != nil {

				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					if nulls.NullAt(uint16(sel[i])) {
						continue
					}
					selIdx := sel[i]
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					p = memhash16(noescape(unsafe.Pointer(&v)), p)
					buckets[i] = uint64(p)
				}
			} else {

				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					if nulls.NullAt(uint16(i)) {
						continue
					}
					selIdx := i
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					p = memhash16(noescape(unsafe.Pointer(&v)), p)
					buckets[i] = uint64(p)
				}
			}
		} else {
			if sel != nil {

				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := sel[i]
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					p = memhash16(noescape(unsafe.Pointer(&v)), p)
					buckets[i] = uint64(p)
				}
			} else {

				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := i
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					p = memhash16(noescape(unsafe.Pointer(&v)), p)
					buckets[i] = uint64(p)
				}
			}
		}

	case types.Int32:
		keys, nulls := col.Int32(), col.Nulls()
		if col.MaybeHasNulls() {
			if sel != nil {

				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					if nulls.NullAt(uint16(sel[i])) {
						continue
					}
					selIdx := sel[i]
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					p = memhash32(noescape(unsafe.Pointer(&v)), p)
					buckets[i] = uint64(p)
				}
			} else {

				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					if nulls.NullAt(uint16(i)) {
						continue
					}
					selIdx := i
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					p = memhash32(noescape(unsafe.Pointer(&v)), p)
					buckets[i] = uint64(p)
				}
			}
		} else {
			if sel != nil {

				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := sel[i]
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					p = memhash32(noescape(unsafe.Pointer(&v)), p)
					buckets[i] = uint64(p)
				}
			} else {

				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := i
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					p = memhash32(noescape(unsafe.Pointer(&v)), p)
					buckets[i] = uint64(p)
				}
			}
		}

	case types.Int64:
		keys, nulls := col.Int64(), col.Nulls()
		if col.MaybeHasNulls() {
			if sel != nil {

				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					if nulls.NullAt(uint16(sel[i])) {
						continue
					}
					selIdx := sel[i]
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					p = memhash64(noescape(unsafe.Pointer(&v)), p)
					buckets[i] = uint64(p)
				}
			} else {

				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					if nulls.NullAt(uint16(i)) {
						continue
					}
					selIdx := i
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					p = memhash64(noescape(unsafe.Pointer(&v)), p)
					buckets[i] = uint64(p)
				}
			}
		} else {
			if sel != nil {

				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := sel[i]
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					p = memhash64(noescape(unsafe.Pointer(&v)), p)
					buckets[i] = uint64(p)
				}
			} else {

				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := i
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					p = memhash64(noescape(unsafe.Pointer(&v)), p)
					buckets[i] = uint64(p)
				}
			}
		}

	case types.Float32:
		keys, nulls := col.Float32(), col.Nulls()
		if col.MaybeHasNulls() {
			if sel != nil {

				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					if nulls.NullAt(uint16(sel[i])) {
						continue
					}
					selIdx := sel[i]
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					p = f32hash(noescape(unsafe.Pointer(&v)), p)
					buckets[i] = uint64(p)
				}
			} else {

				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					if nulls.NullAt(uint16(i)) {
						continue
					}
					selIdx := i
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					p = f32hash(noescape(unsafe.Pointer(&v)), p)
					buckets[i] = uint64(p)
				}
			}
		} else {
			if sel != nil {

				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := sel[i]
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					p = f32hash(noescape(unsafe.Pointer(&v)), p)
					buckets[i] = uint64(p)
				}
			} else {

				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := i
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					p = f32hash(noescape(unsafe.Pointer(&v)), p)
					buckets[i] = uint64(p)
				}
			}
		}

	case types.Float64:
		keys, nulls := col.Float64(), col.Nulls()
		if col.MaybeHasNulls() {
			if sel != nil {

				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					if nulls.NullAt(uint16(sel[i])) {
						continue
					}
					selIdx := sel[i]
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					p = f64hash(noescape(unsafe.Pointer(&v)), p)
					buckets[i] = uint64(p)
				}
			} else {

				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					if nulls.NullAt(uint16(i)) {
						continue
					}
					selIdx := i
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					p = f64hash(noescape(unsafe.Pointer(&v)), p)
					buckets[i] = uint64(p)
				}
			}
		} else {
			if sel != nil {

				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := sel[i]
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					p = f64hash(noescape(unsafe.Pointer(&v)), p)
					buckets[i] = uint64(p)
				}
			} else {

				for i := uint64(0); i < nKeys; i++ {
					ht.cancelChecker.check(ctx)
					selIdx := i
					v := keys[int(selIdx)]
					p := uintptr(buckets[i])
					p = f64hash(noescape(unsafe.Pointer(&v)), p)
					buckets[i] = uint64(p)
				}
			}
		}

	default:
		panic(fmt.Sprintf("unhandled type %d", t))
	}
}

// checkCol determines if the current key column in the groupID buckets matches
// the specified equality column key. If there is a match, then the key is added
// to differs. If the bucket has reached the end, the key is rejected. If the
// hashTable disallows null equality, then if any element in the key is null,
// there is no match.
func (ht *hashTable) checkCol(t types.T, keyColIdx int, nToCheck uint16, sel []uint16) {
	switch t {
	case types.Bool:
		buildVec := ht.vals[ht.keyCols[keyColIdx]]
		probeVec := ht.keys[keyColIdx]

		buildKeys := buildVec.Bool()
		probeKeys := probeVec.Bool()

		if sel != nil {

			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.

						probeIsNull := false
						buildIsNull := false
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								/*  */
								probeIsNull = probeVec.Nulls().NullAt(sel[ht.toCheck[i]])
								/*  */

								/*  */
								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
								/*  */

								/*  */
								if probeIsNull && buildIsNull {
									continue
								}
								/*  */
								if probeIsNull {
									ht.groupID[ht.toCheck[i]] = 0
								} else if buildIsNull {
									ht.differs[ht.toCheck[i]] = true
								} else {

									buildVal := buildKeys[int(keyID-1)]
									selIdx := sel[ht.toCheck[i]]
									probeVal := probeKeys[int(selIdx)]
									var unique bool
									unique = tree.CompareBools(buildVal, probeVal) != 0

									if unique {
										ht.differs[ht.toCheck[i]] = true
									}
								}
							}
						}
					} else {

						probeIsNull := false
						buildIsNull := false
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								/*  */
								probeIsNull = probeVec.Nulls().NullAt(sel[ht.toCheck[i]])
								/*  */

								/*  */
								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
								/*  */

								/*  */
								if probeIsNull {
									ht.groupID[ht.toCheck[i]] = 0
								} else if buildIsNull {
									ht.differs[ht.toCheck[i]] = true
								} else {

									buildVal := buildKeys[int(keyID-1)]
									selIdx := sel[ht.toCheck[i]]
									probeVal := probeKeys[int(selIdx)]
									var unique bool
									unique = tree.CompareBools(buildVal, probeVal) != 0

									if unique {
										ht.differs[ht.toCheck[i]] = true
									}
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */
							probeIsNull = probeVec.Nulls().NullAt(sel[ht.toCheck[i]])
							/*  */

							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := sel[ht.toCheck[i]]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = tree.CompareBools(buildVal, probeVal) != 0

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */

							/*  */
							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := sel[ht.toCheck[i]]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = tree.CompareBools(buildVal, probeVal) != 0

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */

							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := sel[ht.toCheck[i]]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = tree.CompareBools(buildVal, probeVal) != 0

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				}
			}
		} else {

			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.

						probeIsNull := false
						buildIsNull := false
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								/*  */
								probeIsNull = probeVec.Nulls().NullAt(ht.toCheck[i])
								/*  */

								/*  */
								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
								/*  */

								/*  */
								if probeIsNull && buildIsNull {
									continue
								}
								/*  */
								if probeIsNull {
									ht.groupID[ht.toCheck[i]] = 0
								} else if buildIsNull {
									ht.differs[ht.toCheck[i]] = true
								} else {

									buildVal := buildKeys[int(keyID-1)]
									selIdx := ht.toCheck[i]
									probeVal := probeKeys[int(selIdx)]
									var unique bool
									unique = tree.CompareBools(buildVal, probeVal) != 0

									if unique {
										ht.differs[ht.toCheck[i]] = true
									}
								}
							}
						}
					} else {

						probeIsNull := false
						buildIsNull := false
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								/*  */
								probeIsNull = probeVec.Nulls().NullAt(ht.toCheck[i])
								/*  */

								/*  */
								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
								/*  */

								/*  */
								if probeIsNull {
									ht.groupID[ht.toCheck[i]] = 0
								} else if buildIsNull {
									ht.differs[ht.toCheck[i]] = true
								} else {

									buildVal := buildKeys[int(keyID-1)]
									selIdx := ht.toCheck[i]
									probeVal := probeKeys[int(selIdx)]
									var unique bool
									unique = tree.CompareBools(buildVal, probeVal) != 0

									if unique {
										ht.differs[ht.toCheck[i]] = true
									}
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */
							probeIsNull = probeVec.Nulls().NullAt(ht.toCheck[i])
							/*  */

							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := ht.toCheck[i]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = tree.CompareBools(buildVal, probeVal) != 0

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */

							/*  */
							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := ht.toCheck[i]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = tree.CompareBools(buildVal, probeVal) != 0

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */

							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := ht.toCheck[i]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = tree.CompareBools(buildVal, probeVal) != 0

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				}
			}
		}
	case types.Bytes:
		buildVec := ht.vals[ht.keyCols[keyColIdx]]
		probeVec := ht.keys[keyColIdx]

		buildKeys := buildVec.Bytes()
		probeKeys := probeVec.Bytes()

		if sel != nil {

			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.

						probeIsNull := false
						buildIsNull := false
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								/*  */
								probeIsNull = probeVec.Nulls().NullAt(sel[ht.toCheck[i]])
								/*  */

								/*  */
								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
								/*  */

								/*  */
								if probeIsNull && buildIsNull {
									continue
								}
								/*  */
								if probeIsNull {
									ht.groupID[ht.toCheck[i]] = 0
								} else if buildIsNull {
									ht.differs[ht.toCheck[i]] = true
								} else {

									buildVal := buildKeys.Get(int(keyID - 1))
									selIdx := sel[ht.toCheck[i]]
									probeVal := probeKeys.Get(int(selIdx))
									var unique bool
									unique = bytes.Compare(buildVal, probeVal) != 0

									if unique {
										ht.differs[ht.toCheck[i]] = true
									}
								}
							}
						}
					} else {

						probeIsNull := false
						buildIsNull := false
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								/*  */
								probeIsNull = probeVec.Nulls().NullAt(sel[ht.toCheck[i]])
								/*  */

								/*  */
								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
								/*  */

								/*  */
								if probeIsNull {
									ht.groupID[ht.toCheck[i]] = 0
								} else if buildIsNull {
									ht.differs[ht.toCheck[i]] = true
								} else {

									buildVal := buildKeys.Get(int(keyID - 1))
									selIdx := sel[ht.toCheck[i]]
									probeVal := probeKeys.Get(int(selIdx))
									var unique bool
									unique = bytes.Compare(buildVal, probeVal) != 0

									if unique {
										ht.differs[ht.toCheck[i]] = true
									}
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */
							probeIsNull = probeVec.Nulls().NullAt(sel[ht.toCheck[i]])
							/*  */

							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys.Get(int(keyID - 1))
								selIdx := sel[ht.toCheck[i]]
								probeVal := probeKeys.Get(int(selIdx))
								var unique bool
								unique = bytes.Compare(buildVal, probeVal) != 0

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */

							/*  */
							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys.Get(int(keyID - 1))
								selIdx := sel[ht.toCheck[i]]
								probeVal := probeKeys.Get(int(selIdx))
								var unique bool
								unique = bytes.Compare(buildVal, probeVal) != 0

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */

							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys.Get(int(keyID - 1))
								selIdx := sel[ht.toCheck[i]]
								probeVal := probeKeys.Get(int(selIdx))
								var unique bool
								unique = bytes.Compare(buildVal, probeVal) != 0

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				}
			}
		} else {

			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.

						probeIsNull := false
						buildIsNull := false
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								/*  */
								probeIsNull = probeVec.Nulls().NullAt(ht.toCheck[i])
								/*  */

								/*  */
								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
								/*  */

								/*  */
								if probeIsNull && buildIsNull {
									continue
								}
								/*  */
								if probeIsNull {
									ht.groupID[ht.toCheck[i]] = 0
								} else if buildIsNull {
									ht.differs[ht.toCheck[i]] = true
								} else {

									buildVal := buildKeys.Get(int(keyID - 1))
									selIdx := ht.toCheck[i]
									probeVal := probeKeys.Get(int(selIdx))
									var unique bool
									unique = bytes.Compare(buildVal, probeVal) != 0

									if unique {
										ht.differs[ht.toCheck[i]] = true
									}
								}
							}
						}
					} else {

						probeIsNull := false
						buildIsNull := false
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								/*  */
								probeIsNull = probeVec.Nulls().NullAt(ht.toCheck[i])
								/*  */

								/*  */
								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
								/*  */

								/*  */
								if probeIsNull {
									ht.groupID[ht.toCheck[i]] = 0
								} else if buildIsNull {
									ht.differs[ht.toCheck[i]] = true
								} else {

									buildVal := buildKeys.Get(int(keyID - 1))
									selIdx := ht.toCheck[i]
									probeVal := probeKeys.Get(int(selIdx))
									var unique bool
									unique = bytes.Compare(buildVal, probeVal) != 0

									if unique {
										ht.differs[ht.toCheck[i]] = true
									}
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */
							probeIsNull = probeVec.Nulls().NullAt(ht.toCheck[i])
							/*  */

							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys.Get(int(keyID - 1))
								selIdx := ht.toCheck[i]
								probeVal := probeKeys.Get(int(selIdx))
								var unique bool
								unique = bytes.Compare(buildVal, probeVal) != 0

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */

							/*  */
							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys.Get(int(keyID - 1))
								selIdx := ht.toCheck[i]
								probeVal := probeKeys.Get(int(selIdx))
								var unique bool
								unique = bytes.Compare(buildVal, probeVal) != 0

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */

							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys.Get(int(keyID - 1))
								selIdx := ht.toCheck[i]
								probeVal := probeKeys.Get(int(selIdx))
								var unique bool
								unique = bytes.Compare(buildVal, probeVal) != 0

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				}
			}
		}
	case types.Decimal:
		buildVec := ht.vals[ht.keyCols[keyColIdx]]
		probeVec := ht.keys[keyColIdx]

		buildKeys := buildVec.Decimal()
		probeKeys := probeVec.Decimal()

		if sel != nil {

			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.

						probeIsNull := false
						buildIsNull := false
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								/*  */
								probeIsNull = probeVec.Nulls().NullAt(sel[ht.toCheck[i]])
								/*  */

								/*  */
								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
								/*  */

								/*  */
								if probeIsNull && buildIsNull {
									continue
								}
								/*  */
								if probeIsNull {
									ht.groupID[ht.toCheck[i]] = 0
								} else if buildIsNull {
									ht.differs[ht.toCheck[i]] = true
								} else {

									buildVal := buildKeys[int(keyID-1)]
									selIdx := sel[ht.toCheck[i]]
									probeVal := probeKeys[int(selIdx)]
									var unique bool
									unique = tree.CompareDecimals(&buildVal, &probeVal) != 0

									if unique {
										ht.differs[ht.toCheck[i]] = true
									}
								}
							}
						}
					} else {

						probeIsNull := false
						buildIsNull := false
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								/*  */
								probeIsNull = probeVec.Nulls().NullAt(sel[ht.toCheck[i]])
								/*  */

								/*  */
								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
								/*  */

								/*  */
								if probeIsNull {
									ht.groupID[ht.toCheck[i]] = 0
								} else if buildIsNull {
									ht.differs[ht.toCheck[i]] = true
								} else {

									buildVal := buildKeys[int(keyID-1)]
									selIdx := sel[ht.toCheck[i]]
									probeVal := probeKeys[int(selIdx)]
									var unique bool
									unique = tree.CompareDecimals(&buildVal, &probeVal) != 0

									if unique {
										ht.differs[ht.toCheck[i]] = true
									}
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */
							probeIsNull = probeVec.Nulls().NullAt(sel[ht.toCheck[i]])
							/*  */

							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := sel[ht.toCheck[i]]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = tree.CompareDecimals(&buildVal, &probeVal) != 0

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */

							/*  */
							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := sel[ht.toCheck[i]]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = tree.CompareDecimals(&buildVal, &probeVal) != 0

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */

							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := sel[ht.toCheck[i]]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = tree.CompareDecimals(&buildVal, &probeVal) != 0

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				}
			}
		} else {

			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.

						probeIsNull := false
						buildIsNull := false
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								/*  */
								probeIsNull = probeVec.Nulls().NullAt(ht.toCheck[i])
								/*  */

								/*  */
								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
								/*  */

								/*  */
								if probeIsNull && buildIsNull {
									continue
								}
								/*  */
								if probeIsNull {
									ht.groupID[ht.toCheck[i]] = 0
								} else if buildIsNull {
									ht.differs[ht.toCheck[i]] = true
								} else {

									buildVal := buildKeys[int(keyID-1)]
									selIdx := ht.toCheck[i]
									probeVal := probeKeys[int(selIdx)]
									var unique bool
									unique = tree.CompareDecimals(&buildVal, &probeVal) != 0

									if unique {
										ht.differs[ht.toCheck[i]] = true
									}
								}
							}
						}
					} else {

						probeIsNull := false
						buildIsNull := false
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								/*  */
								probeIsNull = probeVec.Nulls().NullAt(ht.toCheck[i])
								/*  */

								/*  */
								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
								/*  */

								/*  */
								if probeIsNull {
									ht.groupID[ht.toCheck[i]] = 0
								} else if buildIsNull {
									ht.differs[ht.toCheck[i]] = true
								} else {

									buildVal := buildKeys[int(keyID-1)]
									selIdx := ht.toCheck[i]
									probeVal := probeKeys[int(selIdx)]
									var unique bool
									unique = tree.CompareDecimals(&buildVal, &probeVal) != 0

									if unique {
										ht.differs[ht.toCheck[i]] = true
									}
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */
							probeIsNull = probeVec.Nulls().NullAt(ht.toCheck[i])
							/*  */

							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := ht.toCheck[i]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = tree.CompareDecimals(&buildVal, &probeVal) != 0

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */

							/*  */
							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := ht.toCheck[i]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = tree.CompareDecimals(&buildVal, &probeVal) != 0

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */

							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := ht.toCheck[i]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = tree.CompareDecimals(&buildVal, &probeVal) != 0

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				}
			}
		}
	case types.Int8:
		buildVec := ht.vals[ht.keyCols[keyColIdx]]
		probeVec := ht.keys[keyColIdx]

		buildKeys := buildVec.Int8()
		probeKeys := probeVec.Int8()

		if sel != nil {

			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.

						probeIsNull := false
						buildIsNull := false
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								/*  */
								probeIsNull = probeVec.Nulls().NullAt(sel[ht.toCheck[i]])
								/*  */

								/*  */
								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
								/*  */

								/*  */
								if probeIsNull && buildIsNull {
									continue
								}
								/*  */
								if probeIsNull {
									ht.groupID[ht.toCheck[i]] = 0
								} else if buildIsNull {
									ht.differs[ht.toCheck[i]] = true
								} else {

									buildVal := buildKeys[int(keyID-1)]
									selIdx := sel[ht.toCheck[i]]
									probeVal := probeKeys[int(selIdx)]
									var unique bool
									unique = buildVal != probeVal

									if unique {
										ht.differs[ht.toCheck[i]] = true
									}
								}
							}
						}
					} else {

						probeIsNull := false
						buildIsNull := false
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								/*  */
								probeIsNull = probeVec.Nulls().NullAt(sel[ht.toCheck[i]])
								/*  */

								/*  */
								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
								/*  */

								/*  */
								if probeIsNull {
									ht.groupID[ht.toCheck[i]] = 0
								} else if buildIsNull {
									ht.differs[ht.toCheck[i]] = true
								} else {

									buildVal := buildKeys[int(keyID-1)]
									selIdx := sel[ht.toCheck[i]]
									probeVal := probeKeys[int(selIdx)]
									var unique bool
									unique = buildVal != probeVal

									if unique {
										ht.differs[ht.toCheck[i]] = true
									}
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */
							probeIsNull = probeVec.Nulls().NullAt(sel[ht.toCheck[i]])
							/*  */

							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := sel[ht.toCheck[i]]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = buildVal != probeVal

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */

							/*  */
							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := sel[ht.toCheck[i]]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = buildVal != probeVal

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */

							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := sel[ht.toCheck[i]]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = buildVal != probeVal

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				}
			}
		} else {

			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.

						probeIsNull := false
						buildIsNull := false
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								/*  */
								probeIsNull = probeVec.Nulls().NullAt(ht.toCheck[i])
								/*  */

								/*  */
								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
								/*  */

								/*  */
								if probeIsNull && buildIsNull {
									continue
								}
								/*  */
								if probeIsNull {
									ht.groupID[ht.toCheck[i]] = 0
								} else if buildIsNull {
									ht.differs[ht.toCheck[i]] = true
								} else {

									buildVal := buildKeys[int(keyID-1)]
									selIdx := ht.toCheck[i]
									probeVal := probeKeys[int(selIdx)]
									var unique bool
									unique = buildVal != probeVal

									if unique {
										ht.differs[ht.toCheck[i]] = true
									}
								}
							}
						}
					} else {

						probeIsNull := false
						buildIsNull := false
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								/*  */
								probeIsNull = probeVec.Nulls().NullAt(ht.toCheck[i])
								/*  */

								/*  */
								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
								/*  */

								/*  */
								if probeIsNull {
									ht.groupID[ht.toCheck[i]] = 0
								} else if buildIsNull {
									ht.differs[ht.toCheck[i]] = true
								} else {

									buildVal := buildKeys[int(keyID-1)]
									selIdx := ht.toCheck[i]
									probeVal := probeKeys[int(selIdx)]
									var unique bool
									unique = buildVal != probeVal

									if unique {
										ht.differs[ht.toCheck[i]] = true
									}
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */
							probeIsNull = probeVec.Nulls().NullAt(ht.toCheck[i])
							/*  */

							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := ht.toCheck[i]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = buildVal != probeVal

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */

							/*  */
							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := ht.toCheck[i]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = buildVal != probeVal

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */

							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := ht.toCheck[i]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = buildVal != probeVal

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				}
			}
		}
	case types.Int16:
		buildVec := ht.vals[ht.keyCols[keyColIdx]]
		probeVec := ht.keys[keyColIdx]

		buildKeys := buildVec.Int16()
		probeKeys := probeVec.Int16()

		if sel != nil {

			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.

						probeIsNull := false
						buildIsNull := false
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								/*  */
								probeIsNull = probeVec.Nulls().NullAt(sel[ht.toCheck[i]])
								/*  */

								/*  */
								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
								/*  */

								/*  */
								if probeIsNull && buildIsNull {
									continue
								}
								/*  */
								if probeIsNull {
									ht.groupID[ht.toCheck[i]] = 0
								} else if buildIsNull {
									ht.differs[ht.toCheck[i]] = true
								} else {

									buildVal := buildKeys[int(keyID-1)]
									selIdx := sel[ht.toCheck[i]]
									probeVal := probeKeys[int(selIdx)]
									var unique bool
									unique = buildVal != probeVal

									if unique {
										ht.differs[ht.toCheck[i]] = true
									}
								}
							}
						}
					} else {

						probeIsNull := false
						buildIsNull := false
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								/*  */
								probeIsNull = probeVec.Nulls().NullAt(sel[ht.toCheck[i]])
								/*  */

								/*  */
								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
								/*  */

								/*  */
								if probeIsNull {
									ht.groupID[ht.toCheck[i]] = 0
								} else if buildIsNull {
									ht.differs[ht.toCheck[i]] = true
								} else {

									buildVal := buildKeys[int(keyID-1)]
									selIdx := sel[ht.toCheck[i]]
									probeVal := probeKeys[int(selIdx)]
									var unique bool
									unique = buildVal != probeVal

									if unique {
										ht.differs[ht.toCheck[i]] = true
									}
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */
							probeIsNull = probeVec.Nulls().NullAt(sel[ht.toCheck[i]])
							/*  */

							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := sel[ht.toCheck[i]]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = buildVal != probeVal

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */

							/*  */
							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := sel[ht.toCheck[i]]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = buildVal != probeVal

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */

							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := sel[ht.toCheck[i]]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = buildVal != probeVal

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				}
			}
		} else {

			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.

						probeIsNull := false
						buildIsNull := false
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								/*  */
								probeIsNull = probeVec.Nulls().NullAt(ht.toCheck[i])
								/*  */

								/*  */
								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
								/*  */

								/*  */
								if probeIsNull && buildIsNull {
									continue
								}
								/*  */
								if probeIsNull {
									ht.groupID[ht.toCheck[i]] = 0
								} else if buildIsNull {
									ht.differs[ht.toCheck[i]] = true
								} else {

									buildVal := buildKeys[int(keyID-1)]
									selIdx := ht.toCheck[i]
									probeVal := probeKeys[int(selIdx)]
									var unique bool
									unique = buildVal != probeVal

									if unique {
										ht.differs[ht.toCheck[i]] = true
									}
								}
							}
						}
					} else {

						probeIsNull := false
						buildIsNull := false
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								/*  */
								probeIsNull = probeVec.Nulls().NullAt(ht.toCheck[i])
								/*  */

								/*  */
								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
								/*  */

								/*  */
								if probeIsNull {
									ht.groupID[ht.toCheck[i]] = 0
								} else if buildIsNull {
									ht.differs[ht.toCheck[i]] = true
								} else {

									buildVal := buildKeys[int(keyID-1)]
									selIdx := ht.toCheck[i]
									probeVal := probeKeys[int(selIdx)]
									var unique bool
									unique = buildVal != probeVal

									if unique {
										ht.differs[ht.toCheck[i]] = true
									}
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */
							probeIsNull = probeVec.Nulls().NullAt(ht.toCheck[i])
							/*  */

							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := ht.toCheck[i]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = buildVal != probeVal

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */

							/*  */
							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := ht.toCheck[i]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = buildVal != probeVal

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */

							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := ht.toCheck[i]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = buildVal != probeVal

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				}
			}
		}
	case types.Int32:
		buildVec := ht.vals[ht.keyCols[keyColIdx]]
		probeVec := ht.keys[keyColIdx]

		buildKeys := buildVec.Int32()
		probeKeys := probeVec.Int32()

		if sel != nil {

			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.

						probeIsNull := false
						buildIsNull := false
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								/*  */
								probeIsNull = probeVec.Nulls().NullAt(sel[ht.toCheck[i]])
								/*  */

								/*  */
								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
								/*  */

								/*  */
								if probeIsNull && buildIsNull {
									continue
								}
								/*  */
								if probeIsNull {
									ht.groupID[ht.toCheck[i]] = 0
								} else if buildIsNull {
									ht.differs[ht.toCheck[i]] = true
								} else {

									buildVal := buildKeys[int(keyID-1)]
									selIdx := sel[ht.toCheck[i]]
									probeVal := probeKeys[int(selIdx)]
									var unique bool
									unique = buildVal != probeVal

									if unique {
										ht.differs[ht.toCheck[i]] = true
									}
								}
							}
						}
					} else {

						probeIsNull := false
						buildIsNull := false
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								/*  */
								probeIsNull = probeVec.Nulls().NullAt(sel[ht.toCheck[i]])
								/*  */

								/*  */
								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
								/*  */

								/*  */
								if probeIsNull {
									ht.groupID[ht.toCheck[i]] = 0
								} else if buildIsNull {
									ht.differs[ht.toCheck[i]] = true
								} else {

									buildVal := buildKeys[int(keyID-1)]
									selIdx := sel[ht.toCheck[i]]
									probeVal := probeKeys[int(selIdx)]
									var unique bool
									unique = buildVal != probeVal

									if unique {
										ht.differs[ht.toCheck[i]] = true
									}
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */
							probeIsNull = probeVec.Nulls().NullAt(sel[ht.toCheck[i]])
							/*  */

							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := sel[ht.toCheck[i]]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = buildVal != probeVal

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */

							/*  */
							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := sel[ht.toCheck[i]]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = buildVal != probeVal

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */

							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := sel[ht.toCheck[i]]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = buildVal != probeVal

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				}
			}
		} else {

			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.

						probeIsNull := false
						buildIsNull := false
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								/*  */
								probeIsNull = probeVec.Nulls().NullAt(ht.toCheck[i])
								/*  */

								/*  */
								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
								/*  */

								/*  */
								if probeIsNull && buildIsNull {
									continue
								}
								/*  */
								if probeIsNull {
									ht.groupID[ht.toCheck[i]] = 0
								} else if buildIsNull {
									ht.differs[ht.toCheck[i]] = true
								} else {

									buildVal := buildKeys[int(keyID-1)]
									selIdx := ht.toCheck[i]
									probeVal := probeKeys[int(selIdx)]
									var unique bool
									unique = buildVal != probeVal

									if unique {
										ht.differs[ht.toCheck[i]] = true
									}
								}
							}
						}
					} else {

						probeIsNull := false
						buildIsNull := false
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								/*  */
								probeIsNull = probeVec.Nulls().NullAt(ht.toCheck[i])
								/*  */

								/*  */
								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
								/*  */

								/*  */
								if probeIsNull {
									ht.groupID[ht.toCheck[i]] = 0
								} else if buildIsNull {
									ht.differs[ht.toCheck[i]] = true
								} else {

									buildVal := buildKeys[int(keyID-1)]
									selIdx := ht.toCheck[i]
									probeVal := probeKeys[int(selIdx)]
									var unique bool
									unique = buildVal != probeVal

									if unique {
										ht.differs[ht.toCheck[i]] = true
									}
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */
							probeIsNull = probeVec.Nulls().NullAt(ht.toCheck[i])
							/*  */

							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := ht.toCheck[i]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = buildVal != probeVal

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */

							/*  */
							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := ht.toCheck[i]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = buildVal != probeVal

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */

							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := ht.toCheck[i]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = buildVal != probeVal

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				}
			}
		}
	case types.Int64:
		buildVec := ht.vals[ht.keyCols[keyColIdx]]
		probeVec := ht.keys[keyColIdx]

		buildKeys := buildVec.Int64()
		probeKeys := probeVec.Int64()

		if sel != nil {

			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.

						probeIsNull := false
						buildIsNull := false
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								/*  */
								probeIsNull = probeVec.Nulls().NullAt(sel[ht.toCheck[i]])
								/*  */

								/*  */
								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
								/*  */

								/*  */
								if probeIsNull && buildIsNull {
									continue
								}
								/*  */
								if probeIsNull {
									ht.groupID[ht.toCheck[i]] = 0
								} else if buildIsNull {
									ht.differs[ht.toCheck[i]] = true
								} else {

									buildVal := buildKeys[int(keyID-1)]
									selIdx := sel[ht.toCheck[i]]
									probeVal := probeKeys[int(selIdx)]
									var unique bool
									unique = buildVal != probeVal

									if unique {
										ht.differs[ht.toCheck[i]] = true
									}
								}
							}
						}
					} else {

						probeIsNull := false
						buildIsNull := false
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								/*  */
								probeIsNull = probeVec.Nulls().NullAt(sel[ht.toCheck[i]])
								/*  */

								/*  */
								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
								/*  */

								/*  */
								if probeIsNull {
									ht.groupID[ht.toCheck[i]] = 0
								} else if buildIsNull {
									ht.differs[ht.toCheck[i]] = true
								} else {

									buildVal := buildKeys[int(keyID-1)]
									selIdx := sel[ht.toCheck[i]]
									probeVal := probeKeys[int(selIdx)]
									var unique bool
									unique = buildVal != probeVal

									if unique {
										ht.differs[ht.toCheck[i]] = true
									}
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */
							probeIsNull = probeVec.Nulls().NullAt(sel[ht.toCheck[i]])
							/*  */

							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := sel[ht.toCheck[i]]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = buildVal != probeVal

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */

							/*  */
							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := sel[ht.toCheck[i]]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = buildVal != probeVal

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */

							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := sel[ht.toCheck[i]]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = buildVal != probeVal

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				}
			}
		} else {

			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.

						probeIsNull := false
						buildIsNull := false
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								/*  */
								probeIsNull = probeVec.Nulls().NullAt(ht.toCheck[i])
								/*  */

								/*  */
								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
								/*  */

								/*  */
								if probeIsNull && buildIsNull {
									continue
								}
								/*  */
								if probeIsNull {
									ht.groupID[ht.toCheck[i]] = 0
								} else if buildIsNull {
									ht.differs[ht.toCheck[i]] = true
								} else {

									buildVal := buildKeys[int(keyID-1)]
									selIdx := ht.toCheck[i]
									probeVal := probeKeys[int(selIdx)]
									var unique bool
									unique = buildVal != probeVal

									if unique {
										ht.differs[ht.toCheck[i]] = true
									}
								}
							}
						}
					} else {

						probeIsNull := false
						buildIsNull := false
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								/*  */
								probeIsNull = probeVec.Nulls().NullAt(ht.toCheck[i])
								/*  */

								/*  */
								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
								/*  */

								/*  */
								if probeIsNull {
									ht.groupID[ht.toCheck[i]] = 0
								} else if buildIsNull {
									ht.differs[ht.toCheck[i]] = true
								} else {

									buildVal := buildKeys[int(keyID-1)]
									selIdx := ht.toCheck[i]
									probeVal := probeKeys[int(selIdx)]
									var unique bool
									unique = buildVal != probeVal

									if unique {
										ht.differs[ht.toCheck[i]] = true
									}
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */
							probeIsNull = probeVec.Nulls().NullAt(ht.toCheck[i])
							/*  */

							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := ht.toCheck[i]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = buildVal != probeVal

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */

							/*  */
							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := ht.toCheck[i]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = buildVal != probeVal

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */

							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := ht.toCheck[i]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = buildVal != probeVal

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				}
			}
		}
	case types.Float32:
		buildVec := ht.vals[ht.keyCols[keyColIdx]]
		probeVec := ht.keys[keyColIdx]

		buildKeys := buildVec.Float32()
		probeKeys := probeVec.Float32()

		if sel != nil {

			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.

						probeIsNull := false
						buildIsNull := false
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								/*  */
								probeIsNull = probeVec.Nulls().NullAt(sel[ht.toCheck[i]])
								/*  */

								/*  */
								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
								/*  */

								/*  */
								if probeIsNull && buildIsNull {
									continue
								}
								/*  */
								if probeIsNull {
									ht.groupID[ht.toCheck[i]] = 0
								} else if buildIsNull {
									ht.differs[ht.toCheck[i]] = true
								} else {

									buildVal := buildKeys[int(keyID-1)]
									selIdx := sel[ht.toCheck[i]]
									probeVal := probeKeys[int(selIdx)]
									var unique bool
									unique = compareFloats(float64(buildVal), float64(probeVal)) != 0

									if unique {
										ht.differs[ht.toCheck[i]] = true
									}
								}
							}
						}
					} else {

						probeIsNull := false
						buildIsNull := false
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								/*  */
								probeIsNull = probeVec.Nulls().NullAt(sel[ht.toCheck[i]])
								/*  */

								/*  */
								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
								/*  */

								/*  */
								if probeIsNull {
									ht.groupID[ht.toCheck[i]] = 0
								} else if buildIsNull {
									ht.differs[ht.toCheck[i]] = true
								} else {

									buildVal := buildKeys[int(keyID-1)]
									selIdx := sel[ht.toCheck[i]]
									probeVal := probeKeys[int(selIdx)]
									var unique bool
									unique = compareFloats(float64(buildVal), float64(probeVal)) != 0

									if unique {
										ht.differs[ht.toCheck[i]] = true
									}
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */
							probeIsNull = probeVec.Nulls().NullAt(sel[ht.toCheck[i]])
							/*  */

							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := sel[ht.toCheck[i]]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = compareFloats(float64(buildVal), float64(probeVal)) != 0

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */

							/*  */
							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := sel[ht.toCheck[i]]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = compareFloats(float64(buildVal), float64(probeVal)) != 0

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */

							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := sel[ht.toCheck[i]]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = compareFloats(float64(buildVal), float64(probeVal)) != 0

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				}
			}
		} else {

			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.

						probeIsNull := false
						buildIsNull := false
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								/*  */
								probeIsNull = probeVec.Nulls().NullAt(ht.toCheck[i])
								/*  */

								/*  */
								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
								/*  */

								/*  */
								if probeIsNull && buildIsNull {
									continue
								}
								/*  */
								if probeIsNull {
									ht.groupID[ht.toCheck[i]] = 0
								} else if buildIsNull {
									ht.differs[ht.toCheck[i]] = true
								} else {

									buildVal := buildKeys[int(keyID-1)]
									selIdx := ht.toCheck[i]
									probeVal := probeKeys[int(selIdx)]
									var unique bool
									unique = compareFloats(float64(buildVal), float64(probeVal)) != 0

									if unique {
										ht.differs[ht.toCheck[i]] = true
									}
								}
							}
						}
					} else {

						probeIsNull := false
						buildIsNull := false
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								/*  */
								probeIsNull = probeVec.Nulls().NullAt(ht.toCheck[i])
								/*  */

								/*  */
								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
								/*  */

								/*  */
								if probeIsNull {
									ht.groupID[ht.toCheck[i]] = 0
								} else if buildIsNull {
									ht.differs[ht.toCheck[i]] = true
								} else {

									buildVal := buildKeys[int(keyID-1)]
									selIdx := ht.toCheck[i]
									probeVal := probeKeys[int(selIdx)]
									var unique bool
									unique = compareFloats(float64(buildVal), float64(probeVal)) != 0

									if unique {
										ht.differs[ht.toCheck[i]] = true
									}
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */
							probeIsNull = probeVec.Nulls().NullAt(ht.toCheck[i])
							/*  */

							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := ht.toCheck[i]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = compareFloats(float64(buildVal), float64(probeVal)) != 0

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */

							/*  */
							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := ht.toCheck[i]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = compareFloats(float64(buildVal), float64(probeVal)) != 0

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */

							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := ht.toCheck[i]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = compareFloats(float64(buildVal), float64(probeVal)) != 0

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				}
			}
		}
	case types.Float64:
		buildVec := ht.vals[ht.keyCols[keyColIdx]]
		probeVec := ht.keys[keyColIdx]

		buildKeys := buildVec.Float64()
		probeKeys := probeVec.Float64()

		if sel != nil {

			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.

						probeIsNull := false
						buildIsNull := false
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								/*  */
								probeIsNull = probeVec.Nulls().NullAt(sel[ht.toCheck[i]])
								/*  */

								/*  */
								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
								/*  */

								/*  */
								if probeIsNull && buildIsNull {
									continue
								}
								/*  */
								if probeIsNull {
									ht.groupID[ht.toCheck[i]] = 0
								} else if buildIsNull {
									ht.differs[ht.toCheck[i]] = true
								} else {

									buildVal := buildKeys[int(keyID-1)]
									selIdx := sel[ht.toCheck[i]]
									probeVal := probeKeys[int(selIdx)]
									var unique bool
									unique = compareFloats(float64(buildVal), float64(probeVal)) != 0

									if unique {
										ht.differs[ht.toCheck[i]] = true
									}
								}
							}
						}
					} else {

						probeIsNull := false
						buildIsNull := false
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								/*  */
								probeIsNull = probeVec.Nulls().NullAt(sel[ht.toCheck[i]])
								/*  */

								/*  */
								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
								/*  */

								/*  */
								if probeIsNull {
									ht.groupID[ht.toCheck[i]] = 0
								} else if buildIsNull {
									ht.differs[ht.toCheck[i]] = true
								} else {

									buildVal := buildKeys[int(keyID-1)]
									selIdx := sel[ht.toCheck[i]]
									probeVal := probeKeys[int(selIdx)]
									var unique bool
									unique = compareFloats(float64(buildVal), float64(probeVal)) != 0

									if unique {
										ht.differs[ht.toCheck[i]] = true
									}
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */
							probeIsNull = probeVec.Nulls().NullAt(sel[ht.toCheck[i]])
							/*  */

							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := sel[ht.toCheck[i]]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = compareFloats(float64(buildVal), float64(probeVal)) != 0

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */

							/*  */
							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := sel[ht.toCheck[i]]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = compareFloats(float64(buildVal), float64(probeVal)) != 0

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */

							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := sel[ht.toCheck[i]]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = compareFloats(float64(buildVal), float64(probeVal)) != 0

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				}
			}
		} else {

			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.

						probeIsNull := false
						buildIsNull := false
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								/*  */
								probeIsNull = probeVec.Nulls().NullAt(ht.toCheck[i])
								/*  */

								/*  */
								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
								/*  */

								/*  */
								if probeIsNull && buildIsNull {
									continue
								}
								/*  */
								if probeIsNull {
									ht.groupID[ht.toCheck[i]] = 0
								} else if buildIsNull {
									ht.differs[ht.toCheck[i]] = true
								} else {

									buildVal := buildKeys[int(keyID-1)]
									selIdx := ht.toCheck[i]
									probeVal := probeKeys[int(selIdx)]
									var unique bool
									unique = compareFloats(float64(buildVal), float64(probeVal)) != 0

									if unique {
										ht.differs[ht.toCheck[i]] = true
									}
								}
							}
						}
					} else {

						probeIsNull := false
						buildIsNull := false
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								/*  */
								probeIsNull = probeVec.Nulls().NullAt(ht.toCheck[i])
								/*  */

								/*  */
								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
								/*  */

								/*  */
								if probeIsNull {
									ht.groupID[ht.toCheck[i]] = 0
								} else if buildIsNull {
									ht.differs[ht.toCheck[i]] = true
								} else {

									buildVal := buildKeys[int(keyID-1)]
									selIdx := ht.toCheck[i]
									probeVal := probeKeys[int(selIdx)]
									var unique bool
									unique = compareFloats(float64(buildVal), float64(probeVal)) != 0

									if unique {
										ht.differs[ht.toCheck[i]] = true
									}
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */
							probeIsNull = probeVec.Nulls().NullAt(ht.toCheck[i])
							/*  */

							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := ht.toCheck[i]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = compareFloats(float64(buildVal), float64(probeVal)) != 0

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */

							/*  */
							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)
							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := ht.toCheck[i]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = compareFloats(float64(buildVal), float64(probeVal)) != 0

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				} else {

					probeIsNull := false
					buildIsNull := false
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						if keyID := ht.groupID[ht.toCheck[i]]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							/*  */

							/*  */

							/*  */
							if probeIsNull {
								ht.groupID[ht.toCheck[i]] = 0
							} else if buildIsNull {
								ht.differs[ht.toCheck[i]] = true
							} else {

								buildVal := buildKeys[int(keyID-1)]
								selIdx := ht.toCheck[i]
								probeVal := probeKeys[int(selIdx)]
								var unique bool
								unique = compareFloats(float64(buildVal), float64(probeVal)) != 0

								if unique {
									ht.differs[ht.toCheck[i]] = true
								}
							}
						}
					}
				}
			}
		}
	default:
		panic(fmt.Sprintf("unhandled type %d", t))
	}
}

// collect prepares the buildIdx and probeIdx arrays where the buildIdx and
// probeIdx at each index are joined to make an output row. The total number of
// resulting rows is returned.
func (prober *hashJoinProber) collect(batch coldata.Batch, batchSize uint16, sel []uint16) uint16 {
	nResults := uint16(0)

	if prober.spec.outer {
		if sel != nil {

			for i := uint16(0); i < batchSize; i++ {
				currentID := prober.ht.headID[i]

				if currentID == 0 {
					prober.probeRowUnmatched[nResults] = true
				}

				for {
					if nResults >= coldata.BatchSize {
						prober.prevBatch = batch
						return nResults
					}

					prober.buildIdx[nResults] = currentID - 1
					prober.probeIdx[nResults] = sel[i]
					currentID = prober.ht.same[currentID]
					prober.ht.headID[i] = currentID
					nResults++

					if currentID == 0 {
						break
					}
				}
			}
		} else {

			for i := uint16(0); i < batchSize; i++ {
				currentID := prober.ht.headID[i]

				if currentID == 0 {
					prober.probeRowUnmatched[nResults] = true
				}

				for {
					if nResults >= coldata.BatchSize {
						prober.prevBatch = batch
						return nResults
					}

					prober.buildIdx[nResults] = currentID - 1
					prober.probeIdx[nResults] = i
					currentID = prober.ht.same[currentID]
					prober.ht.headID[i] = currentID
					nResults++

					if currentID == 0 {
						break
					}
				}
			}
		}
	} else {
		if sel != nil {

			for i := uint16(0); i < batchSize; i++ {
				currentID := prober.ht.headID[i]
				for currentID != 0 {
					if nResults >= coldata.BatchSize {
						prober.prevBatch = batch
						return nResults
					}

					prober.buildIdx[nResults] = currentID - 1
					prober.probeIdx[nResults] = sel[i]
					currentID = prober.ht.same[currentID]
					prober.ht.headID[i] = currentID
					nResults++
				}
			}
		} else {

			for i := uint16(0); i < batchSize; i++ {
				currentID := prober.ht.headID[i]
				for currentID != 0 {
					if nResults >= coldata.BatchSize {
						prober.prevBatch = batch
						return nResults
					}

					prober.buildIdx[nResults] = currentID - 1
					prober.probeIdx[nResults] = i
					currentID = prober.ht.same[currentID]
					prober.ht.headID[i] = currentID
					nResults++
				}
			}
		}
	}

	return nResults
}

// distinctCollect prepares the batch with the joined output columns where the build
// row index for each probe row is given in the groupID slice. This function
// requires assumes a N-1 hash join.
func (prober *hashJoinProber) distinctCollect(
	batch coldata.Batch, batchSize uint16, sel []uint16,
) uint16 {
	nResults := uint16(0)

	if prober.spec.outer {
		nResults = batchSize

		if sel != nil {

			for i := uint16(0); i < batchSize; i++ {
				// Index of keys and outputs in the hash table is calculated as ID - 1.
				prober.buildIdx[i] = prober.ht.groupID[i] - 1
				prober.probeIdx[i] = sel[i]

				prober.probeRowUnmatched[i] = prober.ht.groupID[i] == 0
			}
		} else {

			for i := uint16(0); i < batchSize; i++ {
				// Index of keys and outputs in the hash table is calculated as ID - 1.
				prober.buildIdx[i] = prober.ht.groupID[i] - 1
				prober.probeIdx[i] = i

				prober.probeRowUnmatched[i] = prober.ht.groupID[i] == 0
			}
		}
	} else {
		if sel != nil {

			for i := uint16(0); i < batchSize; i++ {
				if prober.ht.groupID[i] != 0 {
					// Index of keys and outputs in the hash table is calculated as ID - 1.
					prober.buildIdx[nResults] = prober.ht.groupID[i] - 1
					prober.probeIdx[nResults] = sel[i]
					nResults++
				}
			}
		} else {

			for i := uint16(0); i < batchSize; i++ {
				if prober.ht.groupID[i] != 0 {
					// Index of keys and outputs in the hash table is calculated as ID - 1.
					prober.buildIdx[nResults] = prober.ht.groupID[i] - 1
					prober.probeIdx[nResults] = i
					nResults++
				}
			}
		}
	}

	return nResults
}
