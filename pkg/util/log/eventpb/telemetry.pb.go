// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: util/log/eventpb/telemetry.proto

package eventpb

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	descpb "github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb"
	logpb "github.com/cockroachdb/cockroach/pkg/util/log/logpb"
	github_com_cockroachdb_redact "github.com/cockroachdb/redact"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// SampledQuery is the SQL query event logged to the telemetry channel. It
// contains common SQL event/execution details.
type SampledQuery struct {
	logpb.CommonEventDetails `protobuf:"bytes,1,opt,name=common,proto3,embedded=common" json:""`
	CommonSQLEventDetails    `protobuf:"bytes,2,opt,name=sql,proto3,embedded=sql" json:""`
	CommonSQLExecDetails     `protobuf:"bytes,3,opt,name=exec,proto3,embedded=exec" json:""`
	// skipped_queries indicate how many SQL statements were not
	// considered for sampling prior to this one. If the field is
	// omitted, or its value is zero, this indicates that no statement
	// was omitted since the last event.
	SkippedQueries uint64 `protobuf:"varint,4,opt,name=skipped_queries,json=skippedQueries,proto3" json:",omitempty"`
	// Cost of the query as estimated by the optimizer.
	CostEstimate float64 `protobuf:"fixed64,5,opt,name=cost_estimate,json=costEstimate,proto3" json:",omitempty"`
	// The distribution of the DistSQL query plan (local, full, or partial).
	Distribution string `protobuf:"bytes,6,opt,name=distribution,proto3" json:",omitempty" redact:"nonsensitive"`
	// The query's plan gist bytes as a base64 encoded string.
	PlanGist string `protobuf:"bytes,7,opt,name=plan_gist,json=planGist,proto3" json:",omitempty" redact:"nonsensitive"`
	// SessionID is the ID of the session that initiated the query.
	SessionID string `protobuf:"bytes,8,opt,name=session_id,json=sessionId,proto3" json:",omitempty" redact:"nonsensitive"`
	// Name of the database that initiated the query.
	Database string `protobuf:"bytes,9,opt,name=database,proto3" json:",omitempty" redact:"nonsensitive"`
	// Statement ID of the query.
	StatementID string `protobuf:"bytes,10,opt,name=statement_id,json=statementId,proto3" json:",omitempty" redact:"nonsensitive"`
	// Transaction ID of the query.
	TransactionID string `protobuf:"bytes,11,opt,name=transaction_id,json=transactionId,proto3" json:",omitempty" redact:"nonsensitive"`
	// Statement fingerprint ID of the query.
	StatementFingerprintID uint64 `protobuf:"varint,13,opt,name=statement_fingerprint_id,json=statementFingerprintId,proto3" json:",omitempty"`
	// Maximum number of rows scanned by a full scan, as estimated by the
	// optimizer.
	MaxFullScanRowsEstimate float64 `protobuf:"fixed64,14,opt,name=max_full_scan_rows_estimate,json=maxFullScanRowsEstimate,proto3" json:",omitempty"`
	// Total number of rows read by all scans in the query, as estimated by the
	// optimizer.
	TotalScanRowsEstimate float64 `protobuf:"fixed64,15,opt,name=total_scan_rows_estimate,json=totalScanRowsEstimate,proto3" json:",omitempty"`
	// The number of rows output by the query, as estimated by the optimizer.
	OutputRowsEstimate float64 `protobuf:"fixed64,16,opt,name=output_rows_estimate,json=outputRowsEstimate,proto3" json:",omitempty"`
	// Whether table statistics were available to the optimizer when planning the
	// query.
	StatsAvailable bool `protobuf:"varint,17,opt,name=stats_available,json=statsAvailable,proto3" json:",omitempty"`
	// The maximum number of nanoseconds that have passed since stats were
	// collected on any table scanned by this query.
	NanosSinceStatsCollected int64 `protobuf:"varint,18,opt,name=nanos_since_stats_collected,json=nanosSinceStatsCollected,proto3" json:",omitempty"`
	// The number of bytes read from disk.
	BytesRead int64 `protobuf:"varint,19,opt,name=bytes_read,json=bytesRead,proto3" json:",omitempty"`
	// The number of rows read from disk.
	RowsRead int64 `protobuf:"varint,20,opt,name=rows_read,json=rowsRead,proto3" json:",omitempty"`
	// The number of rows written.
	RowsWritten int64 `protobuf:"varint,21,opt,name=rows_written,json=rowsWritten,proto3" json:",omitempty"`
	// The number of inner joins in the query plan.
	InnerJoinCount int64 `protobuf:"varint,22,opt,name=inner_join_count,json=innerJoinCount,proto3" json:",omitempty"`
	// The number of left (or right) outer joins in the query plan.
	LeftOuterJoinCount int64 `protobuf:"varint,23,opt,name=left_outer_join_count,json=leftOuterJoinCount,proto3" json:",omitempty"`
	// The number of full outer joins in the query plan.
	FullOuterJoinCount int64 `protobuf:"varint,24,opt,name=full_outer_join_count,json=fullOuterJoinCount,proto3" json:",omitempty"`
	// The number of semi joins in the query plan.
	SemiJoinCount int64 `protobuf:"varint,25,opt,name=semi_join_count,json=semiJoinCount,proto3" json:",omitempty"`
	// The number of anti joins in the query plan.
	AntiJoinCount int64 `protobuf:"varint,26,opt,name=anti_join_count,json=antiJoinCount,proto3" json:",omitempty"`
	// The number of intersect all joins in the query plan.
	IntersectAllJoinCount int64 `protobuf:"varint,27,opt,name=intersect_all_join_count,json=intersectAllJoinCount,proto3" json:",omitempty"`
	// The number of except all joins in the query plan.
	ExceptAllJoinCount int64 `protobuf:"varint,28,opt,name=except_all_join_count,json=exceptAllJoinCount,proto3" json:",omitempty"`
	// The number of hash joins in the query plan.
	HashJoinCount int64 `protobuf:"varint,29,opt,name=hash_join_count,json=hashJoinCount,proto3" json:",omitempty"`
	// The number of cross joins in the query plan.
	CrossJoinCount int64 `protobuf:"varint,30,opt,name=cross_join_count,json=crossJoinCount,proto3" json:",omitempty"`
	// The number of index joins in the query plan.
	IndexJoinCount int64 `protobuf:"varint,31,opt,name=index_join_count,json=indexJoinCount,proto3" json:",omitempty"`
	// The number of lookup joins in the query plan.
	LookupJoinCount int64 `protobuf:"varint,32,opt,name=lookup_join_count,json=lookupJoinCount,proto3" json:",omitempty"`
	// The number of merge joins in the query plan.
	MergeJoinCount int64 `protobuf:"varint,33,opt,name=merge_join_count,json=mergeJoinCount,proto3" json:",omitempty"`
	// The number of inverted joins in the query plan.
	InvertedJoinCount int64 `protobuf:"varint,34,opt,name=inverted_join_count,json=invertedJoinCount,proto3" json:",omitempty"`
	// The number of apply joins in the query plan.
	ApplyJoinCount int64 `protobuf:"varint,35,opt,name=apply_join_count,json=applyJoinCount,proto3" json:",omitempty"`
	// The number of zig zag joins in the query plan.
	ZigZagJoinCount int64 `protobuf:"varint,36,opt,name=zig_zag_join_count,json=zigZagJoinCount,proto3" json:",omitempty"`
}

func (m *SampledQuery) Reset()         { *m = SampledQuery{} }
func (m *SampledQuery) String() string { return proto.CompactTextString(m) }
func (*SampledQuery) ProtoMessage()    {}
func (*SampledQuery) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d317b4ad74be4f7, []int{0}
}
func (m *SampledQuery) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SampledQuery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SampledQuery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SampledQuery.Merge(m, src)
}
func (m *SampledQuery) XXX_Size() int {
	return m.Size()
}
func (m *SampledQuery) XXX_DiscardUnknown() {
	xxx_messageInfo_SampledQuery.DiscardUnknown(m)
}

var xxx_messageInfo_SampledQuery proto.InternalMessageInfo

// CapturedIndexUsageStats
type CapturedIndexUsageStats struct {
	logpb.CommonEventDetails `protobuf:"bytes,1,opt,name=common,proto3,embedded=common" json:""`
	// TotalReadCount is the number of times this index has been read from.
	TotalReadCount uint64 `protobuf:"varint,2,opt,name=total_read_count,json=totalReadCount,proto3" json:"total_read_count,omitempty"`
	// LastRead is the timestamp that this index was last being read from.
	LastRead string `protobuf:"bytes,3,opt,name=last_read,json=lastRead,proto3" json:",omitempty" redact:"nonsensitive"`
	// TableID is the ID of the table this index is created on. This is same as
	// descpb.TableID and is unique within the cluster.
	TableID uint32 `protobuf:"varint,4,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	// IndexID is the ID of the index within the scope of the given table.
	IndexID      uint32 `protobuf:"varint,5,opt,name=index_id,json=indexId,proto3" json:"index_id,omitempty"`
	DatabaseName string `protobuf:"bytes,6,opt,name=database_name,json=databaseName,proto3" json:",omitempty" redact:"nonsensitive"`
	TableName    string `protobuf:"bytes,7,opt,name=table_name,json=tableName,proto3" json:",omitempty" redact:"nonsensitive"`
	IndexName    string `protobuf:"bytes,8,opt,name=index_name,json=indexName,proto3" json:",omitempty" redact:"nonsensitive"`
	IndexType    string `protobuf:"bytes,9,opt,name=index_type,json=indexType,proto3" json:",omitempty" redact:"nonsensitive"`
	IsUnique     bool   `protobuf:"varint,10,opt,name=is_unique,json=isUnique,proto3" json:",omitempty"`
	IsInverted   bool   `protobuf:"varint,11,opt,name=is_inverted,json=isInverted,proto3" json:",omitempty"`
}

func (m *CapturedIndexUsageStats) Reset()         { *m = CapturedIndexUsageStats{} }
func (m *CapturedIndexUsageStats) String() string { return proto.CompactTextString(m) }
func (*CapturedIndexUsageStats) ProtoMessage()    {}
func (*CapturedIndexUsageStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d317b4ad74be4f7, []int{1}
}
func (m *CapturedIndexUsageStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CapturedIndexUsageStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CapturedIndexUsageStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CapturedIndexUsageStats.Merge(m, src)
}
func (m *CapturedIndexUsageStats) XXX_Size() int {
	return m.Size()
}
func (m *CapturedIndexUsageStats) XXX_DiscardUnknown() {
	xxx_messageInfo_CapturedIndexUsageStats.DiscardUnknown(m)
}

var xxx_messageInfo_CapturedIndexUsageStats proto.InternalMessageInfo

// CreateChangefeed is an event for any CREATE CHANGEFEED query that
// successfully starts running.  Failed CREATE statements will show up as
// ChangefeedFailed events.
type CreateChangefeed struct {
	CommonChangefeedEventDetails `protobuf:"bytes,1,opt,name=common,proto3,embedded=common" json:""`
}

func (m *CreateChangefeed) Reset()         { *m = CreateChangefeed{} }
func (m *CreateChangefeed) String() string { return proto.CompactTextString(m) }
func (*CreateChangefeed) ProtoMessage()    {}
func (*CreateChangefeed) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d317b4ad74be4f7, []int{2}
}
func (m *CreateChangefeed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateChangefeed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateChangefeed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateChangefeed.Merge(m, src)
}
func (m *CreateChangefeed) XXX_Size() int {
	return m.Size()
}
func (m *CreateChangefeed) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateChangefeed.DiscardUnknown(m)
}

var xxx_messageInfo_CreateChangefeed proto.InternalMessageInfo

// ChangefeedFailed is an event for any Changefeed failure since the plan hook
// was triggered.
type ChangefeedFailed struct {
	CommonChangefeedEventDetails `protobuf:"bytes,1,opt,name=common,proto3,embedded=common" json:""`
	// The reason / environment with which the changefeed failed (ex:
	// connection_closed, changefeed_behind)
	FailureType string `protobuf:"bytes,2,opt,name=failure_type,json=failureType,proto3" json:",omitempty" redact:"nonsensitive"`
}

func (m *ChangefeedFailed) Reset()         { *m = ChangefeedFailed{} }
func (m *ChangefeedFailed) String() string { return proto.CompactTextString(m) }
func (*ChangefeedFailed) ProtoMessage()    {}
func (*ChangefeedFailed) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d317b4ad74be4f7, []int{3}
}
func (m *ChangefeedFailed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangefeedFailed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ChangefeedFailed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangefeedFailed.Merge(m, src)
}
func (m *ChangefeedFailed) XXX_Size() int {
	return m.Size()
}
func (m *ChangefeedFailed) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangefeedFailed.DiscardUnknown(m)
}

var xxx_messageInfo_ChangefeedFailed proto.InternalMessageInfo

// RecoveryEvent is an event that is logged on every invocation of BACKUP,
// RESTORE, and on every BACKUP schedule creation, with the appropriate subset
// of fields populated depending on the type of event. This event is is also
// logged whenever a BACKUP and RESTORE job completes or fails.
type RecoveryEvent struct {
	// Common fields for all events.
	logpb.CommonEventDetails `protobuf:"bytes,1,opt,name=common,proto3,embedded=common" json:""`
	// RecoveryType is the type of recovery described by this event, which is one of
	// - backup
	// - scheduled_backup
	// - create_schedule
	// - restore
	//
	// It can also be a job event corresponding to the recovery, which is one of
	// - backup_job
	// - scheduled_backup_job
	// - restore_job
	RecoveryType RecoveryEventType `protobuf:"bytes,2,opt,name=recovery_type,json=recoveryType,proto3,customtype=RecoveryEventType" json:",omitempty" redact:"nonsensitive"`
	// TargetScope is the largest scope of the targets that the user is backing up
	// or restoring based on the following order:
	// table < schema < database < full cluster.
	TargetScope string `protobuf:"bytes,3,opt,name=target_scope,json=targetScope,proto3" json:",omitempty" redact:"nonsensitive"`
	// IsMultiregionTarget is true if any of the targets contain objects with
	// multi-region primitives.
	IsMultiregionTarget bool `protobuf:"varint,4,opt,name=is_multiregion_target,json=isMultiregionTarget,proto3" json:",omitempty"`
	// TargetCount is the number of targets the in the BACKUP/RESTORE.
	TargetCount uint32 `protobuf:"varint,5,opt,name=target_count,json=targetCount,proto3" json:",omitempty"`
	// DestinationSubdirType is
	// - latest: if using the latest subdir
	// - standard: if using a date-based subdir
	// - custom: if using a custom subdir that's not date-based
	DestinationSubdirType string `protobuf:"bytes,6,opt,name=destination_subdir_type,json=destinationSubdirType,proto3" json:",omitempty" redact:"nonsensitive"`
	// DestinationStorageTypes are the types of storage that the user is backing
	// up to or restoring from.
	DestinationStorageTypes []string `protobuf:"bytes,7,rep,name=destination_storage_types,json=destinationStorageTypes,proto3" json:",omitempty" redact:"nonsensitive"`
	// DestinationAuthTypes are the types of authentication methods that the user
	// is using to access the destination storage.
	DestinationAuthTypes []string `protobuf:"bytes,8,rep,name=destination_auth_types,json=destinationAuthTypes,proto3" json:",omitempty" redact:"nonsensitive"`
	// IsLocalityAware indicates if the BACKUP or RESTORE is locality aware.
	IsLocalityAware bool `protobuf:"varint,9,opt,name=is_locality_aware,json=isLocalityAware,proto3" json:",omitempty"`
	// AsOfInterval is the time interval in nanoseconds between the statement
	// timestamp and the timestamp resolved by the AS OF SYSTEM TIME expression.
	// The interval is expressed in nanoseconds.
	AsOfInterval int64 `protobuf:"varint,10,opt,name=as_of_interval,json=asOfInterval,proto3" json:",omitempty"`
	// WithRevisionHistory is true if the BACKUP includes revision history.
	WithRevisionHistory bool `protobuf:"varint,11,opt,name=with_revision_history,json=withRevisionHistory,proto3" json:",omitempty"`
	// HasEncryptionPassphrase is true if the user provided an encryption
	// passphrase to encrypt/decrypt their backup.
	HasEncryptionPassphrase bool `protobuf:"varint,13,opt,name=has_encryption_passphrase,json=hasEncryptionPassphrase,proto3" json:",omitempty"`
	// KMSType is the type of KMS the user is using to encrypt/decrypt their
	// backup.
	KMSType string `protobuf:"bytes,14,opt,name=kms_type,json=kmsType,proto3" json:",omitempty" redact:"nonsensitive"`
	// KMSCount is the number of KMS the user is using.
	KMSCount uint32 `protobuf:"varint,15,opt,name=kms_count,json=kmsCount,proto3" json:",omitempty"`
	// Options contain all the names of the options specified by the user in the
	// BACKUP or RESTORE statement. For options that are accompanied by a value,
	// only those with non-empty values will be present.
	//
	// It's important to note that there are no option values anywhere in the
	// event payload. Future changes to telemetry should refrain from adding
	// values to the payload unless they are properly redacted.
	Options []string `protobuf:"bytes,16,rep,name=options,proto3" json:",omitempty" redact:"nonsensitive"`
	// DebugPauseOn is the type of event that the restore should pause on for
	// debugging purposes. Currently only "error" is supported.
	DebugPauseOn string `protobuf:"bytes,17,opt,name=debug_pause_on,json=debugPauseOn,proto3" json:",omitempty" redact:"nonsensitive"`
	// JobID is the ID of the BACKUP/RESTORE job.
	JobID uint64 `protobuf:"varint,18,opt,name=job_id,json=jobId,proto3" json:",omitempty"`
	// ResultStatus indicates whether the job succeeded or failed.
	ResultStatus string `protobuf:"bytes,20,opt,name=result_status,json=resultStatus,proto3" json:",omitempty" redact:"nonsensitive"`
	// ErrorText is the text of the error that caused the job to fail.
	ErrorText github_com_cockroachdb_redact.RedactableString `protobuf:"bytes,21,opt,name=error_text,json=errorText,proto3,customtype=github.com/cockroachdb/redact.RedactableString" json:",omitempty" redact:"mixed"`
	// RecurringCron is the crontab for the incremental backup.
	RecurringCron string `protobuf:"bytes,24,opt,name=recurring_cron,json=recurringCron,proto3" json:",omitempty" redact:"nonsensitive"`
	// FullBackupCron is the crontab for the full backup.
	FullBackupCron string `protobuf:"bytes,25,opt,name=full_backup_cron,json=fullBackupCron,proto3" json:",omitempty" redact:"nonsensitive"`
	// CustomFirstRunTime is the timestamp for the user configured first run time.
	// Expressed as nanoseconds since the Unix epoch.
	CustomFirstRunTime int64 `protobuf:"varint,26,opt,name=custom_first_run_time,json=customFirstRunTime,proto3" json:",omitempty"`
	// OnExecutionFailure describes the desired behavior if the schedule fails to
	// execute.
	OnExecutionFailure string `protobuf:"bytes,27,opt,name=on_execution_failure,json=onExecutionFailure,proto3" json:",omitempty" redact:"nonsensitive"`
	// OnPreviousRunning describes the desired behavior if the previously
	// scheduled BACKUP is still running.
	OnPreviousRunning string `protobuf:"bytes,28,opt,name=on_previous_running,json=onPreviousRunning,proto3" json:",omitempty" redact:"nonsensitive"`
	// IgnoreExistingBackup is true iff the BACKUP schedule should still be
	// created even if a backup is already present in its destination.
	IgnoreExistingBackup bool `protobuf:"varint,29,opt,name=ignore_existing_backup,json=ignoreExistingBackup,proto3" json:",omitempty"`
}

func (m *RecoveryEvent) Reset()         { *m = RecoveryEvent{} }
func (m *RecoveryEvent) String() string { return proto.CompactTextString(m) }
func (*RecoveryEvent) ProtoMessage()    {}
func (*RecoveryEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d317b4ad74be4f7, []int{4}
}
func (m *RecoveryEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecoveryEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RecoveryEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecoveryEvent.Merge(m, src)
}
func (m *RecoveryEvent) XXX_Size() int {
	return m.Size()
}
func (m *RecoveryEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_RecoveryEvent.DiscardUnknown(m)
}

var xxx_messageInfo_RecoveryEvent proto.InternalMessageInfo

// SchemaDescriptor is an event for schema telemetry, whose purpose is
// to take periodic snapshots of the cluster's SQL schema and publish them in
// the telemetry log channel. For all intents and purposes, the data in such a
// snapshot can be thought of the outer join of certain system tables:
// namespace, descriptor, and at some point perhaps zones, etc.
//
// Snapshots are too large to conveniently be published as a single log event,
// so instead they're broken down into SchemaDescriptor events which
// contain the data in one record of this outer join projection. These events
// are prefixed by a header (a SchemaSnapshotMetadata event).
type SchemaDescriptor struct {
	logpb.CommonEventDetails `protobuf:"bytes,1,opt,name=common,proto3,embedded=common" json:""`
	// SnapshotID is the unique identifier of the snapshot that this event
	// is part of.
	SnapshotID string `protobuf:"bytes,2,opt,name=snapshot_id,json=snapshotId,proto3" json:"snapshot_id,omitempty" redact:"nonsensitive"`
	// ParentDatabaseID matches the same key column in system.namespace.
	ParentDatabaseID uint32 `protobuf:"varint,3,opt,name=parent_database_id,json=parentDatabaseId,proto3" json:",omitempty"`
	// ParentSchemaID matches the same key column in system.namespace.
	ParentSchemaID uint32 `protobuf:"varint,4,opt,name=parent_schema_id,json=parentSchemaId,proto3" json:",omitempty"`
	// Name matches the same key column in system.namespace.
	Name string `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty" redact:"nonsensitive"`
	// DescID matches the 'id' column in system.namespace and system.descriptor.
	DescID uint32 `protobuf:"varint,6,opt,name=desc_id,json=descId,proto3" json:",omitempty"`
	// Desc matches the 'descriptor' column in system.descriptor.
	// Some contents of the descriptor may be redacted to prevent leaking PII.
	Desc *descpb.Descriptor `protobuf:"bytes,7,opt,name=desc,proto3" json:",omitempty" redact:"nonsensitive"`
}

func (m *SchemaDescriptor) Reset()         { *m = SchemaDescriptor{} }
func (m *SchemaDescriptor) String() string { return proto.CompactTextString(m) }
func (*SchemaDescriptor) ProtoMessage()    {}
func (*SchemaDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d317b4ad74be4f7, []int{5}
}
func (m *SchemaDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SchemaDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaDescriptor.Merge(m, src)
}
func (m *SchemaDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *SchemaDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaDescriptor proto.InternalMessageInfo

// SchemaSnapshotMetadata is an event describing a schema snapshot, which
// is a set of SchemaDescriptor messages sharing the same SnapshotID.
type SchemaSnapshotMetadata struct {
	logpb.CommonEventDetails `protobuf:"bytes,1,opt,name=common,proto3,embedded=common" json:""`
	// SnapshotID is the unique identifier of this snapshot.
	SnapshotID string `protobuf:"bytes,2,opt,name=snapshot_id,json=snapshotId,proto3" json:"snapshot_id,omitempty" redact:"nonsensitive"`
	// NumRecords is how many SchemaDescriptor events are in the
	// snapshot.
	NumRecords uint32 `protobuf:"varint,3,opt,name=num_records,json=numRecords,proto3" json:"num_records,omitempty"`
	// AsOfTimestamp is when the snapshot was taken.
	// This is equivalent to the timestamp given in the AS OF SYSTEM TIME
	// clause when querying the namespace and descriptor tables in the
	// system database.
	// Expressed as nanoseconds since the Unix epoch.
	AsOfTimestamp int64 `protobuf:"varint,4,opt,name=as_of_timestamp,json=asOfTimestamp,proto3" json:",omitempty"`
	// Errors records any errors encountered when post-processing this snapshot,
	// which includes the redaction of any potential PII.
	Errors []string `protobuf:"bytes,5,rep,name=errors,proto3" json:",omitempty"`
}

func (m *SchemaSnapshotMetadata) Reset()         { *m = SchemaSnapshotMetadata{} }
func (m *SchemaSnapshotMetadata) String() string { return proto.CompactTextString(m) }
func (*SchemaSnapshotMetadata) ProtoMessage()    {}
func (*SchemaSnapshotMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d317b4ad74be4f7, []int{6}
}
func (m *SchemaSnapshotMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaSnapshotMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SchemaSnapshotMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaSnapshotMetadata.Merge(m, src)
}
func (m *SchemaSnapshotMetadata) XXX_Size() int {
	return m.Size()
}
func (m *SchemaSnapshotMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaSnapshotMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaSnapshotMetadata proto.InternalMessageInfo

func init() {
	proto.RegisterType((*SampledQuery)(nil), "cockroach.util.log.eventpb.SampledQuery")
	proto.RegisterType((*CapturedIndexUsageStats)(nil), "cockroach.util.log.eventpb.CapturedIndexUsageStats")
	proto.RegisterType((*CreateChangefeed)(nil), "cockroach.util.log.eventpb.CreateChangefeed")
	proto.RegisterType((*ChangefeedFailed)(nil), "cockroach.util.log.eventpb.ChangefeedFailed")
	proto.RegisterType((*RecoveryEvent)(nil), "cockroach.util.log.eventpb.RecoveryEvent")
	proto.RegisterType((*SchemaDescriptor)(nil), "cockroach.util.log.eventpb.SchemaDescriptor")
	proto.RegisterType((*SchemaSnapshotMetadata)(nil), "cockroach.util.log.eventpb.SchemaSnapshotMetadata")
}

func init() { proto.RegisterFile("util/log/eventpb/telemetry.proto", fileDescriptor_3d317b4ad74be4f7) }

var fileDescriptor_3d317b4ad74be4f7 = []byte{
	// 2159 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x59, 0xdd, 0x6e, 0x1b, 0xb9,
	0x15, 0xb6, 0x36, 0xfe, 0x91, 0x28, 0x4b, 0x96, 0x19, 0xff, 0x4c, 0x9c, 0xae, 0xe5, 0xd5, 0x16,
	0x59, 0x17, 0xed, 0xca, 0x4d, 0x76, 0x91, 0x0d, 0x52, 0xa0, 0x58, 0xff, 0xc4, 0x59, 0x39, 0xf1,
	0x26, 0x91, 0xbc, 0x5d, 0xec, 0x02, 0x2d, 0x41, 0xcd, 0xd0, 0x23, 0xc6, 0x33, 0xe4, 0x98, 0xe4,
	0x38, 0x52, 0x1e, 0xa1, 0x57, 0x7d, 0x81, 0x3e, 0x41, 0xaf, 0xfa, 0x02, 0xbd, 0x4e, 0xef, 0x72,
	0xb9, 0xe8, 0x85, 0xd0, 0x2a, 0x77, 0x7b, 0xd9, 0x27, 0x28, 0x48, 0x8e, 0xfe, 0xac, 0x71, 0xd7,
	0x02, 0x52, 0xa0, 0x17, 0x81, 0x05, 0xf2, 0xfb, 0xbe, 0xc3, 0x43, 0x1e, 0x9e, 0x73, 0x38, 0x01,
	0x5b, 0xb1, 0xa2, 0xc1, 0x4e, 0xc0, 0xfd, 0x1d, 0x72, 0x41, 0x98, 0x8a, 0x9a, 0x3b, 0x8a, 0x04,
	0x24, 0x24, 0x4a, 0x74, 0xaa, 0x91, 0xe0, 0x8a, 0xc3, 0x0d, 0x97, 0xbb, 0x67, 0x82, 0x63, 0xb7,
	0x55, 0xd5, 0xd8, 0x6a, 0xc0, 0xfd, 0x6a, 0x82, 0xdd, 0x58, 0xf1, 0xb9, 0xcf, 0x0d, 0x6c, 0x47,
	0xff, 0xb2, 0x8c, 0x8d, 0x8f, 0xe5, 0x79, 0xb0, 0xe3, 0x62, 0x85, 0xb5, 0xac, 0x47, 0xa4, 0x1b,
	0x35, 0x77, 0xa4, 0x12, 0xb1, 0xab, 0x62, 0x41, 0xbc, 0x04, 0xf4, 0xe1, 0x84, 0x61, 0xf3, 0x57,
	0x26, 0xd3, 0x9f, 0x4c, 0x4c, 0xcb, 0xf3, 0x00, 0xe1, 0xd8, 0xa3, 0x0a, 0x8d, 0x01, 0x37, 0x06,
	0xc0, 0x80, 0xfb, 0x7d, 0x15, 0x3b, 0x57, 0xf9, 0x3b, 0x04, 0x8b, 0x0d, 0x1c, 0x46, 0x01, 0xf1,
	0x5e, 0xc4, 0x44, 0x74, 0xe0, 0x53, 0x30, 0xef, 0xf2, 0x30, 0xe4, 0xcc, 0xc9, 0x6c, 0x65, 0xb6,
	0xf3, 0xf7, 0xee, 0x54, 0x53, 0x9c, 0xdb, 0x37, 0x88, 0x47, 0x5a, 0xe7, 0x80, 0x28, 0x4c, 0x03,
	0xb9, 0xb7, 0xf8, 0xa6, 0x5b, 0x9e, 0x79, 0xdb, 0x2d, 0x67, 0x7e, 0xec, 0x96, 0x67, 0xea, 0x89,
	0x06, 0x7c, 0x01, 0x6e, 0xc8, 0xf3, 0xc0, 0xf9, 0xc0, 0x48, 0xdd, 0xad, 0x5e, 0xbd, 0x4f, 0x89,
	0x64, 0xe3, 0xc5, 0xd3, 0xff, 0xa2, 0xaa, 0xb5, 0x60, 0x1d, 0xcc, 0x92, 0x36, 0x71, 0x9d, 0x1b,
	0x46, 0xf3, 0xd7, 0xd7, 0xd3, 0x6c, 0x13, 0x37, 0x5d, 0xd2, 0x68, 0xc1, 0x2f, 0xc0, 0x92, 0x3c,
	0xa3, 0x51, 0x44, 0x3c, 0x74, 0x1e, 0x13, 0x41, 0x89, 0x74, 0x66, 0xb7, 0x32, 0xdb, 0xb3, 0x7b,
	0xc5, 0x1f, 0xbb, 0x65, 0xf0, 0x2b, 0x1e, 0x52, 0x45, 0xc2, 0x48, 0x75, 0xea, 0xc5, 0x04, 0xf6,
	0xc2, 0xa2, 0xe0, 0x67, 0xa0, 0xe0, 0x72, 0xa9, 0x10, 0x91, 0x8a, 0x86, 0x58, 0x11, 0x67, 0x6e,
	0x2b, 0xb3, 0x9d, 0x99, 0xa0, 0x2d, 0x6a, 0xd0, 0xa3, 0x04, 0x03, 0x9f, 0x80, 0x45, 0x8f, 0x4a,
	0x25, 0x68, 0x33, 0x56, 0x94, 0x33, 0x67, 0x7e, 0x2b, 0xb3, 0x9d, 0xdb, 0xfb, 0x64, 0x9c, 0xf3,
	0xef, 0x6e, 0x79, 0x55, 0x10, 0x0f, 0xbb, 0xea, 0x61, 0x85, 0x71, 0x26, 0x09, 0x93, 0x54, 0xd1,
	0x0b, 0x52, 0xa9, 0x8f, 0x91, 0xe1, 0x01, 0xc8, 0x45, 0x01, 0x66, 0xc8, 0xa7, 0x52, 0x39, 0x0b,
	0xd3, 0x29, 0x65, 0x35, 0xf3, 0x31, 0x95, 0x0a, 0x36, 0x00, 0x90, 0x44, 0x4a, 0xca, 0x19, 0xa2,
	0x9e, 0x93, 0x35, 0x32, 0x9f, 0xf7, 0xba, 0xe5, 0x5c, 0xc3, 0x8e, 0xd6, 0x0e, 0xae, 0xab, 0x99,
	0x4b, 0x74, 0x6a, 0x1e, 0xdc, 0x07, 0x59, 0x0f, 0x2b, 0xdc, 0xc4, 0x92, 0x38, 0xb9, 0x29, 0x57,
	0xd6, 0x27, 0xc2, 0xef, 0xc0, 0xa2, 0x54, 0x58, 0x91, 0x90, 0x30, 0xa5, 0xd7, 0x06, 0x8c, 0xd0,
	0xfd, 0x5e, 0xb7, 0x9c, 0x6f, 0xf4, 0xc7, 0xaf, 0xbf, 0xba, 0xfc, 0x40, 0xab, 0xe6, 0x41, 0x04,
	0x8a, 0x4a, 0x60, 0x26, 0xb1, 0xab, 0x12, 0xc7, 0xf3, 0x46, 0xfc, 0x41, 0xaf, 0x5b, 0x2e, 0x9c,
	0x0c, 0x67, 0xae, 0x2f, 0x5f, 0x18, 0xd1, 0xab, 0x79, 0xb0, 0x09, 0x9c, 0xe1, 0xda, 0x4f, 0x29,
	0xf3, 0x89, 0x88, 0x04, 0xb5, 0x7e, 0x14, 0x4c, 0x7c, 0x6d, 0xf7, 0xba, 0xe5, 0xb5, 0x81, 0x1f,
	0x87, 0x43, 0xc8, 0x65, 0x9b, 0xf5, 0x35, 0x99, 0x86, 0xf2, 0xe0, 0x53, 0x70, 0x3b, 0xc4, 0x6d,
	0x74, 0x1a, 0x07, 0x01, 0x92, 0x2e, 0x66, 0x48, 0xf0, 0x57, 0x72, 0x18, 0x8f, 0xc5, 0xd4, 0x78,
	0x5c, 0x0f, 0x71, 0xfb, 0x30, 0x0e, 0x82, 0x86, 0x8b, 0x59, 0x9d, 0xbf, 0x92, 0x83, 0xd0, 0x7c,
	0x0c, 0x1c, 0xc5, 0x15, 0x4e, 0x95, 0x5a, 0x4a, 0x95, 0x5a, 0x35, 0xf8, 0x09, 0xa1, 0x2f, 0xc1,
	0x0a, 0x8f, 0x55, 0x14, 0xab, 0x4b, 0x22, 0xa5, 0x54, 0x11, 0x68, 0xb1, 0x63, 0x0a, 0xfa, 0x4e,
	0x2a, 0xac, 0x24, 0xc2, 0x17, 0x98, 0x06, 0xb8, 0x19, 0x10, 0x67, 0x79, 0x2b, 0xb3, 0x9d, 0x4d,
	0xb9, 0x93, 0x1a, 0xb6, 0xdb, 0x47, 0xc1, 0x63, 0x70, 0x9b, 0x61, 0xc6, 0x25, 0x92, 0x94, 0xb9,
	0x04, 0x59, 0x11, 0x97, 0x07, 0x01, 0x71, 0x15, 0xf1, 0x1c, 0xb8, 0x95, 0xd9, 0xbe, 0x31, 0x21,
	0xe2, 0x18, 0x4a, 0x43, 0x33, 0xf4, 0x71, 0xc8, 0xfd, 0x3e, 0x1e, 0x7e, 0x0a, 0x40, 0xb3, 0xa3,
	0x88, 0x44, 0x82, 0x60, 0xcf, 0xb9, 0x99, 0xca, 0xce, 0x19, 0x44, 0x9d, 0x60, 0x0f, 0xfe, 0x12,
	0xe4, 0x8c, 0xc7, 0x06, 0xbd, 0x92, 0x8a, 0xce, 0x6a, 0x80, 0x01, 0xdf, 0x05, 0x8b, 0x06, 0xfc,
	0x4a, 0x50, 0xa5, 0x08, 0x73, 0x56, 0x53, 0xf1, 0x79, 0x8d, 0xf9, 0xd6, 0x42, 0xe0, 0x03, 0x50,
	0xa2, 0x8c, 0x11, 0x81, 0x5e, 0x72, 0xca, 0x90, 0xcb, 0x63, 0xa6, 0x9c, 0xb5, 0x54, 0x5a, 0xd1,
	0xe0, 0x8e, 0x38, 0x65, 0xfb, 0x1a, 0x05, 0x77, 0xc1, 0x6a, 0x40, 0x4e, 0x15, 0xe2, 0xb1, 0x1a,
	0xa7, 0xaf, 0xa7, 0xd2, 0xa1, 0x06, 0x3f, 0xd3, 0xd8, 0x31, 0x09, 0x13, 0x68, 0x13, 0x12, 0x4e,
	0xba, 0x84, 0x06, 0x5f, 0x92, 0xb8, 0x0f, 0x96, 0x24, 0x09, 0xe9, 0x28, 0xf9, 0x56, 0x2a, 0xb9,
	0xa0, 0x61, 0x63, 0x3c, 0xcc, 0xd4, 0x18, 0x6f, 0x23, 0x9d, 0xa7, 0x61, 0x43, 0xde, 0x63, 0xe0,
	0x50, 0xa6, 0x88, 0x90, 0xc4, 0x55, 0x08, 0x07, 0xc1, 0xa8, 0xc0, 0xed, 0x54, 0x81, 0xd5, 0x01,
	0x7e, 0x37, 0x08, 0xc6, 0x7c, 0x27, 0x6d, 0x97, 0x44, 0x13, 0x2a, 0x3f, 0x4b, 0xf7, 0xdd, 0x82,
	0xc7, 0x24, 0xee, 0x83, 0xa5, 0x16, 0x96, 0xad, 0x51, 0xf2, 0x87, 0xe9, 0x3e, 0x68, 0xd8, 0x90,
	0xf7, 0x00, 0x94, 0x5c, 0xc1, 0xa5, 0x1c, 0x25, 0x6e, 0xa6, 0x9f, 0xb9, 0xc1, 0x8d, 0x31, 0x29,
	0xf3, 0x48, 0x7b, 0x94, 0x59, 0xbe, 0x2a, 0x5a, 0x3c, 0xd2, 0x1e, 0x32, 0x1f, 0x82, 0xe5, 0x80,
	0xf3, 0xb3, 0x38, 0x1a, 0xa5, 0x6e, 0xa5, 0x52, 0x97, 0x2c, 0x70, 0xcc, 0x6a, 0x48, 0x84, 0x4f,
	0x46, 0xa9, 0x1f, 0xa5, 0x5b, 0x35, 0xb8, 0x21, 0xf3, 0xb7, 0xe0, 0x26, 0x65, 0x17, 0x44, 0x28,
	0xe2, 0x8d, 0x92, 0x2b, 0xa9, 0xe4, 0xe5, 0x3e, 0x74, 0xcc, 0x32, 0x8e, 0xa2, 0xa0, 0x33, 0x4a,
	0xfe, 0x38, 0xdd, 0xb2, 0xc1, 0x0d, 0x99, 0xbf, 0x01, 0xf0, 0x35, 0xf5, 0xd1, 0x6b, 0xec, 0x8f,
	0x72, 0x7f, 0x9e, 0xee, 0xf0, 0x6b, 0xea, 0x7f, 0x8f, 0xfd, 0x01, 0xf9, 0x68, 0x36, 0xbb, 0x58,
	0x2a, 0x54, 0xfe, 0x32, 0x07, 0xd6, 0xf7, 0x71, 0x64, 0x5a, 0xb8, 0x9a, 0xde, 0xcd, 0x6f, 0x24,
	0xf6, 0x6d, 0x3a, 0x79, 0xcf, 0x6d, 0xd5, 0x36, 0x28, 0xd9, 0x34, 0xad, 0xb3, 0x4c, 0xb2, 0x54,
	0xdd, 0x63, 0xcd, 0xd6, 0x8b, 0x66, 0x5c, 0x27, 0x17, 0xeb, 0xd6, 0x01, 0xc8, 0x05, 0x58, 0x2a,
	0x9b, 0x8e, 0x6e, 0x4c, 0x59, 0x84, 0x35, 0xd3, 0xe4, 0xa9, 0x3b, 0x20, 0xab, 0x74, 0x6e, 0xd5,
	0x85, 0x4b, 0x37, 0x46, 0x85, 0xbd, 0x7c, 0xaf, 0x5b, 0x5e, 0x38, 0xd1, 0x63, 0xb5, 0x83, 0xfa,
	0x82, 0x99, 0xac, 0x19, 0x9c, 0x0d, 0x37, 0xea, 0x99, 0x4e, 0x28, 0xc1, 0x99, 0xcd, 0xd0, 0x38,
	0x33, 0x69, 0x8a, 0x56, 0xa1, 0x5f, 0xe0, 0x11, 0xc3, 0x21, 0x99, 0xbe, 0x05, 0x4a, 0xd8, 0x5f,
	0xe3, 0x90, 0xc0, 0x43, 0x00, 0xec, 0xea, 0x8c, 0xd4, 0x94, 0x3d, 0x50, 0xce, 0x50, 0xfb, 0x3a,
	0x76, 0xf5, 0x46, 0x27, 0x3b, 0xa5, 0x8e, 0xa1, 0x8e, 0xeb, 0xa8, 0x4e, 0x34, 0x75, 0xe7, 0x63,
	0x75, 0x4e, 0x3a, 0x11, 0xd1, 0xa5, 0x84, 0x4a, 0x14, 0x33, 0x7a, 0x1e, 0x13, 0xd3, 0xf7, 0x4c,
	0xd6, 0xbe, 0x2c, 0x95, 0xdf, 0x98, 0x79, 0xb8, 0x03, 0xf2, 0x54, 0xa2, 0xfe, 0x8d, 0x30, 0x9d,
	0xcc, 0x24, 0x1c, 0x50, 0x59, 0x4b, 0x10, 0x15, 0x01, 0x4a, 0xfb, 0x82, 0x60, 0x45, 0xf6, 0x5b,
	0x98, 0xf9, 0xe4, 0x94, 0x10, 0x0f, 0xfe, 0xe1, 0x52, 0x94, 0x3e, 0xf8, 0xe9, 0xee, 0x7a, 0xc8,
	0xfe, 0xe9, 0xb8, 0xad, 0xfc, 0x2d, 0x03, 0x4a, 0x43, 0xc2, 0x21, 0xa6, 0xc1, 0xff, 0xde, 0x28,
	0x3c, 0x02, 0x8b, 0xa7, 0x98, 0x06, 0xb1, 0x20, 0xf6, 0x40, 0x3e, 0x98, 0xee, 0x40, 0xf2, 0x09,
	0x59, 0x1f, 0x49, 0xe5, 0xcf, 0x4b, 0xa0, 0x50, 0x27, 0x2e, 0xbf, 0x20, 0xa2, 0x63, 0x4c, 0xbf,
	0xe7, 0x8b, 0x4d, 0x40, 0x41, 0x24, 0xf2, 0xa3, 0x8b, 0xfd, 0x52, 0x83, 0xff, 0xd1, 0x2d, 0x2f,
	0x8f, 0xd9, 0xd6, 0x2b, 0xba, 0xf6, 0x8d, 0xe9, 0xcb, 0x9a, 0xc8, 0x3a, 0x02, 0x8b, 0x0a, 0x0b,
	0x9f, 0x28, 0x24, 0x5d, 0x1e, 0x91, 0x69, 0x13, 0x43, 0xde, 0x92, 0x1b, 0x9a, 0x0b, 0xf7, 0xc0,
	0x2a, 0x95, 0x28, 0x8c, 0x03, 0x45, 0x05, 0xf1, 0x75, 0x23, 0x6d, 0x67, 0x4d, 0xa2, 0x98, 0x0c,
	0xc1, 0x9b, 0x54, 0x1e, 0x0f, 0xb1, 0x27, 0x06, 0xaa, 0xfb, 0xa0, 0x64, 0x3d, 0x36, 0x97, 0xd9,
	0xdc, 0x31, 0xd1, 0x07, 0x59, 0x8c, 0x4d, 0x6c, 0x08, 0xac, 0x7b, 0xba, 0xab, 0x64, 0xd8, 0x34,
	0xef, 0x32, 0x6e, 0x7a, 0x54, 0xd8, 0x3d, 0x9b, 0x32, 0x99, 0xac, 0x8e, 0xe8, 0x34, 0x8c, 0x8c,
	0xd9, 0x23, 0x17, 0xdc, 0x1a, 0x33, 0xa0, 0xb8, 0xc0, 0xbe, 0x0d, 0x21, 0xe9, 0x2c, 0x6c, 0xdd,
	0x98, 0xc6, 0xc4, 0xe8, 0x52, 0x1b, 0x56, 0x48, 0xdb, 0x90, 0xf0, 0xf7, 0x60, 0x6d, 0xd4, 0x08,
	0x8e, 0x55, 0x2b, 0xb1, 0x90, 0x9d, 0xce, 0xc2, 0xca, 0x88, 0xcc, 0x6e, 0xac, 0x5a, 0x56, 0xfe,
	0x21, 0x58, 0xa6, 0x12, 0x05, 0xdc, 0xc5, 0x01, 0x55, 0x1d, 0x84, 0x5f, 0x61, 0x61, 0x13, 0xd2,
	0xe4, 0xb9, 0x2c, 0x51, 0xf9, 0x34, 0xc1, 0xed, 0x6a, 0x18, 0xfc, 0x1c, 0x14, 0xb1, 0x44, 0xfc,
	0x14, 0x99, 0x76, 0xe8, 0x02, 0x07, 0x26, 0x05, 0x4d, 0x16, 0xc3, 0x45, 0x2c, 0x9f, 0x9d, 0xd6,
	0x12, 0x8c, 0x8e, 0x86, 0x57, 0x54, 0xb5, 0x90, 0x20, 0x17, 0xd4, 0x3c, 0x27, 0x5b, 0x54, 0xef,
	0x5c, 0xe7, 0x8a, 0x84, 0x74, 0x53, 0x83, 0xeb, 0x09, 0xf6, 0x2b, 0x0b, 0x85, 0x47, 0xe0, 0x56,
	0x0b, 0x4b, 0x44, 0x98, 0x2b, 0x3a, 0x91, 0xd9, 0x97, 0x08, 0x4b, 0x19, 0xb5, 0x84, 0x7e, 0x48,
	0x16, 0x52, 0x75, 0xd6, 0x5b, 0x58, 0x3e, 0x1a, 0xe0, 0x9f, 0x0f, 0xe0, 0xf0, 0x18, 0x64, 0xcf,
	0x42, 0x69, 0xe3, 0xa2, 0x68, 0xe2, 0xe2, 0x9e, 0xae, 0x48, 0x4f, 0x8e, 0x1b, 0xd3, 0xdc, 0x9e,
	0x85, 0xb3, 0x50, 0x9a, 0xa0, 0xf8, 0x02, 0xe4, 0xb4, 0x9c, 0x8d, 0xd2, 0x25, 0x13, 0xa5, 0x1b,
	0xbd, 0x6e, 0x39, 0xfb, 0xe4, 0xb8, 0x61, 0xc2, 0xf2, 0x72, 0x7a, 0x3e, 0x0b, 0x65, 0xbf, 0x7b,
	0x5c, 0xe0, 0x66, 0x6d, 0xd2, 0x29, 0x4d, 0x77, 0xb2, 0x7d, 0x1e, 0x3c, 0x06, 0x45, 0x8f, 0x34,
	0x63, 0x1f, 0x45, 0x38, 0x96, 0x04, 0x71, 0x66, 0xde, 0x43, 0x53, 0x55, 0x4d, 0x4d, 0x7f, 0xae,
	0xd9, 0xcf, 0x18, 0xac, 0x82, 0xf9, 0x97, 0xbc, 0xa9, 0x2b, 0x35, 0x34, 0x4f, 0xd1, 0xf5, 0x5e,
	0xb7, 0x3c, 0x77, 0xc4, 0x9b, 0x13, 0x2f, 0xcf, 0xb9, 0x97, 0xbc, 0x69, 0x6b, 0xb6, 0x20, 0x32,
	0x0e, 0x94, 0x79, 0x51, 0xc5, 0xd2, 0x3c, 0x6e, 0xa6, 0xb1, 0x6e, 0xd9, 0x0d, 0x43, 0x86, 0x31,
	0x00, 0x44, 0x08, 0x2e, 0x90, 0x22, 0x6d, 0x65, 0xde, 0x3d, 0xb9, 0xbd, 0xdf, 0x25, 0x59, 0xae,
	0xea, 0x53, 0xd5, 0x8a, 0x9b, 0x55, 0x97, 0x87, 0x3b, 0x83, 0x64, 0xea, 0x35, 0x77, 0xac, 0x6e,
	0xb5, 0x6e, 0xfe, 0xe8, 0xaa, 0xdd, 0x50, 0x82, 0x32, 0x7f, 0x62, 0x01, 0xc5, 0xfe, 0x02, 0x42,
	0xda, 0x26, 0x5e, 0xa5, 0x9e, 0x33, 0x96, 0x4e, 0x48, 0x5b, 0xc1, 0xaf, 0x41, 0x51, 0x10, 0x37,
	0x16, 0x9a, 0x87, 0x5c, 0xc1, 0x99, 0x79, 0xb9, 0x4c, 0xe1, 0x45, 0x61, 0x40, 0xdf, 0x17, 0xe6,
	0xfb, 0x56, 0xc9, 0x3c, 0x88, 0x9a, 0xd8, 0xd5, 0xad, 0xb2, 0x51, 0xbc, 0x35, 0x9d, 0x62, 0x51,
	0x0b, 0xec, 0x19, 0xbe, 0x91, 0xdc, 0x05, 0xab, 0x6e, 0x2c, 0x15, 0x0f, 0xd1, 0x29, 0x15, 0xba,
	0x73, 0x8b, 0x19, 0x52, 0x34, 0x24, 0x57, 0x3c, 0x77, 0xa0, 0x05, 0x1f, 0x6a, 0x6c, 0x3d, 0x66,
	0x27, 0x34, 0x24, 0xf0, 0x3b, 0xb0, 0xc2, 0x19, 0x22, 0x6d, 0xe2, 0x9a, 0x6f, 0x44, 0x28, 0xa9,
	0x60, 0xe6, 0xbd, 0x33, 0xc5, 0xca, 0x20, 0x67, 0x8f, 0xfa, 0x1a, 0x87, 0x56, 0x02, 0x7e, 0x0b,
	0x6e, 0xea, 0xfb, 0xa8, 0xaf, 0x37, 0x8f, 0xa5, 0x5e, 0x1c, 0xa3, 0xcc, 0x37, 0x6f, 0xa0, 0x29,
	0x94, 0x97, 0x39, 0x7b, 0x9e, 0x48, 0xd4, 0xad, 0x02, 0x3c, 0x00, 0x6b, 0xd4, 0x67, 0x5c, 0x10,
	0x44, 0xda, 0x54, 0xa7, 0x32, 0x3f, 0xd9, 0x54, 0xf3, 0x44, 0x9a, 0xbc, 0xf1, 0x2b, 0x16, 0xfd,
	0x28, 0x01, 0xdb, 0x0d, 0xac, 0xfc, 0x71, 0x16, 0x94, 0x1a, 0x6e, 0x8b, 0x84, 0xf8, 0x80, 0x48,
	0x57, 0xd0, 0x48, 0x71, 0xf1, 0x9e, 0x4b, 0xf4, 0x57, 0x20, 0x2f, 0x19, 0x8e, 0x64, 0x8b, 0x9b,
	0xef, 0x38, 0x49, 0x37, 0xd1, 0xeb, 0x96, 0x41, 0x23, 0x19, 0xae, 0x1d, 0x5c, 0xed, 0x39, 0xe8,
	0x73, 0x6b, 0x1e, 0x7c, 0x0e, 0x60, 0x84, 0x05, 0x61, 0x0a, 0x0d, 0x9a, 0x61, 0x6a, 0x9b, 0xf4,
	0xc2, 0x5e, 0xa5, 0xd7, 0x2d, 0x97, 0x9e, 0x9b, 0xd9, 0x83, 0x64, 0x72, 0xe2, 0x62, 0x96, 0xa2,
	0xf1, 0x79, 0x0f, 0x1e, 0x81, 0x64, 0x0c, 0x49, 0xb3, 0x09, 0xc3, 0x7e, 0x7d, 0xab, 0xd7, 0x2d,
	0x17, 0xad, 0x9e, 0xdd, 0x9f, 0x09, 0xb5, 0x62, 0x34, 0x3a, 0xeb, 0xc1, 0x4f, 0xc1, 0xac, 0xe9,
	0x83, 0xe7, 0x8c, 0x83, 0xb7, 0xae, 0x76, 0xc9, 0xc0, 0xe0, 0x5d, 0xb0, 0xe0, 0x11, 0xe9, 0x6a,
	0x8b, 0xf3, 0xc6, 0xa2, 0xd3, 0xeb, 0x96, 0xe7, 0xf5, 0x29, 0x4c, 0x58, 0x9a, 0xd7, 0xc0, 0x9a,
	0x6e, 0xfc, 0x66, 0xf5, 0x2f, 0xd3, 0xb1, 0xe7, 0xef, 0x7d, 0x34, 0x72, 0x2a, 0xf2, 0x3c, 0xd0,
	0xff, 0xb4, 0x57, 0xd5, 0xe1, 0x41, 0x5e, 0x3f, 0xbe, 0x8c, 0x6e, 0xe5, 0xaf, 0x1f, 0x80, 0x35,
	0xeb, 0x4e, 0xff, 0x64, 0x8e, 0x89, 0xc2, 0x7a, 0xaf, 0xff, 0x6f, 0x43, 0xa2, 0x0c, 0xf2, 0x2c,
	0x0e, 0x91, 0x6e, 0xd6, 0x84, 0x27, 0x6d, 0x2c, 0xd4, 0x01, 0x8b, 0xc3, 0xba, 0x1d, 0x31, 0x9f,
	0x41, 0x4c, 0x55, 0xd6, 0x29, 0x41, 0x2a, 0x1c, 0x46, 0xe6, 0x80, 0xd3, 0x3e, 0x83, 0xc8, 0x67,
	0xa7, 0x27, 0x7d, 0x10, 0xbc, 0x03, 0xe6, 0x4d, 0x16, 0x94, 0xce, 0x9c, 0x29, 0x3f, 0x97, 0xe1,
	0xc9, 0xec, 0xde, 0x2f, 0xde, 0xfc, 0x6b, 0x73, 0xe6, 0x4d, 0x6f, 0x33, 0xf3, 0xb6, 0xb7, 0x99,
	0xf9, 0xa1, 0xb7, 0x99, 0xf9, 0x67, 0x6f, 0x33, 0xf3, 0xa7, 0x77, 0x9b, 0x33, 0x6f, 0xdf, 0x6d,
	0xce, 0xfc, 0xf0, 0x6e, 0x73, 0xe6, 0xfb, 0x85, 0xa4, 0x15, 0x6f, 0xce, 0x9b, 0xff, 0x41, 0xf8,
	0xec, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x03, 0x00, 0x50, 0x20, 0x20, 0x19, 0x00, 0x00,
}

func (m *SampledQuery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SampledQuery) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SampledQuery) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ZigZagJoinCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ZigZagJoinCount))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa0
	}
	if m.ApplyJoinCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ApplyJoinCount))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x98
	}
	if m.InvertedJoinCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.InvertedJoinCount))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.MergeJoinCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.MergeJoinCount))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.LookupJoinCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.LookupJoinCount))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.IndexJoinCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.IndexJoinCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.CrossJoinCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.CrossJoinCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.HashJoinCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.HashJoinCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.ExceptAllJoinCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ExceptAllJoinCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.IntersectAllJoinCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.IntersectAllJoinCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.AntiJoinCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.AntiJoinCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.SemiJoinCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.SemiJoinCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.FullOuterJoinCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.FullOuterJoinCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.LeftOuterJoinCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.LeftOuterJoinCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.InnerJoinCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.InnerJoinCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.RowsWritten != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.RowsWritten))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.RowsRead != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.RowsRead))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.BytesRead != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.BytesRead))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.NanosSinceStatsCollected != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.NanosSinceStatsCollected))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.StatsAvailable {
		i--
		if m.StatsAvailable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.OutputRowsEstimate != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.OutputRowsEstimate))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x81
	}
	if m.TotalScanRowsEstimate != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TotalScanRowsEstimate))))
		i--
		dAtA[i] = 0x79
	}
	if m.MaxFullScanRowsEstimate != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MaxFullScanRowsEstimate))))
		i--
		dAtA[i] = 0x71
	}
	if m.StatementFingerprintID != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.StatementFingerprintID))
		i--
		dAtA[i] = 0x68
	}
	if len(m.TransactionID) > 0 {
		i -= len(m.TransactionID)
		copy(dAtA[i:], m.TransactionID)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.TransactionID)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.StatementID) > 0 {
		i -= len(m.StatementID)
		copy(dAtA[i:], m.StatementID)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.StatementID)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.SessionID) > 0 {
		i -= len(m.SessionID)
		copy(dAtA[i:], m.SessionID)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.SessionID)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.PlanGist) > 0 {
		i -= len(m.PlanGist)
		copy(dAtA[i:], m.PlanGist)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.PlanGist)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Distribution) > 0 {
		i -= len(m.Distribution)
		copy(dAtA[i:], m.Distribution)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Distribution)))
		i--
		dAtA[i] = 0x32
	}
	if m.CostEstimate != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CostEstimate))))
		i--
		dAtA[i] = 0x29
	}
	if m.SkippedQueries != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.SkippedQueries))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.CommonSQLExecDetails.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTelemetry(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.CommonSQLEventDetails.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTelemetry(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.CommonEventDetails.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTelemetry(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CapturedIndexUsageStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CapturedIndexUsageStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CapturedIndexUsageStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsInverted {
		i--
		if m.IsInverted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.IsUnique {
		i--
		if m.IsUnique {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.IndexType) > 0 {
		i -= len(m.IndexType)
		copy(dAtA[i:], m.IndexType)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.IndexType)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.IndexName) > 0 {
		i -= len(m.IndexName)
		copy(dAtA[i:], m.IndexName)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.IndexName)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.TableName) > 0 {
		i -= len(m.TableName)
		copy(dAtA[i:], m.TableName)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.TableName)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.DatabaseName) > 0 {
		i -= len(m.DatabaseName)
		copy(dAtA[i:], m.DatabaseName)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.DatabaseName)))
		i--
		dAtA[i] = 0x32
	}
	if m.IndexID != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.IndexID))
		i--
		dAtA[i] = 0x28
	}
	if m.TableID != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x20
	}
	if len(m.LastRead) > 0 {
		i -= len(m.LastRead)
		copy(dAtA[i:], m.LastRead)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.LastRead)))
		i--
		dAtA[i] = 0x1a
	}
	if m.TotalReadCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.TotalReadCount))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.CommonEventDetails.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTelemetry(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CreateChangefeed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateChangefeed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateChangefeed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.CommonChangefeedEventDetails.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTelemetry(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ChangefeedFailed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangefeedFailed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChangefeedFailed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FailureType) > 0 {
		i -= len(m.FailureType)
		copy(dAtA[i:], m.FailureType)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.FailureType)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.CommonChangefeedEventDetails.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTelemetry(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RecoveryEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecoveryEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecoveryEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IgnoreExistingBackup {
		i--
		if m.IgnoreExistingBackup {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if len(m.OnPreviousRunning) > 0 {
		i -= len(m.OnPreviousRunning)
		copy(dAtA[i:], m.OnPreviousRunning)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.OnPreviousRunning)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if len(m.OnExecutionFailure) > 0 {
		i -= len(m.OnExecutionFailure)
		copy(dAtA[i:], m.OnExecutionFailure)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.OnExecutionFailure)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if m.CustomFirstRunTime != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.CustomFirstRunTime))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if len(m.FullBackupCron) > 0 {
		i -= len(m.FullBackupCron)
		copy(dAtA[i:], m.FullBackupCron)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.FullBackupCron)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if len(m.RecurringCron) > 0 {
		i -= len(m.RecurringCron)
		copy(dAtA[i:], m.RecurringCron)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.RecurringCron)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if len(m.ErrorText) > 0 {
		i -= len(m.ErrorText)
		copy(dAtA[i:], m.ErrorText)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.ErrorText)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.ResultStatus) > 0 {
		i -= len(m.ResultStatus)
		copy(dAtA[i:], m.ResultStatus)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.ResultStatus)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.JobID != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.JobID))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if len(m.DebugPauseOn) > 0 {
		i -= len(m.DebugPauseOn)
		copy(dAtA[i:], m.DebugPauseOn)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.DebugPauseOn)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.Options) > 0 {
		for iNdEx := len(m.Options) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Options[iNdEx])
			copy(dAtA[i:], m.Options[iNdEx])
			i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Options[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.KMSCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.KMSCount))
		i--
		dAtA[i] = 0x78
	}
	if len(m.KMSType) > 0 {
		i -= len(m.KMSType)
		copy(dAtA[i:], m.KMSType)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.KMSType)))
		i--
		dAtA[i] = 0x72
	}
	if m.HasEncryptionPassphrase {
		i--
		if m.HasEncryptionPassphrase {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.WithRevisionHistory {
		i--
		if m.WithRevisionHistory {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.AsOfInterval != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.AsOfInterval))
		i--
		dAtA[i] = 0x50
	}
	if m.IsLocalityAware {
		i--
		if m.IsLocalityAware {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.DestinationAuthTypes) > 0 {
		for iNdEx := len(m.DestinationAuthTypes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DestinationAuthTypes[iNdEx])
			copy(dAtA[i:], m.DestinationAuthTypes[iNdEx])
			i = encodeVarintTelemetry(dAtA, i, uint64(len(m.DestinationAuthTypes[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.DestinationStorageTypes) > 0 {
		for iNdEx := len(m.DestinationStorageTypes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DestinationStorageTypes[iNdEx])
			copy(dAtA[i:], m.DestinationStorageTypes[iNdEx])
			i = encodeVarintTelemetry(dAtA, i, uint64(len(m.DestinationStorageTypes[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.DestinationSubdirType) > 0 {
		i -= len(m.DestinationSubdirType)
		copy(dAtA[i:], m.DestinationSubdirType)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.DestinationSubdirType)))
		i--
		dAtA[i] = 0x32
	}
	if m.TargetCount != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.TargetCount))
		i--
		dAtA[i] = 0x28
	}
	if m.IsMultiregionTarget {
		i--
		if m.IsMultiregionTarget {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.TargetScope) > 0 {
		i -= len(m.TargetScope)
		copy(dAtA[i:], m.TargetScope)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.TargetScope)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RecoveryType) > 0 {
		i -= len(m.RecoveryType)
		copy(dAtA[i:], m.RecoveryType)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.RecoveryType)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.CommonEventDetails.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTelemetry(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SchemaDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchemaDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Desc != nil {
		{
			size, err := m.Desc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTelemetry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.DescID != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.DescID))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ParentSchemaID != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ParentSchemaID))
		i--
		dAtA[i] = 0x20
	}
	if m.ParentDatabaseID != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ParentDatabaseID))
		i--
		dAtA[i] = 0x18
	}
	if len(m.SnapshotID) > 0 {
		i -= len(m.SnapshotID)
		copy(dAtA[i:], m.SnapshotID)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.SnapshotID)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.CommonEventDetails.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTelemetry(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SchemaSnapshotMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaSnapshotMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchemaSnapshotMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Errors) > 0 {
		for iNdEx := len(m.Errors) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Errors[iNdEx])
			copy(dAtA[i:], m.Errors[iNdEx])
			i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Errors[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.AsOfTimestamp != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.AsOfTimestamp))
		i--
		dAtA[i] = 0x20
	}
	if m.NumRecords != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.NumRecords))
		i--
		dAtA[i] = 0x18
	}
	if len(m.SnapshotID) > 0 {
		i -= len(m.SnapshotID)
		copy(dAtA[i:], m.SnapshotID)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.SnapshotID)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.CommonEventDetails.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTelemetry(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintTelemetry(dAtA []byte, offset int, v uint64) int {
	offset -= sovTelemetry(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SampledQuery) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CommonEventDetails.Size()
	n += 1 + l + sovTelemetry(uint64(l))
	l = m.CommonSQLEventDetails.Size()
	n += 1 + l + sovTelemetry(uint64(l))
	l = m.CommonSQLExecDetails.Size()
	n += 1 + l + sovTelemetry(uint64(l))
	if m.SkippedQueries != 0 {
		n += 1 + sovTelemetry(uint64(m.SkippedQueries))
	}
	if m.CostEstimate != 0 {
		n += 9
	}
	l = len(m.Distribution)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	l = len(m.PlanGist)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	l = len(m.SessionID)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	l = len(m.StatementID)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	l = len(m.TransactionID)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.StatementFingerprintID != 0 {
		n += 1 + sovTelemetry(uint64(m.StatementFingerprintID))
	}
	if m.MaxFullScanRowsEstimate != 0 {
		n += 9
	}
	if m.TotalScanRowsEstimate != 0 {
		n += 9
	}
	if m.OutputRowsEstimate != 0 {
		n += 10
	}
	if m.StatsAvailable {
		n += 3
	}
	if m.NanosSinceStatsCollected != 0 {
		n += 2 + sovTelemetry(uint64(m.NanosSinceStatsCollected))
	}
	if m.BytesRead != 0 {
		n += 2 + sovTelemetry(uint64(m.BytesRead))
	}
	if m.RowsRead != 0 {
		n += 2 + sovTelemetry(uint64(m.RowsRead))
	}
	if m.RowsWritten != 0 {
		n += 2 + sovTelemetry(uint64(m.RowsWritten))
	}
	if m.InnerJoinCount != 0 {
		n += 2 + sovTelemetry(uint64(m.InnerJoinCount))
	}
	if m.LeftOuterJoinCount != 0 {
		n += 2 + sovTelemetry(uint64(m.LeftOuterJoinCount))
	}
	if m.FullOuterJoinCount != 0 {
		n += 2 + sovTelemetry(uint64(m.FullOuterJoinCount))
	}
	if m.SemiJoinCount != 0 {
		n += 2 + sovTelemetry(uint64(m.SemiJoinCount))
	}
	if m.AntiJoinCount != 0 {
		n += 2 + sovTelemetry(uint64(m.AntiJoinCount))
	}
	if m.IntersectAllJoinCount != 0 {
		n += 2 + sovTelemetry(uint64(m.IntersectAllJoinCount))
	}
	if m.ExceptAllJoinCount != 0 {
		n += 2 + sovTelemetry(uint64(m.ExceptAllJoinCount))
	}
	if m.HashJoinCount != 0 {
		n += 2 + sovTelemetry(uint64(m.HashJoinCount))
	}
	if m.CrossJoinCount != 0 {
		n += 2 + sovTelemetry(uint64(m.CrossJoinCount))
	}
	if m.IndexJoinCount != 0 {
		n += 2 + sovTelemetry(uint64(m.IndexJoinCount))
	}
	if m.LookupJoinCount != 0 {
		n += 2 + sovTelemetry(uint64(m.LookupJoinCount))
	}
	if m.MergeJoinCount != 0 {
		n += 2 + sovTelemetry(uint64(m.MergeJoinCount))
	}
	if m.InvertedJoinCount != 0 {
		n += 2 + sovTelemetry(uint64(m.InvertedJoinCount))
	}
	if m.ApplyJoinCount != 0 {
		n += 2 + sovTelemetry(uint64(m.ApplyJoinCount))
	}
	if m.ZigZagJoinCount != 0 {
		n += 2 + sovTelemetry(uint64(m.ZigZagJoinCount))
	}
	return n
}

func (m *CapturedIndexUsageStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CommonEventDetails.Size()
	n += 1 + l + sovTelemetry(uint64(l))
	if m.TotalReadCount != 0 {
		n += 1 + sovTelemetry(uint64(m.TotalReadCount))
	}
	l = len(m.LastRead)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.TableID != 0 {
		n += 1 + sovTelemetry(uint64(m.TableID))
	}
	if m.IndexID != 0 {
		n += 1 + sovTelemetry(uint64(m.IndexID))
	}
	l = len(m.DatabaseName)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	l = len(m.IndexName)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	l = len(m.IndexType)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.IsUnique {
		n += 2
	}
	if m.IsInverted {
		n += 2
	}
	return n
}

func (m *CreateChangefeed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CommonChangefeedEventDetails.Size()
	n += 1 + l + sovTelemetry(uint64(l))
	return n
}

func (m *ChangefeedFailed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CommonChangefeedEventDetails.Size()
	n += 1 + l + sovTelemetry(uint64(l))
	l = len(m.FailureType)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *RecoveryEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CommonEventDetails.Size()
	n += 1 + l + sovTelemetry(uint64(l))
	l = len(m.RecoveryType)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	l = len(m.TargetScope)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.IsMultiregionTarget {
		n += 2
	}
	if m.TargetCount != 0 {
		n += 1 + sovTelemetry(uint64(m.TargetCount))
	}
	l = len(m.DestinationSubdirType)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if len(m.DestinationStorageTypes) > 0 {
		for _, s := range m.DestinationStorageTypes {
			l = len(s)
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	if len(m.DestinationAuthTypes) > 0 {
		for _, s := range m.DestinationAuthTypes {
			l = len(s)
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	if m.IsLocalityAware {
		n += 2
	}
	if m.AsOfInterval != 0 {
		n += 1 + sovTelemetry(uint64(m.AsOfInterval))
	}
	if m.WithRevisionHistory {
		n += 2
	}
	if m.HasEncryptionPassphrase {
		n += 2
	}
	l = len(m.KMSType)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.KMSCount != 0 {
		n += 1 + sovTelemetry(uint64(m.KMSCount))
	}
	if len(m.Options) > 0 {
		for _, s := range m.Options {
			l = len(s)
			n += 2 + l + sovTelemetry(uint64(l))
		}
	}
	l = len(m.DebugPauseOn)
	if l > 0 {
		n += 2 + l + sovTelemetry(uint64(l))
	}
	if m.JobID != 0 {
		n += 2 + sovTelemetry(uint64(m.JobID))
	}
	l = len(m.ResultStatus)
	if l > 0 {
		n += 2 + l + sovTelemetry(uint64(l))
	}
	l = len(m.ErrorText)
	if l > 0 {
		n += 2 + l + sovTelemetry(uint64(l))
	}
	l = len(m.RecurringCron)
	if l > 0 {
		n += 2 + l + sovTelemetry(uint64(l))
	}
	l = len(m.FullBackupCron)
	if l > 0 {
		n += 2 + l + sovTelemetry(uint64(l))
	}
	if m.CustomFirstRunTime != 0 {
		n += 2 + sovTelemetry(uint64(m.CustomFirstRunTime))
	}
	l = len(m.OnExecutionFailure)
	if l > 0 {
		n += 2 + l + sovTelemetry(uint64(l))
	}
	l = len(m.OnPreviousRunning)
	if l > 0 {
		n += 2 + l + sovTelemetry(uint64(l))
	}
	if m.IgnoreExistingBackup {
		n += 3
	}
	return n
}

func (m *SchemaDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CommonEventDetails.Size()
	n += 1 + l + sovTelemetry(uint64(l))
	l = len(m.SnapshotID)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.ParentDatabaseID != 0 {
		n += 1 + sovTelemetry(uint64(m.ParentDatabaseID))
	}
	if m.ParentSchemaID != 0 {
		n += 1 + sovTelemetry(uint64(m.ParentSchemaID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.DescID != 0 {
		n += 1 + sovTelemetry(uint64(m.DescID))
	}
	if m.Desc != nil {
		l = m.Desc.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *SchemaSnapshotMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CommonEventDetails.Size()
	n += 1 + l + sovTelemetry(uint64(l))
	l = len(m.SnapshotID)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.NumRecords != 0 {
		n += 1 + sovTelemetry(uint64(m.NumRecords))
	}
	if m.AsOfTimestamp != 0 {
		n += 1 + sovTelemetry(uint64(m.AsOfTimestamp))
	}
	if len(m.Errors) > 0 {
		for _, s := range m.Errors {
			l = len(s)
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func sovTelemetry(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTelemetry(x uint64) (n int) {
	return sovTelemetry(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SampledQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SampledQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SampledQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonEventDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CommonEventDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonSQLEventDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CommonSQLEventDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonSQLExecDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CommonSQLExecDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkippedQueries", wireType)
			}
			m.SkippedQueries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkippedQueries |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostEstimate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CostEstimate = float64(math.Float64frombits(v))
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Distribution", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Distribution = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanGist", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlanGist = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatementID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatementID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatementFingerprintID", wireType)
			}
			m.StatementFingerprintID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatementFingerprintID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxFullScanRowsEstimate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MaxFullScanRowsEstimate = float64(math.Float64frombits(v))
		case 15:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalScanRowsEstimate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TotalScanRowsEstimate = float64(math.Float64frombits(v))
		case 16:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputRowsEstimate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.OutputRowsEstimate = float64(math.Float64frombits(v))
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatsAvailable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StatsAvailable = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NanosSinceStatsCollected", wireType)
			}
			m.NanosSinceStatsCollected = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NanosSinceStatsCollected |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesRead", wireType)
			}
			m.BytesRead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesRead |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowsRead", wireType)
			}
			m.RowsRead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RowsRead |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowsWritten", wireType)
			}
			m.RowsWritten = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RowsWritten |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InnerJoinCount", wireType)
			}
			m.InnerJoinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InnerJoinCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftOuterJoinCount", wireType)
			}
			m.LeftOuterJoinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeftOuterJoinCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullOuterJoinCount", wireType)
			}
			m.FullOuterJoinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FullOuterJoinCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SemiJoinCount", wireType)
			}
			m.SemiJoinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SemiJoinCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AntiJoinCount", wireType)
			}
			m.AntiJoinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AntiJoinCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntersectAllJoinCount", wireType)
			}
			m.IntersectAllJoinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IntersectAllJoinCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExceptAllJoinCount", wireType)
			}
			m.ExceptAllJoinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExceptAllJoinCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashJoinCount", wireType)
			}
			m.HashJoinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HashJoinCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrossJoinCount", wireType)
			}
			m.CrossJoinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CrossJoinCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexJoinCount", wireType)
			}
			m.IndexJoinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexJoinCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LookupJoinCount", wireType)
			}
			m.LookupJoinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LookupJoinCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MergeJoinCount", wireType)
			}
			m.MergeJoinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MergeJoinCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertedJoinCount", wireType)
			}
			m.InvertedJoinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InvertedJoinCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyJoinCount", wireType)
			}
			m.ApplyJoinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApplyJoinCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZigZagJoinCount", wireType)
			}
			m.ZigZagJoinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ZigZagJoinCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CapturedIndexUsageStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CapturedIndexUsageStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CapturedIndexUsageStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonEventDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CommonEventDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalReadCount", wireType)
			}
			m.TotalReadCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalReadCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRead", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastRead = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatabaseName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUnique", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsUnique = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsInverted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsInverted = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateChangefeed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateChangefeed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateChangefeed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonChangefeedEventDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CommonChangefeedEventDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangefeedFailed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangefeedFailed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangefeedFailed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonChangefeedEventDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CommonChangefeedEventDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailureType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailureType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecoveryEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecoveryEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecoveryEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonEventDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CommonEventDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoveryType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecoveryType = RecoveryEventType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetScope", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetScope = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMultiregionTarget", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMultiregionTarget = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetCount", wireType)
			}
			m.TargetCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationSubdirType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationSubdirType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationStorageTypes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationStorageTypes = append(m.DestinationStorageTypes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationAuthTypes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationAuthTypes = append(m.DestinationAuthTypes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLocalityAware", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLocalityAware = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsOfInterval", wireType)
			}
			m.AsOfInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AsOfInterval |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithRevisionHistory", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithRevisionHistory = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasEncryptionPassphrase", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasEncryptionPassphrase = bool(v != 0)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KMSType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KMSType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KMSCount", wireType)
			}
			m.KMSCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KMSCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Options = append(m.Options, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugPauseOn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DebugPauseOn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			m.JobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResultStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResultStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorText = github_com_cockroachdb_redact.RedactableString(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecurringCron", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecurringCron = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullBackupCron", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FullBackupCron = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomFirstRunTime", wireType)
			}
			m.CustomFirstRunTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CustomFirstRunTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnExecutionFailure", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OnExecutionFailure = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnPreviousRunning", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OnPreviousRunning = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreExistingBackup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IgnoreExistingBackup = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonEventDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CommonEventDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SnapshotID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentDatabaseID", wireType)
			}
			m.ParentDatabaseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentDatabaseID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentSchemaID", wireType)
			}
			m.ParentSchemaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentSchemaID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescID", wireType)
			}
			m.DescID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DescID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Desc == nil {
				m.Desc = &descpb.Descriptor{}
			}
			if err := m.Desc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaSnapshotMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaSnapshotMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaSnapshotMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonEventDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CommonEventDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SnapshotID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumRecords", wireType)
			}
			m.NumRecords = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumRecords |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsOfTimestamp", wireType)
			}
			m.AsOfTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AsOfTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTelemetry(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTelemetry
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTelemetry
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTelemetry
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTelemetry        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTelemetry          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTelemetry = fmt.Errorf("proto: unexpected end of group")
)
