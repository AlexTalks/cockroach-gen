// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: multitenant/mtinfopb/info.proto

package mtinfopb

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	kvpb "github.com/cockroachdb/cockroach/pkg/kv/kvpb"
	tenantcapabilitiespb "github.com/cockroachdb/cockroach/pkg/multitenant/tenantcapabilities/tenantcapabilitiespb"
	github_com_cockroachdb_cockroach_pkg_roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"
	roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"
	github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb "github.com/cockroachdb/cockroach/pkg/sql/catalog/catpb"
	hlc "github.com/cockroachdb/cockroach/pkg/util/hlc"
	github_com_cockroachdb_cockroach_pkg_util_uuid "github.com/cockroachdb/cockroach/pkg/util/uuid"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// The state of the tenant's logical keyspace (DEPRECATED).
// This enum is only used when the data_state column is NULL.
type ProtoInfo_DeprecatedDataState int32

const (
	// Tenant data is ready and SQL servers can access it.
	// DEPRECATED. Use DataStateReady.
	ProtoInfo_READY ProtoInfo_DeprecatedDataState = 0
	// Tenant data is being added. Not available for SQL sessions.
	// DEPRECATED. Use DataStateAdd.
	ProtoInfo_ADD ProtoInfo_DeprecatedDataState = 1
	// Tenant data is being dropped. Not available for SQL sessions.
	// DEPRECATED. Use DataStateDrop.
	ProtoInfo_DROP ProtoInfo_DeprecatedDataState = 2
)

var ProtoInfo_DeprecatedDataState_name = map[int32]string{
	0: "READY",
	1: "ADD",
	2: "DROP",
}

var ProtoInfo_DeprecatedDataState_value = map[string]int32{
	"READY": 0,
	"ADD":   1,
	"DROP":  2,
}

func (x ProtoInfo_DeprecatedDataState) Enum() *ProtoInfo_DeprecatedDataState {
	p := new(ProtoInfo_DeprecatedDataState)
	*p = x
	return p
}

func (x ProtoInfo_DeprecatedDataState) String() string {
	return proto.EnumName(ProtoInfo_DeprecatedDataState_name, int32(x))
}

func (x *ProtoInfo_DeprecatedDataState) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ProtoInfo_DeprecatedDataState_value, data, "ProtoInfo_DeprecatedDataState")
	if err != nil {
		return err
	}
	*x = ProtoInfo_DeprecatedDataState(value)
	return nil
}

func (ProtoInfo_DeprecatedDataState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_22ea1ce3469aae16, []int{0, 0}
}

// ProtoInfo represents the metadata for a tenant as
// stored in the "info" column of the "system.tenants" table.
type ProtoInfo struct {
	// ID is the internal numeric identifier of the tenant (DEPRECATED).
	// This field is redundant with the id column in system.tenants.
	DeprecatedID uint64 `protobuf:"varint,1,opt,name=deprecated_id,json=deprecatedId" json:"deprecated_id"`
	// DeprecatedDataState is the state of the tenant's keyspace (DEPRECATED).
	DeprecatedDataState ProtoInfo_DeprecatedDataState `protobuf:"varint,2,opt,name=deprecated_data_state,json=deprecatedDataState,enum=cockroach.multitenant.ProtoInfo_DeprecatedDataState" json:"deprecated_data_state"`
	// DroppedName is the name the tenant had before DROP VIRTUAL
	// CLUSTER was run on the tenant. It should be empty for active or
	// adding tenants.
	DroppedName github_com_cockroachdb_cockroach_pkg_roachpb.TenantName `protobuf:"bytes,3,opt,name=dropped_name,json=droppedName,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.TenantName" json:"dropped_name"`
	// PhysicalReplicationConsumerJobID is set if this tenant is the target tenant
	// of a running tenant replication job.
	PhysicalReplicationConsumerJobID github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.JobID `protobuf:"varint,4,opt,name=physical_replication_consumer_job_id,json=physicalReplicationConsumerJobId,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/catpb.JobID" json:"physical_replication_consumer_job_id"`
	// PhysicalReplicationProducerJobIDs contains any physical
	// replication producer jobs that are using this tenant as a source.
	PhysicalReplicationProducerJobIDs []github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.JobID `protobuf:"varint,6,rep,name=physical_replication_producer_job_ids,json=physicalReplicationProducerJobIds,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/catpb.JobID" json:"physical_replication_producer_job_ids,omitempty"`
	// Capabilities encapsulate a set of capabilities that a specific tenant
	// possesses.
	Capabilities tenantcapabilitiespb.TenantCapabilities `protobuf:"bytes,5,opt,name=capabilities" json:"capabilities"`
	// If this tenant was previously a physical replication target that
	// was promoted, PreviousSourceTenant holds information about the
	// source cluster of that replication stream.
	PreviousSourceTenant *PreviousSourceTenant `protobuf:"bytes,7,opt,name=previous_source_tenant,json=previousSourceTenant" json:"previous_source_tenant,omitempty"`
	// LastReverTenantTimestamp is the timestamp at which we last called
	// RevertRange in preparation for a stream resumption into this
	// tenant.
	//
	// This is cleared on ALTER VIRTUAL CLUSTER START SERVICE and CREATE
	// VIRTUAL CLUSTER FROM REPLICATION STREAM.
	LastRevertTenantTimestamp hlc.Timestamp `protobuf:"bytes,8,opt,name=last_revert_tenant_timestamp,json=lastRevertTenantTimestamp" json:"last_revert_tenant_timestamp"`
}

func (m *ProtoInfo) Reset()         { *m = ProtoInfo{} }
func (m *ProtoInfo) String() string { return proto.CompactTextString(m) }
func (*ProtoInfo) ProtoMessage()    {}
func (*ProtoInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_22ea1ce3469aae16, []int{0}
}
func (m *ProtoInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProtoInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ProtoInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtoInfo.Merge(m, src)
}
func (m *ProtoInfo) XXX_Size() int {
	return m.Size()
}
func (m *ProtoInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtoInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ProtoInfo proto.InternalMessageInfo

type PreviousSourceTenant struct {
	// TODO(ssd): It would be nice to store something here that
	// identified a particular MVCC history so that we could also use
	// this to compare against things like restored tenants.
	ClusterID github_com_cockroachdb_cockroach_pkg_util_uuid.UUID `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,customtype=github.com/cockroachdb/cockroach/pkg/util/uuid.UUID" json:"cluster_id"`
	TenantID  roachpb.TenantID                                    `protobuf:"bytes,2,opt,name=tenant_id,json=tenantId" json:"tenant_id"`
	// CutoverTimestamp is the time at which we cutover from the source
	// tenant.
	CutoverTimestamp hlc.Timestamp `protobuf:"bytes,3,opt,name=cutover_timestamp,json=cutoverTimestamp" json:"cutover_timestamp"`
}

func (m *PreviousSourceTenant) Reset()         { *m = PreviousSourceTenant{} }
func (m *PreviousSourceTenant) String() string { return proto.CompactTextString(m) }
func (*PreviousSourceTenant) ProtoMessage()    {}
func (*PreviousSourceTenant) Descriptor() ([]byte, []int) {
	return fileDescriptor_22ea1ce3469aae16, []int{1}
}
func (m *PreviousSourceTenant) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PreviousSourceTenant) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PreviousSourceTenant) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PreviousSourceTenant.Merge(m, src)
}
func (m *PreviousSourceTenant) XXX_Size() int {
	return m.Size()
}
func (m *PreviousSourceTenant) XXX_DiscardUnknown() {
	xxx_messageInfo_PreviousSourceTenant.DiscardUnknown(m)
}

var xxx_messageInfo_PreviousSourceTenant proto.InternalMessageInfo

// SQLInfo contain the additional tenant metadata from the other
// columns in system.tenants not otherwise encoded in ProtoInfo.
type SQLInfo struct {
	ID uint64 `protobuf:"varint,1,opt,name=id" json:"id"`
	// Copy of the name column in system.tenants.
	Name github_com_cockroachdb_cockroach_pkg_roachpb.TenantName `protobuf:"bytes,2,opt,name=name,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.TenantName" json:"name"`
	// Copy of the data_state column in system.tenants.
	DataState TenantDataState `protobuf:"varint,3,opt,name=data_state,json=dataState,casttype=TenantDataState" json:"data_state"`
	// Copy of the service_mode column in system.tenants.
	ServiceMode TenantServiceMode `protobuf:"varint,4,opt,name=service_mode,json=serviceMode,casttype=TenantServiceMode" json:"service_mode"`
}

func (m *SQLInfo) Reset()         { *m = SQLInfo{} }
func (m *SQLInfo) String() string { return proto.CompactTextString(m) }
func (*SQLInfo) ProtoMessage()    {}
func (*SQLInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_22ea1ce3469aae16, []int{2}
}
func (m *SQLInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SQLInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SQLInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SQLInfo.Merge(m, src)
}
func (m *SQLInfo) XXX_Size() int {
	return m.Size()
}
func (m *SQLInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SQLInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SQLInfo proto.InternalMessageInfo

// UsageInfo contains metadata related to cost control and consumption. In a
// running cluster, this data is stored in the system.tenant_usage table.
// Each field corresponds has a corresponding column in that table.
type UsageInfo struct {
	RUBurstLimit float64 `protobuf:"fixed64,1,opt,name=ru_burst_limit,json=ruBurstLimit" json:"ru_burst_limit"`
	RURefillRate float64 `protobuf:"fixed64,2,opt,name=ru_refill_rate,json=ruRefillRate" json:"ru_refill_rate"`
	RUCurrent    float64 `protobuf:"fixed64,3,opt,name=ru_current,json=ruCurrent" json:"ru_current"`
	// All-time consumption for this tenant. Each field has a corresponding column
	// in system.tenant_usage.
	Consumption kvpb.TenantConsumption `protobuf:"bytes,4,opt,name=consumption" json:"consumption"`
}

func (m *UsageInfo) Reset()         { *m = UsageInfo{} }
func (m *UsageInfo) String() string { return proto.CompactTextString(m) }
func (*UsageInfo) ProtoMessage()    {}
func (*UsageInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_22ea1ce3469aae16, []int{3}
}
func (m *UsageInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UsageInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UsageInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UsageInfo.Merge(m, src)
}
func (m *UsageInfo) XXX_Size() int {
	return m.Size()
}
func (m *UsageInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_UsageInfo.DiscardUnknown(m)
}

var xxx_messageInfo_UsageInfo proto.InternalMessageInfo

// SettingOverride represents a cluster setting override for one tenant.
type SettingOverride struct {
	Name      string  `protobuf:"bytes,1,opt,name=name" json:"name"`
	Value     string  `protobuf:"bytes,2,opt,name=value" json:"value"`
	ValueType string  `protobuf:"bytes,3,opt,name=value_type,json=valueType" json:"value_type"`
	Reason    *string `protobuf:"bytes,4,opt,name=reason" json:"reason,omitempty"`
}

func (m *SettingOverride) Reset()         { *m = SettingOverride{} }
func (m *SettingOverride) String() string { return proto.CompactTextString(m) }
func (*SettingOverride) ProtoMessage()    {}
func (*SettingOverride) Descriptor() ([]byte, []int) {
	return fileDescriptor_22ea1ce3469aae16, []int{4}
}
func (m *SettingOverride) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SettingOverride) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SettingOverride) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SettingOverride.Merge(m, src)
}
func (m *SettingOverride) XXX_Size() int {
	return m.Size()
}
func (m *SettingOverride) XXX_DiscardUnknown() {
	xxx_messageInfo_SettingOverride.DiscardUnknown(m)
}

var xxx_messageInfo_SettingOverride proto.InternalMessageInfo

// TenantInfoWithUsage contains the information for a tenant in a multi-tenant
// cluster plus metadata related to cost control and consumption and setting overrides.
type TenantInfoWithUsage struct {
	ProtoInfo        `protobuf:"bytes,1,opt,name=info,embedded=info" json:"info"`
	Usage            *UsageInfo `protobuf:"bytes,2,opt,name=usage" json:"usage,omitempty"`
	SQLInfo          `protobuf:"bytes,3,opt,name=extra_columns,json=extraColumns,embedded=extra_columns" json:"extra_columns"`
	SettingOverrides []*SettingOverride `protobuf:"bytes,4,rep,name=setting_overrides,json=settingOverrides" json:"setting_overrides,omitempty"`
}

func (m *TenantInfoWithUsage) Reset()         { *m = TenantInfoWithUsage{} }
func (m *TenantInfoWithUsage) String() string { return proto.CompactTextString(m) }
func (*TenantInfoWithUsage) ProtoMessage()    {}
func (*TenantInfoWithUsage) Descriptor() ([]byte, []int) {
	return fileDescriptor_22ea1ce3469aae16, []int{5}
}
func (m *TenantInfoWithUsage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TenantInfoWithUsage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TenantInfoWithUsage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TenantInfoWithUsage.Merge(m, src)
}
func (m *TenantInfoWithUsage) XXX_Size() int {
	return m.Size()
}
func (m *TenantInfoWithUsage) XXX_DiscardUnknown() {
	xxx_messageInfo_TenantInfoWithUsage.DiscardUnknown(m)
}

var xxx_messageInfo_TenantInfoWithUsage proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("cockroach.multitenant.ProtoInfo_DeprecatedDataState", ProtoInfo_DeprecatedDataState_name, ProtoInfo_DeprecatedDataState_value)
	proto.RegisterType((*ProtoInfo)(nil), "cockroach.multitenant.ProtoInfo")
	proto.RegisterType((*PreviousSourceTenant)(nil), "cockroach.multitenant.PreviousSourceTenant")
	proto.RegisterType((*SQLInfo)(nil), "cockroach.multitenant.SQLInfo")
	proto.RegisterType((*UsageInfo)(nil), "cockroach.multitenant.UsageInfo")
	proto.RegisterType((*SettingOverride)(nil), "cockroach.multitenant.SettingOverride")
	proto.RegisterType((*TenantInfoWithUsage)(nil), "cockroach.multitenant.TenantInfoWithUsage")
}

func init() { proto.RegisterFile("multitenant/mtinfopb/info.proto", fileDescriptor_22ea1ce3469aae16) }

var fileDescriptor_22ea1ce3469aae16 = []byte{
	// 1132 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0xdf, 0x8e, 0xdb, 0x44,
	0x17, 0x8f, 0x93, 0x6c, 0x77, 0x3d, 0xc9, 0xb6, 0xd9, 0xe9, 0xb6, 0x5f, 0xba, 0x1f, 0x24, 0x69,
	0x29, 0x28, 0x12, 0x52, 0x8c, 0x52, 0x54, 0xd4, 0xaa, 0x2a, 0xaa, 0x63, 0x10, 0xa9, 0x5a, 0xba,
	0x4c, 0xba, 0x42, 0xc0, 0x85, 0x35, 0xb6, 0x67, 0x93, 0x61, 0x1d, 0x8f, 0x19, 0x8f, 0x23, 0xf6,
	0x11, 0xe0, 0x8a, 0x47, 0x40, 0xe2, 0x21, 0xca, 0x23, 0xec, 0xe5, 0x5e, 0x56, 0x5c, 0x44, 0x90,
	0xbd, 0xe1, 0x09, 0xb8, 0xa8, 0x84, 0x84, 0x3c, 0x33, 0x49, 0xbc, 0x22, 0x29, 0x2b, 0xc1, 0x95,
	0x67, 0xce, 0x9c, 0xdf, 0xef, 0x9c, 0x39, 0xff, 0xc6, 0xa0, 0x39, 0x4e, 0x43, 0x41, 0x05, 0x89,
	0x70, 0x24, 0xac, 0xb1, 0xa0, 0xd1, 0x21, 0x8b, 0x3d, 0x2b, 0xfb, 0x74, 0x62, 0xce, 0x04, 0x83,
	0xd7, 0x7c, 0xe6, 0x1f, 0x71, 0x86, 0xfd, 0x51, 0x27, 0xa7, 0xba, 0xb7, 0x3b, 0x64, 0x43, 0x26,
	0x35, 0xac, 0x6c, 0xa5, 0x94, 0xf7, 0x76, 0x8e, 0x26, 0xd6, 0xd1, 0x24, 0xf6, 0x2c, 0x1c, 0x53,
	0x2d, 0x82, 0x12, 0x1b, 0x7b, 0x56, 0x80, 0x05, 0xd6, 0xb2, 0x8f, 0xf3, 0x46, 0xd5, 0xc7, 0xc7,
	0x31, 0xf6, 0x68, 0x48, 0x05, 0x25, 0xc9, 0x0a, 0x51, 0xec, 0x59, 0xf9, 0xad, 0xe6, 0xa9, 0xa7,
	0x82, 0x86, 0xd6, 0x28, 0xf4, 0x2d, 0x41, 0xc7, 0x24, 0x11, 0x78, 0x1c, 0xab, 0x93, 0x5b, 0x7f,
	0x6e, 0x02, 0x73, 0x3f, 0x5b, 0xf5, 0xa3, 0x43, 0x06, 0xef, 0x81, 0xed, 0x80, 0xc4, 0x9c, 0xf8,
	0x58, 0x90, 0xc0, 0xa5, 0x41, 0xdd, 0x68, 0x19, 0xed, 0xb2, 0xbd, 0x7b, 0x32, 0x6d, 0x16, 0x66,
	0xd3, 0x66, 0xd5, 0x59, 0x1c, 0xf6, 0x1d, 0x54, 0x5d, 0xaa, 0xf6, 0x03, 0x18, 0x81, 0x6b, 0x39,
	0x68, 0x76, 0x07, 0x37, 0x11, 0x58, 0x90, 0x7a, 0xb1, 0x65, 0xb4, 0x2f, 0x77, 0xdf, 0xef, 0xac,
	0x0c, 0x4f, 0x67, 0x61, 0xbb, 0xb3, 0xe4, 0x76, 0xb0, 0xc0, 0x83, 0x0c, 0x6b, 0x97, 0x33, 0xc3,
	0xe8, 0x6a, 0xf0, 0xf7, 0x23, 0xe8, 0x81, 0x6a, 0xc0, 0x59, 0x1c, 0x93, 0xc0, 0x8d, 0xf0, 0x98,
	0xd4, 0x4b, 0x2d, 0xa3, 0x6d, 0xda, 0x1f, 0x66, 0x80, 0x57, 0xd3, 0xe6, 0x07, 0x43, 0x2a, 0x46,
	0xa9, 0xd7, 0xf1, 0xd9, 0xd8, 0x5a, 0x18, 0x0e, 0xbc, 0xe5, 0xda, 0x8a, 0x8f, 0x86, 0x96, 0x8e,
	0x78, 0xe7, 0xb9, 0xf4, 0xe5, 0x53, 0x3c, 0x26, 0xa8, 0xa2, 0x49, 0xb3, 0x0d, 0xfc, 0xd9, 0x00,
	0xb7, 0xe3, 0xd1, 0x71, 0x42, 0x7d, 0x1c, 0xba, 0x9c, 0xc4, 0x21, 0xf5, 0xb1, 0xa0, 0x2c, 0x72,
	0x7d, 0x16, 0x25, 0xe9, 0x98, 0x70, 0xf7, 0x6b, 0xe6, 0x65, 0x61, 0x2a, 0xb7, 0x8c, 0x76, 0xc9,
	0x1e, 0xe9, 0x30, 0xb5, 0xf6, 0x35, 0x06, 0x2d, 0x21, 0x3d, 0x8d, 0x78, 0xcc, 0xbc, 0xbe, 0xf3,
	0x6a, 0xda, 0x7c, 0x70, 0x21, 0x07, 0x93, 0x6f, 0x42, 0xcb, 0xc7, 0x02, 0x87, 0x6c, 0x98, 0x7d,
	0x63, 0xaf, 0x23, 0xf1, 0xa8, 0x15, 0xbf, 0xde, 0x42, 0x00, 0x5f, 0x18, 0xe0, 0xed, 0x95, 0xae,
	0xc7, 0x9c, 0x05, 0xa9, 0xbf, 0x70, 0x3d, 0xa9, 0x5f, 0x6a, 0x95, 0xda, 0x25, 0x9b, 0xcc, 0xa6,
	0xcd, 0x9b, 0x2b, 0xfc, 0xde, 0xd7, 0xea, 0xd2, 0x6e, 0xf2, 0xaf, 0x1d, 0xbf, 0x19, 0xbf, 0xde,
	0x44, 0x90, 0xc0, 0x11, 0xa8, 0xe6, 0x2b, 0xb8, 0xbe, 0xd1, 0x32, 0xda, 0x95, 0xee, 0xc3, 0x35,
	0xf5, 0xb3, 0xaa, 0x03, 0x74, 0x3e, 0x7b, 0x39, 0xa1, 0xae, 0xa4, 0x73, 0xcc, 0x10, 0x83, 0xeb,
	0x31, 0x27, 0x13, 0xca, 0xd2, 0xc4, 0x4d, 0x58, 0xca, 0x7d, 0xe2, 0x2a, 0xba, 0xfa, 0xa6, 0xb4,
	0xf9, 0xee, 0xda, 0x9a, 0x55, 0xa0, 0x81, 0xc4, 0x28, 0x63, 0x68, 0x37, 0x5e, 0x21, 0x85, 0x01,
	0x78, 0x23, 0xc4, 0x89, 0x70, 0x39, 0x99, 0x10, 0x2e, 0x34, 0xbd, 0xbb, 0x68, 0xc2, 0xfa, 0x96,
	0x34, 0xf4, 0x66, 0xce, 0x50, 0xd6, 0xa9, 0x9d, 0x51, 0xe8, 0x77, 0x9e, 0xcf, 0x95, 0xb4, 0xef,
	0x37, 0x32, 0x22, 0x24, 0x79, 0x14, 0xf9, 0x42, 0xe1, 0xd6, 0x1d, 0x70, 0x75, 0x45, 0xf7, 0x40,
	0x13, 0x6c, 0xa0, 0x8f, 0x1e, 0x39, 0x5f, 0xd4, 0x0a, 0x70, 0x13, 0x94, 0x1e, 0x39, 0x4e, 0xcd,
	0x80, 0x5b, 0xa0, 0xec, 0xa0, 0x67, 0xfb, 0xb5, 0xe2, 0xfd, 0xf2, 0xef, 0x3f, 0x36, 0x8d, 0x5b,
	0x3f, 0x15, 0xc1, 0xee, 0xaa, 0xfb, 0xc0, 0x21, 0x00, 0x7e, 0x98, 0x26, 0x82, 0xf0, 0xf9, 0x1c,
	0xa8, 0xda, 0x9f, 0x64, 0x8e, 0xfc, 0x32, 0x6d, 0xde, 0xb9, 0x50, 0x0d, 0xc8, 0x99, 0x93, 0xa6,
	0x34, 0xe8, 0x1c, 0x1c, 0xf4, 0x9d, 0xd9, 0xb4, 0x69, 0xf6, 0x14, 0x61, 0xdf, 0x41, 0xa6, 0xe6,
	0xee, 0x07, 0xf0, 0x31, 0x30, 0x75, 0x58, 0x68, 0x20, 0x87, 0x45, 0xa5, 0xfb, 0xff, 0x5c, 0x3c,
	0xce, 0xf7, 0x68, 0xdf, 0xb1, 0x6b, 0xba, 0xcb, 0xb6, 0xe6, 0x12, 0xb4, 0xa5, 0xf0, 0xfd, 0x00,
	0xee, 0x83, 0x1d, 0x3f, 0x15, 0x6c, 0x42, 0x78, 0x2e, 0xc6, 0xa5, 0x8b, 0xc7, 0xb8, 0xa6, 0xd1,
	0x0b, 0xb9, 0x8e, 0xd2, 0x1f, 0x06, 0xd8, 0x1c, 0x7c, 0xf6, 0x44, 0xce, 0xc8, 0x3d, 0x50, 0x5c,
	0x0c, 0x46, 0xa0, 0x7d, 0x29, 0xf6, 0x1d, 0x54, 0xa4, 0x01, 0x1c, 0x80, 0xb2, 0x1c, 0x46, 0xc5,
	0xff, 0x66, 0x18, 0x49, 0x32, 0x78, 0x17, 0x80, 0xdc, 0x38, 0xcd, 0x6e, 0xb3, 0x6d, 0xff, 0x4f,
	0x53, 0x5f, 0x51, 0xda, 0x8b, 0x9c, 0x23, 0x33, 0x58, 0xa4, 0xff, 0x01, 0xa8, 0x26, 0x84, 0x4f,
	0xa8, 0x4f, 0xdc, 0x31, 0x0b, 0x88, 0x1c, 0x52, 0xdb, 0xf6, 0x0d, 0x8d, 0xdc, 0x51, 0xc8, 0x81,
	0xd2, 0x78, 0xca, 0x02, 0x82, 0x2a, 0xc9, 0x72, 0xa3, 0x2f, 0xfe, 0x5d, 0x11, 0x98, 0x07, 0x09,
	0x1e, 0x12, 0x79, 0xf5, 0xfb, 0xe0, 0x32, 0x4f, 0x5d, 0x2f, 0xe5, 0x89, 0x70, 0x43, 0x3a, 0xa6,
	0x42, 0x86, 0xc1, 0x58, 0xbe, 0x0f, 0xe8, 0xc0, 0xce, 0x0e, 0x9f, 0x64, 0x67, 0xa8, 0xca, 0xd3,
	0xe5, 0x4e, 0x63, 0x39, 0x39, 0xa4, 0x61, 0xe8, 0xf2, 0xf9, 0xc3, 0x70, 0x0e, 0x8b, 0xe4, 0x21,
	0xca, 0xae, 0x51, 0xe5, 0xe9, 0x72, 0x07, 0xdf, 0x03, 0x80, 0xa7, 0xae, 0x9f, 0x72, 0x4e, 0x22,
	0x21, 0x23, 0x60, 0xd8, 0x3b, 0x1a, 0x67, 0xa2, 0x83, 0x9e, 0x3a, 0x40, 0x26, 0x4f, 0xf5, 0x12,
	0x3e, 0x01, 0x15, 0x35, 0xa3, 0xe3, 0x6c, 0xc2, 0xc8, 0xab, 0x57, 0xba, 0xb7, 0xd7, 0x96, 0x55,
	0x6f, 0xa9, 0xab, 0x2b, 0x21, 0x0f, 0xd7, 0xb1, 0xf8, 0xde, 0x00, 0x57, 0x06, 0x44, 0x08, 0x1a,
	0x0d, 0x9f, 0x4d, 0x08, 0xe7, 0x34, 0x20, 0xb0, 0xae, 0x13, 0x6e, 0xc8, 0x84, 0x2b, 0xa8, 0xca,
	0xda, 0x1e, 0xd8, 0x98, 0xe0, 0x30, 0x9d, 0xd7, 0x82, 0x3a, 0x52, 0x22, 0xf8, 0x16, 0x00, 0x72,
	0xe1, 0x8a, 0xe3, 0x78, 0xfe, 0x72, 0x29, 0x05, 0x53, 0xca, 0x9f, 0x1f, 0xc7, 0x04, 0x5e, 0x07,
	0x97, 0x38, 0xc1, 0x89, 0xf6, 0xde, 0x44, 0x7a, 0xa7, 0x9d, 0x79, 0x51, 0x04, 0x57, 0x75, 0x03,
	0x44, 0x87, 0xec, 0x73, 0x2a, 0x46, 0x32, 0x4d, 0xf0, 0x21, 0x28, 0x67, 0xff, 0x24, 0xd2, 0xa1,
	0x4a, 0xb7, 0xf5, 0x4f, 0xaf, 0xae, 0xbd, 0x95, 0x99, 0x3d, 0x9d, 0x36, 0x0d, 0x24, 0x71, 0xf0,
	0x2e, 0xd8, 0x48, 0x33, 0x22, 0xdd, 0x89, 0xeb, 0x08, 0x16, 0x35, 0x81, 0x94, 0x3a, 0x7c, 0x0a,
	0xb6, 0xc9, 0xb7, 0x82, 0x63, 0xd7, 0x67, 0x61, 0x3a, 0x8e, 0x12, 0xdd, 0x75, 0x8d, 0x35, 0x78,
	0xdd, 0x4c, 0x39, 0xf3, 0x55, 0x09, 0xef, 0x29, 0x34, 0x1c, 0x80, 0x9d, 0x44, 0x85, 0xda, 0x65,
	0x3a, 0xd6, 0x49, 0xbd, 0xdc, 0x2a, 0xb5, 0x2b, 0xdd, 0x77, 0xd6, 0x51, 0x9e, 0x4f, 0x0d, 0xaa,
	0x25, 0xe7, 0x05, 0x89, 0x8a, 0x9c, 0xfd, 0xd5, 0xc9, 0x6f, 0x8d, 0xc2, 0xc9, 0xac, 0x61, 0x9c,
	0xce, 0x1a, 0xc6, 0xcb, 0x59, 0xc3, 0xf8, 0x75, 0xd6, 0x30, 0x7e, 0x38, 0x6b, 0x14, 0x4e, 0xcf,
	0x1a, 0x85, 0x97, 0x67, 0x8d, 0xc2, 0x97, 0xf7, 0x2e, 0xd4, 0xaf, 0xab, 0xfe, 0x07, 0xff, 0x0a,
	0x00, 0x00, 0xff, 0xff, 0x22, 0xb4, 0x5f, 0x7d, 0x26, 0x0a, 0x00, 0x00,
}

func (this *ProtoInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtoInfo)
	if !ok {
		that2, ok := that.(ProtoInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DeprecatedID != that1.DeprecatedID {
		return false
	}
	if this.DeprecatedDataState != that1.DeprecatedDataState {
		return false
	}
	if this.DroppedName != that1.DroppedName {
		return false
	}
	if this.PhysicalReplicationConsumerJobID != that1.PhysicalReplicationConsumerJobID {
		return false
	}
	if len(this.PhysicalReplicationProducerJobIDs) != len(that1.PhysicalReplicationProducerJobIDs) {
		return false
	}
	for i := range this.PhysicalReplicationProducerJobIDs {
		if this.PhysicalReplicationProducerJobIDs[i] != that1.PhysicalReplicationProducerJobIDs[i] {
			return false
		}
	}
	if !this.Capabilities.Equal(&that1.Capabilities) {
		return false
	}
	if !this.PreviousSourceTenant.Equal(that1.PreviousSourceTenant) {
		return false
	}
	if !this.LastRevertTenantTimestamp.Equal(&that1.LastRevertTenantTimestamp) {
		return false
	}
	return true
}
func (this *PreviousSourceTenant) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PreviousSourceTenant)
	if !ok {
		that2, ok := that.(PreviousSourceTenant)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ClusterID.Equal(that1.ClusterID) {
		return false
	}
	if !this.TenantID.Equal(&that1.TenantID) {
		return false
	}
	if !this.CutoverTimestamp.Equal(&that1.CutoverTimestamp) {
		return false
	}
	return true
}
func (this *SQLInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SQLInfo)
	if !ok {
		that2, ok := that.(SQLInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ID != that1.ID {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.DataState != that1.DataState {
		return false
	}
	if this.ServiceMode != that1.ServiceMode {
		return false
	}
	return true
}
func (this *UsageInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UsageInfo)
	if !ok {
		that2, ok := that.(UsageInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RUBurstLimit != that1.RUBurstLimit {
		return false
	}
	if this.RURefillRate != that1.RURefillRate {
		return false
	}
	if this.RUCurrent != that1.RUCurrent {
		return false
	}
	if !this.Consumption.Equal(&that1.Consumption) {
		return false
	}
	return true
}
func (this *SettingOverride) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SettingOverride)
	if !ok {
		that2, ok := that.(SettingOverride)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if this.ValueType != that1.ValueType {
		return false
	}
	if this.Reason != nil && that1.Reason != nil {
		if *this.Reason != *that1.Reason {
			return false
		}
	} else if this.Reason != nil {
		return false
	} else if that1.Reason != nil {
		return false
	}
	return true
}
func (this *TenantInfoWithUsage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TenantInfoWithUsage)
	if !ok {
		that2, ok := that.(TenantInfoWithUsage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ProtoInfo.Equal(&that1.ProtoInfo) {
		return false
	}
	if !this.Usage.Equal(that1.Usage) {
		return false
	}
	if !this.SQLInfo.Equal(&that1.SQLInfo) {
		return false
	}
	if len(this.SettingOverrides) != len(that1.SettingOverrides) {
		return false
	}
	for i := range this.SettingOverrides {
		if !this.SettingOverrides[i].Equal(that1.SettingOverrides[i]) {
			return false
		}
	}
	return true
}
func (m *ProtoInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtoInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtoInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.LastRevertTenantTimestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintInfo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if m.PreviousSourceTenant != nil {
		{
			size, err := m.PreviousSourceTenant.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInfo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.PhysicalReplicationProducerJobIDs) > 0 {
		for iNdEx := len(m.PhysicalReplicationProducerJobIDs) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintInfo(dAtA, i, uint64(m.PhysicalReplicationProducerJobIDs[iNdEx]))
			i--
			dAtA[i] = 0x30
		}
	}
	{
		size, err := m.Capabilities.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintInfo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	i = encodeVarintInfo(dAtA, i, uint64(m.PhysicalReplicationConsumerJobID))
	i--
	dAtA[i] = 0x20
	i -= len(m.DroppedName)
	copy(dAtA[i:], m.DroppedName)
	i = encodeVarintInfo(dAtA, i, uint64(len(m.DroppedName)))
	i--
	dAtA[i] = 0x1a
	i = encodeVarintInfo(dAtA, i, uint64(m.DeprecatedDataState))
	i--
	dAtA[i] = 0x10
	i = encodeVarintInfo(dAtA, i, uint64(m.DeprecatedID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *PreviousSourceTenant) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PreviousSourceTenant) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PreviousSourceTenant) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.CutoverTimestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintInfo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.TenantID.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintInfo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.ClusterID.Size()
		i -= size
		if _, err := m.ClusterID.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintInfo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SQLInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SQLInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SQLInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintInfo(dAtA, i, uint64(m.ServiceMode))
	i--
	dAtA[i] = 0x20
	i = encodeVarintInfo(dAtA, i, uint64(m.DataState))
	i--
	dAtA[i] = 0x18
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintInfo(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0x12
	i = encodeVarintInfo(dAtA, i, uint64(m.ID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *UsageInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UsageInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UsageInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Consumption.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintInfo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.RUCurrent))))
	i--
	dAtA[i] = 0x19
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.RURefillRate))))
	i--
	dAtA[i] = 0x11
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.RUBurstLimit))))
	i--
	dAtA[i] = 0x9
	return len(dAtA) - i, nil
}

func (m *SettingOverride) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SettingOverride) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SettingOverride) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Reason != nil {
		i -= len(*m.Reason)
		copy(dAtA[i:], *m.Reason)
		i = encodeVarintInfo(dAtA, i, uint64(len(*m.Reason)))
		i--
		dAtA[i] = 0x22
	}
	i -= len(m.ValueType)
	copy(dAtA[i:], m.ValueType)
	i = encodeVarintInfo(dAtA, i, uint64(len(m.ValueType)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.Value)
	copy(dAtA[i:], m.Value)
	i = encodeVarintInfo(dAtA, i, uint64(len(m.Value)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintInfo(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TenantInfoWithUsage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TenantInfoWithUsage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TenantInfoWithUsage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SettingOverrides) > 0 {
		for iNdEx := len(m.SettingOverrides) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SettingOverrides[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInfo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	{
		size, err := m.SQLInfo.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintInfo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Usage != nil {
		{
			size, err := m.Usage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInfo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.ProtoInfo.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintInfo(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintInfo(dAtA []byte, offset int, v uint64) int {
	offset -= sovInfo(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ProtoInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovInfo(uint64(m.DeprecatedID))
	n += 1 + sovInfo(uint64(m.DeprecatedDataState))
	l = len(m.DroppedName)
	n += 1 + l + sovInfo(uint64(l))
	n += 1 + sovInfo(uint64(m.PhysicalReplicationConsumerJobID))
	l = m.Capabilities.Size()
	n += 1 + l + sovInfo(uint64(l))
	if len(m.PhysicalReplicationProducerJobIDs) > 0 {
		for _, e := range m.PhysicalReplicationProducerJobIDs {
			n += 1 + sovInfo(uint64(e))
		}
	}
	if m.PreviousSourceTenant != nil {
		l = m.PreviousSourceTenant.Size()
		n += 1 + l + sovInfo(uint64(l))
	}
	l = m.LastRevertTenantTimestamp.Size()
	n += 1 + l + sovInfo(uint64(l))
	return n
}

func (m *PreviousSourceTenant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ClusterID.Size()
	n += 1 + l + sovInfo(uint64(l))
	l = m.TenantID.Size()
	n += 1 + l + sovInfo(uint64(l))
	l = m.CutoverTimestamp.Size()
	n += 1 + l + sovInfo(uint64(l))
	return n
}

func (m *SQLInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovInfo(uint64(m.ID))
	l = len(m.Name)
	n += 1 + l + sovInfo(uint64(l))
	n += 1 + sovInfo(uint64(m.DataState))
	n += 1 + sovInfo(uint64(m.ServiceMode))
	return n
}

func (m *UsageInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	n += 9
	n += 9
	l = m.Consumption.Size()
	n += 1 + l + sovInfo(uint64(l))
	return n
}

func (m *SettingOverride) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovInfo(uint64(l))
	l = len(m.Value)
	n += 1 + l + sovInfo(uint64(l))
	l = len(m.ValueType)
	n += 1 + l + sovInfo(uint64(l))
	if m.Reason != nil {
		l = len(*m.Reason)
		n += 1 + l + sovInfo(uint64(l))
	}
	return n
}

func (m *TenantInfoWithUsage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ProtoInfo.Size()
	n += 1 + l + sovInfo(uint64(l))
	if m.Usage != nil {
		l = m.Usage.Size()
		n += 1 + l + sovInfo(uint64(l))
	}
	l = m.SQLInfo.Size()
	n += 1 + l + sovInfo(uint64(l))
	if len(m.SettingOverrides) > 0 {
		for _, e := range m.SettingOverrides {
			l = e.Size()
			n += 1 + l + sovInfo(uint64(l))
		}
	}
	return n
}

func sovInfo(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozInfo(x uint64) (n int) {
	return sovInfo(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ProtoInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtoInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtoInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedID", wireType)
			}
			m.DeprecatedID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeprecatedID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedDataState", wireType)
			}
			m.DeprecatedDataState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeprecatedDataState |= ProtoInfo_DeprecatedDataState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DroppedName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DroppedName = github_com_cockroachdb_cockroach_pkg_roachpb.TenantName(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalReplicationConsumerJobID", wireType)
			}
			m.PhysicalReplicationConsumerJobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PhysicalReplicationConsumerJobID |= github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.JobID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capabilities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Capabilities.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.JobID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInfo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.JobID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PhysicalReplicationProducerJobIDs = append(m.PhysicalReplicationProducerJobIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInfo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthInfo
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthInfo
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PhysicalReplicationProducerJobIDs) == 0 {
					m.PhysicalReplicationProducerJobIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.JobID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.JobID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowInfo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.JobID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PhysicalReplicationProducerJobIDs = append(m.PhysicalReplicationProducerJobIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalReplicationProducerJobIDs", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousSourceTenant", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreviousSourceTenant == nil {
				m.PreviousSourceTenant = &PreviousSourceTenant{}
			}
			if err := m.PreviousSourceTenant.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRevertTenantTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LastRevertTenantTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreviousSourceTenant) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreviousSourceTenant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreviousSourceTenant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInfo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClusterID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TenantID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CutoverTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CutoverTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SQLInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SQLInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SQLInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = github_com_cockroachdb_cockroach_pkg_roachpb.TenantName(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataState", wireType)
			}
			m.DataState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataState |= TenantDataState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceMode", wireType)
			}
			m.ServiceMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServiceMode |= TenantServiceMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UsageInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UsageInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UsageInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RUBurstLimit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.RUBurstLimit = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RURefillRate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.RURefillRate = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RUCurrent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.RUCurrent = float64(math.Float64frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Consumption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Consumption.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SettingOverride) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SettingOverride: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SettingOverride: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Reason = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TenantInfoWithUsage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TenantInfoWithUsage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TenantInfoWithUsage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtoInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProtoInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Usage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Usage == nil {
				m.Usage = &UsageInfo{}
			}
			if err := m.Usage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SQLInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SQLInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettingOverrides", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SettingOverrides = append(m.SettingOverrides, &SettingOverride{})
			if err := m.SettingOverrides[len(m.SettingOverrides)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipInfo(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowInfo
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInfo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInfo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthInfo
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupInfo
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthInfo
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthInfo        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowInfo          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupInfo = fmt.Errorf("proto: unexpected end of group")
)

