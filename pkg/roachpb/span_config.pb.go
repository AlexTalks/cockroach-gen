// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: roachpb/span_config.proto

package roachpb

import (
	fmt "fmt"
	hlc "github.com/cockroachdb/cockroach/pkg/util/hlc"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Constraint_Type int32

const (
	// REQUIRED ensures all replicas are placed on stores with locality tags
	// that match the constraint. Replication will fail if there aren't any such
	// stores.
	Constraint_REQUIRED Constraint_Type = 0
	// PROHIBITED prevents replicas from being placed on stores with locality
	// tags that match the constrain.
	Constraint_PROHIBITED Constraint_Type = 1
)

var Constraint_Type_name = map[int32]string{
	0: "REQUIRED",
	1: "PROHIBITED",
}

var Constraint_Type_value = map[string]int32{
	"REQUIRED":   0,
	"PROHIBITED": 1,
}

func (x Constraint_Type) String() string {
	return proto.EnumName(Constraint_Type_name, int32(x))
}

func (Constraint_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{2, 0}
}

// GCPolicy dictates the garbage collection policy to apply over a given span.
type GCPolicy struct {
	// TTLSeconds is the number of seconds overwritten values will be retained
	// before garbage collection. A value <= 0 means older versions are never
	// GC-ed.
	TTLSeconds int32 `protobuf:"varint,1,opt,name=ttl_seconds,json=ttlSeconds,proto3" json:"ttl_seconds,omitempty"`
	// ProtectionPolicies is a list of policies that dictate GC behavior for a
	// range (in conjunction with the GC TTL). A ProtectionPolicy can be used
	// to indicate a timestamp above which GC should not run, regardless of the
	// GC TTL. The data it applies over is guaranteed to not be GC-ed provided it
	// wasn't GC-ed before the config applied.
	ProtectionPolicies []ProtectionPolicy `protobuf:"bytes,2,rep,name=protection_policies,json=protectionPolicies,proto3" json:"protection_policies"`
	// IgnoreStrictEnforcement is used to selectively opt out of strict GC TTL
	// enforcement (where requests served at timestamps below the TTL are made to
	// fail, even if the data exists).
	IgnoreStrictEnforcement bool `protobuf:"varint,3,opt,name=ignore_strict_enforcement,json=ignoreStrictEnforcement,proto3" json:"ignore_strict_enforcement,omitempty"`
}

func (m *GCPolicy) Reset()         { *m = GCPolicy{} }
func (m *GCPolicy) String() string { return proto.CompactTextString(m) }
func (*GCPolicy) ProtoMessage()    {}
func (*GCPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{0}
}
func (m *GCPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GCPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCPolicy.Merge(m, src)
}
func (m *GCPolicy) XXX_Size() int {
	return m.Size()
}
func (m *GCPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_GCPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_GCPolicy proto.InternalMessageInfo

// ProtectionPolicy dictates a protection policy against garbage collection that
// applies over a given span.
type ProtectionPolicy struct {
	// ProtectedTimestamp is a timestamp above which GC should not run, regardless
	// of the GC TTL.
	ProtectedTimestamp hlc.Timestamp `protobuf:"bytes,1,opt,name=protected_timestamp,json=protectedTimestamp,proto3" json:"protected_timestamp"`
}

func (m *ProtectionPolicy) Reset()         { *m = ProtectionPolicy{} }
func (m *ProtectionPolicy) String() string { return proto.CompactTextString(m) }
func (*ProtectionPolicy) ProtoMessage()    {}
func (*ProtectionPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{1}
}
func (m *ProtectionPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProtectionPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ProtectionPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtectionPolicy.Merge(m, src)
}
func (m *ProtectionPolicy) XXX_Size() int {
	return m.Size()
}
func (m *ProtectionPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtectionPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_ProtectionPolicy proto.InternalMessageInfo

// Constraint constrains the stores that a replica can be stored on. It
// parallels the definition found in zonepb/zone.proto.
type Constraint struct {
	// Type captures the kind of constraint this is: required or prohibited.
	Type Constraint_Type `protobuf:"varint,1,opt,name=type,proto3,enum=cockroach.roachpb.Constraint_Type" json:"type,omitempty"`
	// Key captures the locality tag key we're constraining against.
	Key string `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	// Value is the locality tag value we're constraining against.
	Value string `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Constraint) Reset()      { *m = Constraint{} }
func (*Constraint) ProtoMessage() {}
func (*Constraint) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{2}
}
func (m *Constraint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Constraint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Constraint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Constraint.Merge(m, src)
}
func (m *Constraint) XXX_Size() int {
	return m.Size()
}
func (m *Constraint) XXX_DiscardUnknown() {
	xxx_messageInfo_Constraint.DiscardUnknown(m)
}

var xxx_messageInfo_Constraint proto.InternalMessageInfo

// ConstraintsConjunction is the set of constraints that need to be satisfied
// together by replicas. It parallels the definition found in zonepb/zone.proto.
type ConstraintsConjunction struct {
	// NumReplicas is the number of replicas that should abide by the constraints
	// below. If set to zero, the constraints will apply to all replicas of the
	// range.
	//
	// NB: Only REQUIRED constraints are allowed when the number of replicas is
	// non-zero.
	NumReplicas int32 `protobuf:"varint,1,opt,name=num_replicas,json=numReplicas,proto3" json:"num_replicas,omitempty"`
	// Constraints is the set that needs to be satisfied by the store in order for
	// us to place replicas on it.
	Constraints []Constraint `protobuf:"bytes,2,rep,name=constraints,proto3" json:"constraints"`
}

func (m *ConstraintsConjunction) Reset()      { *m = ConstraintsConjunction{} }
func (*ConstraintsConjunction) ProtoMessage() {}
func (*ConstraintsConjunction) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{3}
}
func (m *ConstraintsConjunction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConstraintsConjunction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ConstraintsConjunction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConstraintsConjunction.Merge(m, src)
}
func (m *ConstraintsConjunction) XXX_Size() int {
	return m.Size()
}
func (m *ConstraintsConjunction) XXX_DiscardUnknown() {
	xxx_messageInfo_ConstraintsConjunction.DiscardUnknown(m)
}

var xxx_messageInfo_ConstraintsConjunction proto.InternalMessageInfo

// LeasePreference specifies a preference about where range leases should be
// located. It parallels the definition found in zonepb/zone.proto.
type LeasePreference struct {
	// Constraints is the set that needs to be satisfied by the store in order for
	// us to prefer placing leases on it.
	Constraints []Constraint `protobuf:"bytes,1,rep,name=constraints,proto3" json:"constraints"`
}

func (m *LeasePreference) Reset()         { *m = LeasePreference{} }
func (m *LeasePreference) String() string { return proto.CompactTextString(m) }
func (*LeasePreference) ProtoMessage()    {}
func (*LeasePreference) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{4}
}
func (m *LeasePreference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeasePreference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LeasePreference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeasePreference.Merge(m, src)
}
func (m *LeasePreference) XXX_Size() int {
	return m.Size()
}
func (m *LeasePreference) XXX_DiscardUnknown() {
	xxx_messageInfo_LeasePreference.DiscardUnknown(m)
}

var xxx_messageInfo_LeasePreference proto.InternalMessageInfo

// SpanConfig holds the configuration that applies to a given keyspan. It is a
// superset of the fields found in zonepb.zone.proto.
type SpanConfig struct {
	// RangeMinBytes is the minimum size, in bytes, a range can have. When a range
	// is less than this size, it'll be merged with an adjacent range.
	RangeMinBytes int64 `protobuf:"varint,1,opt,name=range_min_bytes,json=rangeMinBytes,proto3" json:"range_min_bytes,omitempty"`
	// RangeMaxBytes is the maximum size, in bytes, a range can have. When a range
	// is more than this size, it'll split into two ranges.
	RangeMaxBytes int64 `protobuf:"varint,2,opt,name=range_max_bytes,json=rangeMaxBytes,proto3" json:"range_max_bytes,omitempty"`
	// GCPolicy dictates the the GC policy to apply over a range.
	GCPolicy GCPolicy `protobuf:"bytes,3,opt,name=gc_policy,json=gcPolicy,proto3" json:"gc_policy"`
	// GlobalReads specifies whether transactions operating over the range(s)
	// should be configured to provide non-blocking behavior, meaning that reads
	// can be served consistently from all replicas and do not block on writes. In
	// exchange, writes get pushed into the future and must wait on commit to
	// ensure linearizability. For more, see #52745.
	GlobalReads bool `protobuf:"varint,4,opt,name=global_reads,json=globalReads,proto3" json:"global_reads,omitempty"`
	// NumReplicas specifies the number of replicas, including both voting and
	// non-voting kinds.
	NumReplicas int32 `protobuf:"varint,5,opt,name=num_replicas,json=numReplicas,proto3" json:"num_replicas,omitempty"`
	// NumVoters specifies the number of voter replicas. If set to zero, we'll
	// consider NumReplicas to be the voter replica count instead (i.e. no
	// non-voting replicas).
	NumVoters int32 `protobuf:"varint,6,opt,name=num_voters,json=numVoters,proto3" json:"num_voters,omitempty"`
	// Constraints constrain which stores the both voting and non-voting replicas
	// can be placed on.
	//
	// NB: The NumReplicas fields in Constraints must either:
	// - add up to at most SpanConfig.NumReplicas (pinning the sum of replicas and
	//   having the rest float freely);
	// - all be zero (applying each constraint to all replicas).
	Constraints []ConstraintsConjunction `protobuf:"bytes,7,rep,name=constraints,proto3" json:"constraints"`
	// VoterConstraints constrains which stores the voting replicas can be placed
	// on. This must be compatible with the Constraints field above, but not
	// necessarily a subset. It's compatible as long as there are no prohibitive
	// constraints above that are required here.
	VoterConstraints []ConstraintsConjunction `protobuf:"bytes,8,rep,name=voter_constraints,json=voterConstraints,proto3" json:"voter_constraints"`
	// LeasePreference captures the preference for how range leases are to be
	// placed. They're allowed to be placed elsewhere if needed, but will follow
	// the stated preferences when possible.
	//
	// More than one lease preference is allowed; they're considered as the most
	// preferred option to least. The first preference that an existing replica of
	// a range matches will take priority for the lease.
	LeasePreferences []LeasePreference `protobuf:"bytes,9,rep,name=lease_preferences,json=leasePreferences,proto3" json:"lease_preferences"`
	// RangefeedEnabled determines whether rangefeeds are enabled over the
	// specific range.
	RangefeedEnabled bool `protobuf:"varint,10,opt,name=rangefeed_enabled,json=rangefeedEnabled,proto3" json:"rangefeed_enabled,omitempty"`
	// ExcludeDataFromBackup specifies if the range has been marked to be excluded
	// from a backup targeting the table represented by this keyspace. This
	// information is used when ExportRequests issued by backups are being
	// serviced in KV, to decide whether or not to send back any row data.
	ExcludeDataFromBackup bool `protobuf:"varint,11,opt,name=exclude_data_from_backup,json=excludeDataFromBackup,proto3" json:"exclude_data_from_backup,omitempty"`
}

func (m *SpanConfig) Reset()         { *m = SpanConfig{} }
func (m *SpanConfig) String() string { return proto.CompactTextString(m) }
func (*SpanConfig) ProtoMessage()    {}
func (*SpanConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{5}
}
func (m *SpanConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SpanConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanConfig.Merge(m, src)
}
func (m *SpanConfig) XXX_Size() int {
	return m.Size()
}
func (m *SpanConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SpanConfig proto.InternalMessageInfo

// SystemSpanConfigTarget specifies the target of system span configurations.
type SystemSpanConfigTarget struct {
	// SourceTenantID is the ID of the tenant that specified the system span
	// configuration.
	SourceTenantID TenantID `protobuf:"bytes,1,opt,name=source_tenant_id,json=sourceTenantId,proto3" json:"source_tenant_id"`
	// TargetTenantID is the ID of the tenant that the associated system span
	// configuration applies to.
	//
	// If the host tenant is the source and the target is unspecified then the
	// associated system span configuration applies over all ranges in the system
	// (including those belonging to secondary tenants).
	//
	// Secondary tenants are only allowed to target themselves and must fill in
	// this field. The host tenant may use this field to target a specific
	// secondary tenant.
	TargetTenantID *TenantID `protobuf:"bytes,2,opt,name=target_tenant_id,json=targetTenantId,proto3" json:"target_tenant_id,omitempty"`
}

func (m *SystemSpanConfigTarget) Reset()         { *m = SystemSpanConfigTarget{} }
func (m *SystemSpanConfigTarget) String() string { return proto.CompactTextString(m) }
func (*SystemSpanConfigTarget) ProtoMessage()    {}
func (*SystemSpanConfigTarget) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{6}
}
func (m *SystemSpanConfigTarget) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SystemSpanConfigTarget) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SystemSpanConfigTarget) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SystemSpanConfigTarget.Merge(m, src)
}
func (m *SystemSpanConfigTarget) XXX_Size() int {
	return m.Size()
}
func (m *SystemSpanConfigTarget) XXX_DiscardUnknown() {
	xxx_messageInfo_SystemSpanConfigTarget.DiscardUnknown(m)
}

var xxx_messageInfo_SystemSpanConfigTarget proto.InternalMessageInfo

// SpanConfigTarget specifies the target of an associated span configuration.
type SpanConfigTarget struct {
	// Types that are valid to be assigned to Union:
	//	*SpanConfigTarget_Span
	//	*SpanConfigTarget_SystemSpanConfigTarget
	Union isSpanConfigTarget_Union `protobuf_oneof:"union"`
}

func (m *SpanConfigTarget) Reset()         { *m = SpanConfigTarget{} }
func (m *SpanConfigTarget) String() string { return proto.CompactTextString(m) }
func (*SpanConfigTarget) ProtoMessage()    {}
func (*SpanConfigTarget) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{7}
}
func (m *SpanConfigTarget) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanConfigTarget) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SpanConfigTarget) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanConfigTarget.Merge(m, src)
}
func (m *SpanConfigTarget) XXX_Size() int {
	return m.Size()
}
func (m *SpanConfigTarget) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanConfigTarget.DiscardUnknown(m)
}

var xxx_messageInfo_SpanConfigTarget proto.InternalMessageInfo

type isSpanConfigTarget_Union interface {
	isSpanConfigTarget_Union()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SpanConfigTarget_Span struct {
	Span *Span `protobuf:"bytes,1,opt,name=span,proto3,oneof" json:"span,omitempty"`
}
type SpanConfigTarget_SystemSpanConfigTarget struct {
	SystemSpanConfigTarget *SystemSpanConfigTarget `protobuf:"bytes,2,opt,name=system_span_config_target,json=systemSpanConfigTarget,proto3,oneof" json:"system_span_config_target,omitempty"`
}

func (*SpanConfigTarget_Span) isSpanConfigTarget_Union()                   {}
func (*SpanConfigTarget_SystemSpanConfigTarget) isSpanConfigTarget_Union() {}

func (m *SpanConfigTarget) GetUnion() isSpanConfigTarget_Union {
	if m != nil {
		return m.Union
	}
	return nil
}

func (m *SpanConfigTarget) GetSpan() *Span {
	if x, ok := m.GetUnion().(*SpanConfigTarget_Span); ok {
		return x.Span
	}
	return nil
}

func (m *SpanConfigTarget) GetSystemSpanConfigTarget() *SystemSpanConfigTarget {
	if x, ok := m.GetUnion().(*SpanConfigTarget_SystemSpanConfigTarget); ok {
		return x.SystemSpanConfigTarget
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SpanConfigTarget) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SpanConfigTarget_Span)(nil),
		(*SpanConfigTarget_SystemSpanConfigTarget)(nil),
	}
}

// SpanConfigEntry ties a span to its corresponding config.
type SpanConfigEntry struct {
	// Target specifies the target the config applies over.
	Target SpanConfigTarget `protobuf:"bytes,3,opt,name=target,proto3" json:"target"`
	// Config is the set of attributes that apply over the corresponding target.
	Config SpanConfig `protobuf:"bytes,2,opt,name=config,proto3" json:"config"`
}

func (m *SpanConfigEntry) Reset()         { *m = SpanConfigEntry{} }
func (m *SpanConfigEntry) String() string { return proto.CompactTextString(m) }
func (*SpanConfigEntry) ProtoMessage()    {}
func (*SpanConfigEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{8}
}
func (m *SpanConfigEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanConfigEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SpanConfigEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanConfigEntry.Merge(m, src)
}
func (m *SpanConfigEntry) XXX_Size() int {
	return m.Size()
}
func (m *SpanConfigEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanConfigEntry.DiscardUnknown(m)
}

var xxx_messageInfo_SpanConfigEntry proto.InternalMessageInfo

// GetSpanConfigsRequest is used to fetch the span configurations and system
// span configurations.
type GetSpanConfigsRequest struct {
	// Targets to request configurations for. The targets listed here are not
	// allowed to be duplicated/overlap with one another.
	Targets []SpanConfigTarget `protobuf:"bytes,2,rep,name=targets,proto3" json:"targets"`
}

func (m *GetSpanConfigsRequest) Reset()         { *m = GetSpanConfigsRequest{} }
func (m *GetSpanConfigsRequest) String() string { return proto.CompactTextString(m) }
func (*GetSpanConfigsRequest) ProtoMessage()    {}
func (*GetSpanConfigsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{9}
}
func (m *GetSpanConfigsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpanConfigsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpanConfigsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpanConfigsRequest.Merge(m, src)
}
func (m *GetSpanConfigsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetSpanConfigsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpanConfigsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpanConfigsRequest proto.InternalMessageInfo

// GetSpanConfigsResponse lists out the span configurations and system span
// configurations that have been requested.
type GetSpanConfigsResponse struct {
	// SpanConfigEntries capture the span configurations over the requested spans.
	// The results for each Span in the matching GetSpanConfigsRequest are
	// flattened out into a single slice, and follow the same ordering. It's
	// possible for there to be no configurations for a given span; there'll
	// simply be no entries for it.
	//
	// Any system span configurations set by the tenant are also returned if
	// requested.
	SpanConfigEntries []SpanConfigEntry `protobuf:"bytes,1,rep,name=span_config_entries,json=spanConfigEntries,proto3" json:"span_config_entries"`
}

func (m *GetSpanConfigsResponse) Reset()         { *m = GetSpanConfigsResponse{} }
func (m *GetSpanConfigsResponse) String() string { return proto.CompactTextString(m) }
func (*GetSpanConfigsResponse) ProtoMessage()    {}
func (*GetSpanConfigsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{10}
}
func (m *GetSpanConfigsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpanConfigsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpanConfigsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpanConfigsResponse.Merge(m, src)
}
func (m *GetSpanConfigsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetSpanConfigsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpanConfigsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpanConfigsResponse proto.InternalMessageInfo

// UpdateSpanConfigsRequest is used to update the span configurations and system
// span configurations over the given targets.
//
// This is a "targeted" API: the targets being deleted are expected to have been
// present exactly as specified. The same is true for targets being upserted with
// new configs. If targets aren't present, an error is returned.
//
// Adding configurations that target a span are expected to not overlap with any
// existing spans. When divvying up an existing span into multiple others,
// callers are expected to delete the old and upsert the new ones. This can
// happen as part of the same request, as we delete targets marked for deletion
// before upserting what was requested.
//
// Targets are not allowed to overlap with other targets in the same list. They
// are, however, allowed to overlap across lists. This is necessary to support
// the delete+upsert semantics described above.
type UpdateSpanConfigsRequest struct {
	// ToDelete captures the targets we want to delete configs for.
	ToDelete []SpanConfigTarget `protobuf:"bytes,3,rep,name=to_delete,json=toDelete,proto3" json:"to_delete"`
	// ToUpsert captures the targets we want to upsert and the configs we want
	// to upsert with.
	ToUpsert []SpanConfigEntry `protobuf:"bytes,4,rep,name=to_upsert,json=toUpsert,proto3" json:"to_upsert"`
}

func (m *UpdateSpanConfigsRequest) Reset()         { *m = UpdateSpanConfigsRequest{} }
func (m *UpdateSpanConfigsRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateSpanConfigsRequest) ProtoMessage()    {}
func (*UpdateSpanConfigsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{11}
}
func (m *UpdateSpanConfigsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateSpanConfigsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UpdateSpanConfigsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateSpanConfigsRequest.Merge(m, src)
}
func (m *UpdateSpanConfigsRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateSpanConfigsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateSpanConfigsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateSpanConfigsRequest proto.InternalMessageInfo

type UpdateSpanConfigsResponse struct {
}

func (m *UpdateSpanConfigsResponse) Reset()         { *m = UpdateSpanConfigsResponse{} }
func (m *UpdateSpanConfigsResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateSpanConfigsResponse) ProtoMessage()    {}
func (*UpdateSpanConfigsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{12}
}
func (m *UpdateSpanConfigsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateSpanConfigsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UpdateSpanConfigsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateSpanConfigsResponse.Merge(m, src)
}
func (m *UpdateSpanConfigsResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateSpanConfigsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateSpanConfigsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateSpanConfigsResponse proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("cockroach.roachpb.Constraint_Type", Constraint_Type_name, Constraint_Type_value)
	proto.RegisterType((*GCPolicy)(nil), "cockroach.roachpb.GCPolicy")
	proto.RegisterType((*ProtectionPolicy)(nil), "cockroach.roachpb.ProtectionPolicy")
	proto.RegisterType((*Constraint)(nil), "cockroach.roachpb.Constraint")
	proto.RegisterType((*ConstraintsConjunction)(nil), "cockroach.roachpb.ConstraintsConjunction")
	proto.RegisterType((*LeasePreference)(nil), "cockroach.roachpb.LeasePreference")
	proto.RegisterType((*SpanConfig)(nil), "cockroach.roachpb.SpanConfig")
	proto.RegisterType((*SystemSpanConfigTarget)(nil), "cockroach.roachpb.SystemSpanConfigTarget")
	proto.RegisterType((*SpanConfigTarget)(nil), "cockroach.roachpb.SpanConfigTarget")
	proto.RegisterType((*SpanConfigEntry)(nil), "cockroach.roachpb.SpanConfigEntry")
	proto.RegisterType((*GetSpanConfigsRequest)(nil), "cockroach.roachpb.GetSpanConfigsRequest")
	proto.RegisterType((*GetSpanConfigsResponse)(nil), "cockroach.roachpb.GetSpanConfigsResponse")
	proto.RegisterType((*UpdateSpanConfigsRequest)(nil), "cockroach.roachpb.UpdateSpanConfigsRequest")
	proto.RegisterType((*UpdateSpanConfigsResponse)(nil), "cockroach.roachpb.UpdateSpanConfigsResponse")
}

func init() { proto.RegisterFile("roachpb/span_config.proto", fileDescriptor_91c9f1dcea14470a) }

var fileDescriptor_91c9f1dcea14470a = []byte{
	// 1078 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0xc1, 0x4f, 0x1b, 0xc7,
	0x17, 0xf6, 0x1a, 0x03, 0xf6, 0x33, 0x3f, 0x58, 0x26, 0x09, 0x59, 0x12, 0x61, 0x13, 0xe7, 0xa7,
	0x8a, 0xa8, 0xaa, 0x91, 0xa8, 0xd4, 0x4a, 0xf4, 0x54, 0x83, 0x13, 0x40, 0xa9, 0x4a, 0x16, 0x53,
	0xb5, 0x51, 0xdb, 0xd5, 0x78, 0xf7, 0xd9, 0x6c, 0x59, 0xcf, 0x6c, 0x77, 0x66, 0x23, 0x7c, 0xec,
	0xbd, 0x87, 0xde, 0xda, 0x43, 0x0f, 0xfc, 0x0d, 0x95, 0x2a, 0xf5, 0x4f, 0xe0, 0x98, 0x23, 0x97,
	0xa2, 0xd6, 0x5c, 0xfa, 0x67, 0x54, 0x3b, 0x3b, 0xb6, 0x17, 0x70, 0xa8, 0x92, 0xdb, 0xfa, 0xbd,
	0xef, 0x7d, 0xdf, 0xf7, 0xde, 0xbc, 0xd9, 0x35, 0x2c, 0x47, 0x9c, 0xba, 0x47, 0x61, 0x7b, 0x5d,
	0x84, 0x94, 0x39, 0x2e, 0x67, 0x1d, 0xbf, 0x5b, 0x0f, 0x23, 0x2e, 0x39, 0x59, 0x74, 0xb9, 0x7b,
	0xac, 0xd2, 0x75, 0x0d, 0x7a, 0x40, 0x86, 0x68, 0x8f, 0x4a, 0x9a, 0xc2, 0x1e, 0xdc, 0xed, 0xf2,
	0x2e, 0x57, 0x8f, 0xeb, 0xc9, 0x93, 0x8e, 0x5a, 0xb1, 0xf4, 0x83, 0xf5, 0xa3, 0xc0, 0x5d, 0x97,
	0x7e, 0x0f, 0x85, 0xa4, 0xbd, 0x30, 0xcd, 0xd4, 0xfe, 0x34, 0xa0, 0xf8, 0x6c, 0x6b, 0x9f, 0x07,
	0xbe, 0xdb, 0x27, 0xeb, 0x50, 0x96, 0x32, 0x70, 0x04, 0xba, 0x9c, 0x79, 0xc2, 0x32, 0x56, 0x8d,
	0xb5, 0xe9, 0xc6, 0xfc, 0xe0, 0xa2, 0x0a, 0xad, 0xd6, 0xf3, 0x83, 0x34, 0x6a, 0x83, 0x94, 0x81,
	0x7e, 0x26, 0x2f, 0xe1, 0x4e, 0x42, 0x83, 0xae, 0xf4, 0x39, 0x73, 0xc2, 0x84, 0xc5, 0x47, 0x61,
	0xe5, 0x57, 0xa7, 0xd6, 0xca, 0x1b, 0x8f, 0xeb, 0x37, 0x2c, 0xd7, 0xf7, 0x47, 0xe8, 0x54, 0xb2,
	0x51, 0x38, 0xbb, 0xa8, 0xe6, 0x6c, 0x12, 0x5e, 0x8d, 0xfb, 0x28, 0xc8, 0x26, 0x2c, 0xfb, 0x5d,
	0xc6, 0x23, 0x74, 0x84, 0x8c, 0x7c, 0x57, 0x3a, 0xc8, 0x3a, 0x3c, 0x72, 0xb1, 0x87, 0x4c, 0x5a,
	0x53, 0xab, 0xc6, 0x5a, 0xd1, 0xbe, 0x9f, 0x02, 0x0e, 0x54, 0xbe, 0x39, 0x4e, 0x6f, 0x16, 0xff,
	0x38, 0xad, 0x1a, 0xff, 0x9c, 0x56, 0x8d, 0x5a, 0x04, 0xe6, 0x75, 0x4d, 0xd2, 0x1a, 0xb9, 0x46,
	0xcf, 0x19, 0x0d, 0x44, 0xb5, 0x5b, 0xde, 0x58, 0xc9, 0xb8, 0x4e, 0xa6, 0x56, 0x3f, 0x0a, 0xdc,
	0x7a, 0x6b, 0x08, 0xba, 0xe6, 0x17, 0xbd, 0x51, 0x26, 0xa3, 0xf9, 0xab, 0x01, 0xb0, 0xc5, 0x99,
	0x90, 0x11, 0xf5, 0x99, 0x24, 0x1f, 0x41, 0x41, 0xf6, 0x43, 0x54, 0xfc, 0xf3, 0x1b, 0xb5, 0x09,
	0x53, 0x19, 0x83, 0xeb, 0xad, 0x7e, 0x88, 0xb6, 0xc2, 0x13, 0x13, 0xa6, 0x8e, 0xb1, 0x6f, 0xe5,
	0x57, 0x8d, 0xb5, 0x92, 0x9d, 0x3c, 0x92, 0xbb, 0x30, 0xfd, 0x8a, 0x06, 0x31, 0xaa, 0xf6, 0x4b,
	0x76, 0xfa, 0xa3, 0xf6, 0x7f, 0x28, 0x24, 0x55, 0x64, 0x0e, 0x8a, 0x76, 0xf3, 0xc5, 0xe1, 0xae,
	0xdd, 0xdc, 0x36, 0x73, 0x64, 0x1e, 0x60, 0xdf, 0xfe, 0x7c, 0x67, 0xb7, 0xb1, 0xdb, 0x6a, 0x6e,
	0x9b, 0xc6, 0x66, 0xf1, 0x97, 0xd3, 0x6a, 0x4e, 0xd9, 0xfb, 0xd1, 0x80, 0xa5, 0xb1, 0xa2, 0xd8,
	0xe2, 0xec, 0xbb, 0x98, 0xa9, 0xf9, 0x90, 0x47, 0x30, 0xc7, 0xe2, 0x9e, 0x13, 0x61, 0x18, 0xf8,
	0x2e, 0xd5, 0x1b, 0x60, 0x97, 0x59, 0xdc, 0xb3, 0x75, 0x88, 0x34, 0xa1, 0xec, 0x8e, 0x8b, 0xf5,
	0x51, 0xaf, 0xdc, 0xda, 0x94, 0x1e, 0x5a, 0xb6, 0x2e, 0x63, 0xe7, 0x5b, 0x58, 0x78, 0x8e, 0x54,
	0xe0, 0x7e, 0x84, 0x1d, 0x8c, 0x90, 0xb9, 0x78, 0x5d, 0xc3, 0x78, 0x47, 0x8d, 0x82, 0xe2, 0xff,
	0x61, 0x1a, 0xe0, 0x20, 0xa4, 0x6c, 0x4b, 0xdd, 0x26, 0xf2, 0x1e, 0x2c, 0x44, 0x94, 0x75, 0xd1,
	0xe9, 0xf9, 0xcc, 0x69, 0xf7, 0x25, 0xa6, 0x5d, 0x4e, 0xd9, 0xff, 0x53, 0xe1, 0xcf, 0x7c, 0xd6,
	0x48, 0x82, 0x19, 0x1c, 0x3d, 0xd1, 0xb8, 0x7c, 0x16, 0x47, 0x4f, 0x52, 0xdc, 0x1e, 0x94, 0xba,
	0x6e, 0xba, 0xfa, 0x7d, 0x75, 0x2e, 0xe5, 0x8d, 0x87, 0x13, 0x9c, 0x0e, 0xef, 0x58, 0xc3, 0x4c,
	0x7c, 0x0e, 0x2e, 0xaa, 0xa3, 0x5b, 0x67, 0x17, 0xbb, 0xae, 0x5e, 0xcc, 0x47, 0x30, 0xd7, 0x0d,
	0x78, 0x9b, 0x06, 0x4e, 0x84, 0xd4, 0x13, 0x56, 0x41, 0x6d, 0x79, 0x39, 0x8d, 0xd9, 0x49, 0xe8,
	0xc6, 0x09, 0x4d, 0xdf, 0x3c, 0xa1, 0x15, 0x80, 0x04, 0xf2, 0x8a, 0x4b, 0x8c, 0x84, 0x35, 0xa3,
	0x00, 0x25, 0x16, 0xf7, 0xbe, 0x50, 0x01, 0xf2, 0xe2, 0xea, 0x70, 0x67, 0xd5, 0x70, 0x9f, 0xdc,
	0x3a, 0xdc, 0xec, 0x8e, 0x4c, 0x18, 0x34, 0xf9, 0x1a, 0x16, 0x95, 0x9a, 0x93, 0x25, 0x2e, 0xbe,
	0x1b, 0xb1, 0xa9, 0x98, 0x32, 0x10, 0x72, 0x08, 0x8b, 0x41, 0xb2, 0x20, 0x4e, 0x38, 0xda, 0x10,
	0x61, 0x95, 0x14, 0xfb, 0xa4, 0xcb, 0x74, 0x6d, 0x99, 0x86, 0xb4, 0xc1, 0xd5, 0xb0, 0x20, 0xef,
	0xc3, 0xa2, 0x3a, 0xc9, 0x0e, 0xa2, 0xe7, 0x20, 0xa3, 0xed, 0x00, 0x3d, 0x0b, 0xd4, 0xc4, 0xcd,
	0x51, 0xa2, 0x99, 0xc6, 0xc9, 0xc7, 0x60, 0xe1, 0x89, 0x1b, 0xc4, 0x1e, 0x3a, 0xc9, 0xcb, 0xd6,
	0xe9, 0x44, 0xbc, 0xe7, 0xb4, 0xa9, 0x7b, 0x1c, 0x87, 0x56, 0x59, 0xd5, 0xdc, 0xd3, 0xf9, 0x6d,
	0x2a, 0xe9, 0xd3, 0x88, 0xf7, 0x1a, 0x2a, 0xa9, 0x77, 0xf0, 0xdc, 0x80, 0xa5, 0x83, 0xbe, 0x90,
	0xd8, 0x1b, 0x6f, 0x62, 0x8b, 0x46, 0x5d, 0x94, 0xe4, 0x1b, 0x30, 0x05, 0x8f, 0x23, 0x17, 0x1d,
	0x89, 0x8c, 0x32, 0xe9, 0xf8, 0x9e, 0x7e, 0x13, 0x4d, 0x5a, 0xa3, 0x96, 0xc2, 0xec, 0x6e, 0x37,
	0x96, 0xf4, 0x1a, 0xcd, 0x1f, 0xa8, 0xe2, 0x61, 0xdc, 0x9e, 0x17, 0xd9, 0xdf, 0x1e, 0xf9, 0x0a,
	0x4c, 0xa9, 0x84, 0x32, 0xf4, 0xf9, 0xff, 0xa6, 0x27, 0x09, 0x75, 0xea, 0x70, 0x4c, 0x2d, 0xb3,
	0xbf, 0x3d, 0xdd, 0xda, 0x6f, 0x06, 0x98, 0x37, 0x9a, 0xfa, 0x00, 0x0a, 0xc9, 0x17, 0x4c, 0x37,
	0x72, 0x7f, 0x82, 0x52, 0x52, 0xb2, 0x93, 0xb3, 0x15, 0x8c, 0x74, 0x60, 0x59, 0xa8, 0xe9, 0x38,
	0x99, 0xef, 0x9e, 0x93, 0xca, 0x69, 0xb7, 0x93, 0xf6, 0x68, 0xf2, 0x44, 0x77, 0x72, 0xf6, 0x92,
	0x98, 0x98, 0x69, 0xcc, 0xc2, 0x74, 0xcc, 0x7c, 0xce, 0x6a, 0x3f, 0x1b, 0xb0, 0x30, 0xce, 0x36,
	0x99, 0x8c, 0xfa, 0xe4, 0x53, 0x98, 0xd1, 0x8a, 0xe9, 0x2d, 0x7e, 0xfc, 0x06, 0xd7, 0x57, 0x18,
	0xd3, 0xe5, 0xd2, 0x85, 0xe4, 0x13, 0x98, 0x49, 0xbd, 0x6b, 0xd3, 0x2b, 0xb7, 0x52, 0x0c, 0x8b,
	0xd3, 0x92, 0xbd, 0x42, 0xd1, 0x30, 0xf3, 0xb5, 0x36, 0xdc, 0x7b, 0x86, 0x72, 0x0c, 0x12, 0x36,
	0x7e, 0x1f, 0xa3, 0x90, 0x64, 0x0b, 0x66, 0x53, 0x95, 0xdb, 0x3e, 0xaf, 0x6f, 0xf0, 0x37, 0xac,
	0xd4, 0x1a, 0x11, 0x2c, 0x5d, 0xd7, 0x10, 0x21, 0x67, 0x02, 0xc9, 0x97, 0x70, 0x27, 0x7b, 0x02,
	0xc8, 0x64, 0xe4, 0xe3, 0xf0, 0x05, 0x5c, 0xbb, 0x55, 0x50, 0x0d, 0x51, 0xeb, 0x2d, 0x8a, 0x2b,
	0x61, 0x1f, 0x45, 0xed, 0x77, 0x03, 0xac, 0xc3, 0xd0, 0xa3, 0x12, 0x27, 0xf4, 0xf6, 0x14, 0x4a,
	0x92, 0x3b, 0x1e, 0x06, 0x28, 0x93, 0x6f, 0xdb, 0x5b, 0x76, 0x57, 0x94, 0x7c, 0x5b, 0x95, 0x92,
	0xa6, 0xe2, 0x89, 0x43, 0x81, 0x91, 0xb4, 0x0a, 0x6f, 0x69, 0xba, 0x28, 0xf9, 0xa1, 0xaa, 0x4c,
	0xa7, 0xb4, 0x57, 0x28, 0xe6, 0xcd, 0xa9, 0xda, 0x43, 0x58, 0x9e, 0x60, 0x3b, 0x1d, 0x57, 0xe3,
	0xc9, 0xd9, 0xdf, 0x95, 0xdc, 0xd9, 0xa0, 0x62, 0xbc, 0x1e, 0x54, 0x8c, 0xf3, 0x41, 0xc5, 0xf8,
	0x6b, 0x50, 0x31, 0x7e, 0xba, 0xac, 0xe4, 0x5e, 0x5f, 0x56, 0x72, 0xe7, 0x97, 0x95, 0xdc, 0xcb,
	0x59, 0xad, 0xd9, 0x9e, 0x51, 0x7f, 0xb7, 0x3e, 0xfc, 0x37, 0x00, 0x00, 0xff, 0xff, 0xa8, 0xbc,
	0x8e, 0xf6, 0xe2, 0x09, 0x00, 0x00,
}

func (this *GCPolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPolicy)
	if !ok {
		that2, ok := that.(GCPolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TTLSeconds != that1.TTLSeconds {
		return false
	}
	if len(this.ProtectionPolicies) != len(that1.ProtectionPolicies) {
		return false
	}
	for i := range this.ProtectionPolicies {
		if !this.ProtectionPolicies[i].Equal(&that1.ProtectionPolicies[i]) {
			return false
		}
	}
	if this.IgnoreStrictEnforcement != that1.IgnoreStrictEnforcement {
		return false
	}
	return true
}
func (this *ProtectionPolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtectionPolicy)
	if !ok {
		that2, ok := that.(ProtectionPolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ProtectedTimestamp.Equal(&that1.ProtectedTimestamp) {
		return false
	}
	return true
}
func (this *Constraint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Constraint)
	if !ok {
		that2, ok := that.(Constraint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *ConstraintsConjunction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConstraintsConjunction)
	if !ok {
		that2, ok := that.(ConstraintsConjunction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NumReplicas != that1.NumReplicas {
		return false
	}
	if len(this.Constraints) != len(that1.Constraints) {
		return false
	}
	for i := range this.Constraints {
		if !this.Constraints[i].Equal(&that1.Constraints[i]) {
			return false
		}
	}
	return true
}
func (this *LeasePreference) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LeasePreference)
	if !ok {
		that2, ok := that.(LeasePreference)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Constraints) != len(that1.Constraints) {
		return false
	}
	for i := range this.Constraints {
		if !this.Constraints[i].Equal(&that1.Constraints[i]) {
			return false
		}
	}
	return true
}
func (this *SpanConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SpanConfig)
	if !ok {
		that2, ok := that.(SpanConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RangeMinBytes != that1.RangeMinBytes {
		return false
	}
	if this.RangeMaxBytes != that1.RangeMaxBytes {
		return false
	}
	if !this.GCPolicy.Equal(&that1.GCPolicy) {
		return false
	}
	if this.GlobalReads != that1.GlobalReads {
		return false
	}
	if this.NumReplicas != that1.NumReplicas {
		return false
	}
	if this.NumVoters != that1.NumVoters {
		return false
	}
	if len(this.Constraints) != len(that1.Constraints) {
		return false
	}
	for i := range this.Constraints {
		if !this.Constraints[i].Equal(&that1.Constraints[i]) {
			return false
		}
	}
	if len(this.VoterConstraints) != len(that1.VoterConstraints) {
		return false
	}
	for i := range this.VoterConstraints {
		if !this.VoterConstraints[i].Equal(&that1.VoterConstraints[i]) {
			return false
		}
	}
	if len(this.LeasePreferences) != len(that1.LeasePreferences) {
		return false
	}
	for i := range this.LeasePreferences {
		if !this.LeasePreferences[i].Equal(&that1.LeasePreferences[i]) {
			return false
		}
	}
	if this.RangefeedEnabled != that1.RangefeedEnabled {
		return false
	}
	if this.ExcludeDataFromBackup != that1.ExcludeDataFromBackup {
		return false
	}
	return true
}
func (this *SystemSpanConfigTarget) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SystemSpanConfigTarget)
	if !ok {
		that2, ok := that.(SystemSpanConfigTarget)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SourceTenantID.Equal(&that1.SourceTenantID) {
		return false
	}
	if !this.TargetTenantID.Equal(that1.TargetTenantID) {
		return false
	}
	return true
}
func (m *GCPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IgnoreStrictEnforcement {
		i--
		if m.IgnoreStrictEnforcement {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.ProtectionPolicies) > 0 {
		for iNdEx := len(m.ProtectionPolicies) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ProtectionPolicies[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpanConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.TTLSeconds != 0 {
		i = encodeVarintSpanConfig(dAtA, i, uint64(m.TTLSeconds))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProtectionPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtectionPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtectionPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ProtectedTimestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSpanConfig(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Constraint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Constraint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Constraint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintSpanConfig(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintSpanConfig(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintSpanConfig(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ConstraintsConjunction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConstraintsConjunction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConstraintsConjunction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Constraints) > 0 {
		for iNdEx := len(m.Constraints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Constraints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpanConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.NumReplicas != 0 {
		i = encodeVarintSpanConfig(dAtA, i, uint64(m.NumReplicas))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LeasePreference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeasePreference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeasePreference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Constraints) > 0 {
		for iNdEx := len(m.Constraints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Constraints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpanConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SpanConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExcludeDataFromBackup {
		i--
		if m.ExcludeDataFromBackup {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.RangefeedEnabled {
		i--
		if m.RangefeedEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.LeasePreferences) > 0 {
		for iNdEx := len(m.LeasePreferences) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LeasePreferences[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpanConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.VoterConstraints) > 0 {
		for iNdEx := len(m.VoterConstraints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VoterConstraints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpanConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Constraints) > 0 {
		for iNdEx := len(m.Constraints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Constraints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpanConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.NumVoters != 0 {
		i = encodeVarintSpanConfig(dAtA, i, uint64(m.NumVoters))
		i--
		dAtA[i] = 0x30
	}
	if m.NumReplicas != 0 {
		i = encodeVarintSpanConfig(dAtA, i, uint64(m.NumReplicas))
		i--
		dAtA[i] = 0x28
	}
	if m.GlobalReads {
		i--
		if m.GlobalReads {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.GCPolicy.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSpanConfig(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.RangeMaxBytes != 0 {
		i = encodeVarintSpanConfig(dAtA, i, uint64(m.RangeMaxBytes))
		i--
		dAtA[i] = 0x10
	}
	if m.RangeMinBytes != 0 {
		i = encodeVarintSpanConfig(dAtA, i, uint64(m.RangeMinBytes))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SystemSpanConfigTarget) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SystemSpanConfigTarget) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SystemSpanConfigTarget) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TargetTenantID != nil {
		{
			size, err := m.TargetTenantID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpanConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.SourceTenantID.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSpanConfig(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SpanConfigTarget) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanConfigTarget) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanConfigTarget) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Union != nil {
		{
			size := m.Union.Size()
			i -= size
			if _, err := m.Union.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *SpanConfigTarget_Span) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanConfigTarget_Span) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Span != nil {
		{
			size, err := m.Span.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpanConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *SpanConfigTarget_SystemSpanConfigTarget) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanConfigTarget_SystemSpanConfigTarget) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SystemSpanConfigTarget != nil {
		{
			size, err := m.SystemSpanConfigTarget.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpanConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *SpanConfigEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanConfigEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanConfigEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Target.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSpanConfig(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Config.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSpanConfig(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}

func (m *GetSpanConfigsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpanConfigsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpanConfigsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Targets) > 0 {
		for iNdEx := len(m.Targets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Targets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpanConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetSpanConfigsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpanConfigsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpanConfigsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SpanConfigEntries) > 0 {
		for iNdEx := len(m.SpanConfigEntries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SpanConfigEntries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpanConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UpdateSpanConfigsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateSpanConfigsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateSpanConfigsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ToUpsert) > 0 {
		for iNdEx := len(m.ToUpsert) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ToUpsert[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpanConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ToDelete) > 0 {
		for iNdEx := len(m.ToDelete) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ToDelete[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpanConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	return len(dAtA) - i, nil
}

func (m *UpdateSpanConfigsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateSpanConfigsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateSpanConfigsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintSpanConfig(dAtA []byte, offset int, v uint64) int {
	offset -= sovSpanConfig(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func NewPopulatedGCPolicy(r randySpanConfig, easy bool) *GCPolicy {
	this := &GCPolicy{}
	this.TTLSeconds = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.TTLSeconds *= -1
	}
	if r.Intn(5) != 0 {
		v1 := r.Intn(5)
		this.ProtectionPolicies = make([]ProtectionPolicy, v1)
		for i := 0; i < v1; i++ {
			v2 := NewPopulatedProtectionPolicy(r, easy)
			this.ProtectionPolicies[i] = *v2
		}
	}
	this.IgnoreStrictEnforcement = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedProtectionPolicy(r randySpanConfig, easy bool) *ProtectionPolicy {
	this := &ProtectionPolicy{}
	v3 := hlc.NewPopulatedTimestamp(r, easy)
	this.ProtectedTimestamp = *v3
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randySpanConfig interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneSpanConfig(r randySpanConfig) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringSpanConfig(r randySpanConfig) string {
	v4 := r.Intn(100)
	tmps := make([]rune, v4)
	for i := 0; i < v4; i++ {
		tmps[i] = randUTF8RuneSpanConfig(r)
	}
	return string(tmps)
}
func randUnrecognizedSpanConfig(r randySpanConfig, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldSpanConfig(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldSpanConfig(dAtA []byte, r randySpanConfig, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateSpanConfig(dAtA, uint64(key))
		v5 := r.Int63()
		if r.Intn(2) == 0 {
			v5 *= -1
		}
		dAtA = encodeVarintPopulateSpanConfig(dAtA, uint64(v5))
	case 1:
		dAtA = encodeVarintPopulateSpanConfig(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateSpanConfig(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateSpanConfig(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateSpanConfig(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateSpanConfig(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *GCPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TTLSeconds != 0 {
		n += 1 + sovSpanConfig(uint64(m.TTLSeconds))
	}
	if len(m.ProtectionPolicies) > 0 {
		for _, e := range m.ProtectionPolicies {
			l = e.Size()
			n += 1 + l + sovSpanConfig(uint64(l))
		}
	}
	if m.IgnoreStrictEnforcement {
		n += 2
	}
	return n
}

func (m *ProtectionPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ProtectedTimestamp.Size()
	n += 1 + l + sovSpanConfig(uint64(l))
	return n
}

func (m *Constraint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovSpanConfig(uint64(m.Type))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovSpanConfig(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovSpanConfig(uint64(l))
	}
	return n
}

func (m *ConstraintsConjunction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NumReplicas != 0 {
		n += 1 + sovSpanConfig(uint64(m.NumReplicas))
	}
	if len(m.Constraints) > 0 {
		for _, e := range m.Constraints {
			l = e.Size()
			n += 1 + l + sovSpanConfig(uint64(l))
		}
	}
	return n
}

func (m *LeasePreference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Constraints) > 0 {
		for _, e := range m.Constraints {
			l = e.Size()
			n += 1 + l + sovSpanConfig(uint64(l))
		}
	}
	return n
}

func (m *SpanConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeMinBytes != 0 {
		n += 1 + sovSpanConfig(uint64(m.RangeMinBytes))
	}
	if m.RangeMaxBytes != 0 {
		n += 1 + sovSpanConfig(uint64(m.RangeMaxBytes))
	}
	l = m.GCPolicy.Size()
	n += 1 + l + sovSpanConfig(uint64(l))
	if m.GlobalReads {
		n += 2
	}
	if m.NumReplicas != 0 {
		n += 1 + sovSpanConfig(uint64(m.NumReplicas))
	}
	if m.NumVoters != 0 {
		n += 1 + sovSpanConfig(uint64(m.NumVoters))
	}
	if len(m.Constraints) > 0 {
		for _, e := range m.Constraints {
			l = e.Size()
			n += 1 + l + sovSpanConfig(uint64(l))
		}
	}
	if len(m.VoterConstraints) > 0 {
		for _, e := range m.VoterConstraints {
			l = e.Size()
			n += 1 + l + sovSpanConfig(uint64(l))
		}
	}
	if len(m.LeasePreferences) > 0 {
		for _, e := range m.LeasePreferences {
			l = e.Size()
			n += 1 + l + sovSpanConfig(uint64(l))
		}
	}
	if m.RangefeedEnabled {
		n += 2
	}
	if m.ExcludeDataFromBackup {
		n += 2
	}
	return n
}

func (m *SystemSpanConfigTarget) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.SourceTenantID.Size()
	n += 1 + l + sovSpanConfig(uint64(l))
	if m.TargetTenantID != nil {
		l = m.TargetTenantID.Size()
		n += 1 + l + sovSpanConfig(uint64(l))
	}
	return n
}

func (m *SpanConfigTarget) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Union != nil {
		n += m.Union.Size()
	}
	return n
}

func (m *SpanConfigTarget_Span) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Span != nil {
		l = m.Span.Size()
		n += 1 + l + sovSpanConfig(uint64(l))
	}
	return n
}
func (m *SpanConfigTarget_SystemSpanConfigTarget) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SystemSpanConfigTarget != nil {
		l = m.SystemSpanConfigTarget.Size()
		n += 1 + l + sovSpanConfig(uint64(l))
	}
	return n
}
func (m *SpanConfigEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Config.Size()
	n += 1 + l + sovSpanConfig(uint64(l))
	l = m.Target.Size()
	n += 1 + l + sovSpanConfig(uint64(l))
	return n
}

func (m *GetSpanConfigsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Targets) > 0 {
		for _, e := range m.Targets {
			l = e.Size()
			n += 1 + l + sovSpanConfig(uint64(l))
		}
	}
	return n
}

func (m *GetSpanConfigsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SpanConfigEntries) > 0 {
		for _, e := range m.SpanConfigEntries {
			l = e.Size()
			n += 1 + l + sovSpanConfig(uint64(l))
		}
	}
	return n
}

func (m *UpdateSpanConfigsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ToDelete) > 0 {
		for _, e := range m.ToDelete {
			l = e.Size()
			n += 1 + l + sovSpanConfig(uint64(l))
		}
	}
	if len(m.ToUpsert) > 0 {
		for _, e := range m.ToUpsert {
			l = e.Size()
			n += 1 + l + sovSpanConfig(uint64(l))
		}
	}
	return n
}

func (m *UpdateSpanConfigsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovSpanConfig(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSpanConfig(x uint64) (n int) {
	return sovSpanConfig(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GCPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTLSeconds", wireType)
			}
			m.TTLSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TTLSeconds |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtectionPolicies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProtectionPolicies = append(m.ProtectionPolicies, ProtectionPolicy{})
			if err := m.ProtectionPolicies[len(m.ProtectionPolicies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreStrictEnforcement", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IgnoreStrictEnforcement = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtectionPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtectionPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtectionPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtectedTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProtectedTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Constraint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Constraint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Constraint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Constraint_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConstraintsConjunction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConstraintsConjunction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConstraintsConjunction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumReplicas", wireType)
			}
			m.NumReplicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumReplicas |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constraints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Constraints = append(m.Constraints, Constraint{})
			if err := m.Constraints[len(m.Constraints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeasePreference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeasePreference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeasePreference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constraints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Constraints = append(m.Constraints, Constraint{})
			if err := m.Constraints[len(m.Constraints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeMinBytes", wireType)
			}
			m.RangeMinBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeMinBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeMaxBytes", wireType)
			}
			m.RangeMaxBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeMaxBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GCPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GCPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalReads", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GlobalReads = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumReplicas", wireType)
			}
			m.NumReplicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumReplicas |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumVoters", wireType)
			}
			m.NumVoters = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumVoters |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constraints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Constraints = append(m.Constraints, ConstraintsConjunction{})
			if err := m.Constraints[len(m.Constraints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoterConstraints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VoterConstraints = append(m.VoterConstraints, ConstraintsConjunction{})
			if err := m.VoterConstraints[len(m.VoterConstraints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeasePreferences", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeasePreferences = append(m.LeasePreferences, LeasePreference{})
			if err := m.LeasePreferences[len(m.LeasePreferences)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangefeedEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RangefeedEnabled = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeDataFromBackup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExcludeDataFromBackup = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SystemSpanConfigTarget) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SystemSpanConfigTarget: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SystemSpanConfigTarget: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceTenantID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SourceTenantID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetTenantID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TargetTenantID == nil {
				m.TargetTenantID = &TenantID{}
			}
			if err := m.TargetTenantID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanConfigTarget) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanConfigTarget: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanConfigTarget: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Span{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Union = &SpanConfigTarget_Span{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemSpanConfigTarget", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SystemSpanConfigTarget{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Union = &SpanConfigTarget_SystemSpanConfigTarget{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanConfigEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanConfigEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanConfigEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Target.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpanConfigsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpanConfigsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpanConfigsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Targets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Targets = append(m.Targets, SpanConfigTarget{})
			if err := m.Targets[len(m.Targets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpanConfigsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpanConfigsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpanConfigsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanConfigEntries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpanConfigEntries = append(m.SpanConfigEntries, SpanConfigEntry{})
			if err := m.SpanConfigEntries[len(m.SpanConfigEntries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateSpanConfigsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateSpanConfigsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateSpanConfigsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToDelete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToDelete = append(m.ToDelete, SpanConfigTarget{})
			if err := m.ToDelete[len(m.ToDelete)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToUpsert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToUpsert = append(m.ToUpsert, SpanConfigEntry{})
			if err := m.ToUpsert[len(m.ToUpsert)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateSpanConfigsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateSpanConfigsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateSpanConfigsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSpanConfig(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSpanConfig
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSpanConfig
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSpanConfig
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSpanConfig        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSpanConfig          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSpanConfig = fmt.Errorf("proto: unexpected end of group")
)
