// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: roachpb/span_config.proto

package roachpb

import (
	fmt "fmt"
	hlc "github.com/cockroachdb/cockroach/pkg/util/hlc"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Constraint_Type int32

const (
	// REQUIRED ensures all replicas are placed on stores with locality tags
	// that match the constraint. Replication will fail if there aren't any such
	// stores.
	Constraint_REQUIRED Constraint_Type = 0
	// PROHIBITED prevents replicas from being placed on stores with locality
	// tags that match the constrain.
	Constraint_PROHIBITED Constraint_Type = 1
)

var Constraint_Type_name = map[int32]string{
	0: "REQUIRED",
	1: "PROHIBITED",
}

var Constraint_Type_value = map[string]int32{
	"REQUIRED":   0,
	"PROHIBITED": 1,
}

func (x Constraint_Type) String() string {
	return proto.EnumName(Constraint_Type_name, int32(x))
}

func (Constraint_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{2, 0}
}

// GCPolicy dictates the garbage collection policy to apply over a given span.
type GCPolicy struct {
	// TTLSeconds is the number of seconds overwritten values will be retained
	// before garbage collection. A value <= 0 means older versions are never
	// GC-ed.
	TTLSeconds int32 `protobuf:"varint,1,opt,name=ttl_seconds,json=ttlSeconds,proto3" json:"ttl_seconds,omitempty"`
	// ProtectionPolicies is a list of policies that dictate GC behavior for a
	// range (in conjunction with the GC TTL). A ProtectionPolicy can be used
	// to indicate a timestamp above which GC should not run, regardless of the
	// GC TTL. The data it applies over is guaranteed to not be GC-ed provided it
	// wasn't GC-ed before the config applied.
	ProtectionPolicies []ProtectionPolicy `protobuf:"bytes,2,rep,name=protection_policies,json=protectionPolicies,proto3" json:"protection_policies"`
	// IgnoreStrictEnforcement is used to selectively opt out of strict GC TTL
	// enforcement (where requests served at timestamps below the TTL are made to
	// fail, even if the data exists).
	IgnoreStrictEnforcement bool `protobuf:"varint,3,opt,name=ignore_strict_enforcement,json=ignoreStrictEnforcement,proto3" json:"ignore_strict_enforcement,omitempty"`
}

func (m *GCPolicy) Reset()         { *m = GCPolicy{} }
func (m *GCPolicy) String() string { return proto.CompactTextString(m) }
func (*GCPolicy) ProtoMessage()    {}
func (*GCPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{0}
}
func (m *GCPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GCPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCPolicy.Merge(m, src)
}
func (m *GCPolicy) XXX_Size() int {
	return m.Size()
}
func (m *GCPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_GCPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_GCPolicy proto.InternalMessageInfo

// ProtectionPolicy dictates a protection policy against garbage collection that
// applies over a given span.
type ProtectionPolicy struct {
	// ProtectedTimestamp is a timestamp above which GC should not run, regardless
	// of the GC TTL.
	ProtectedTimestamp hlc.Timestamp `protobuf:"bytes,1,opt,name=protected_timestamp,json=protectedTimestamp,proto3" json:"protected_timestamp"`
}

func (m *ProtectionPolicy) Reset()         { *m = ProtectionPolicy{} }
func (m *ProtectionPolicy) String() string { return proto.CompactTextString(m) }
func (*ProtectionPolicy) ProtoMessage()    {}
func (*ProtectionPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{1}
}
func (m *ProtectionPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProtectionPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ProtectionPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtectionPolicy.Merge(m, src)
}
func (m *ProtectionPolicy) XXX_Size() int {
	return m.Size()
}
func (m *ProtectionPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtectionPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_ProtectionPolicy proto.InternalMessageInfo

// Constraint constrains the stores that a replica can be stored on. It
// parallels the definition found in zonepb/zone.proto.
type Constraint struct {
	// Type captures the kind of constraint this is: required or prohibited.
	Type Constraint_Type `protobuf:"varint,1,opt,name=type,proto3,enum=cockroach.roachpb.Constraint_Type" json:"type,omitempty"`
	// Key captures the locality tag key we're constraining against.
	Key string `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	// Value is the locality tag value we're constraining against.
	Value string `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Constraint) Reset()      { *m = Constraint{} }
func (*Constraint) ProtoMessage() {}
func (*Constraint) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{2}
}
func (m *Constraint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Constraint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Constraint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Constraint.Merge(m, src)
}
func (m *Constraint) XXX_Size() int {
	return m.Size()
}
func (m *Constraint) XXX_DiscardUnknown() {
	xxx_messageInfo_Constraint.DiscardUnknown(m)
}

var xxx_messageInfo_Constraint proto.InternalMessageInfo

// ConstraintsConjunction is the set of constraints that need to be satisfied
// together by replicas. It parallels the definition found in zonepb/zone.proto.
type ConstraintsConjunction struct {
	// NumReplicas is the number of replicas that should abide by the constraints
	// below. If set to zero, the constraints will apply to all replicas of the
	// range.
	//
	// NB: Only REQUIRED constraints are allowed when the number of replicas is
	// non-zero.
	NumReplicas int32 `protobuf:"varint,1,opt,name=num_replicas,json=numReplicas,proto3" json:"num_replicas,omitempty"`
	// Constraints is the set that needs to be satisfied by the store in order for
	// us to place replicas on it.
	Constraints []Constraint `protobuf:"bytes,2,rep,name=constraints,proto3" json:"constraints"`
}

func (m *ConstraintsConjunction) Reset()      { *m = ConstraintsConjunction{} }
func (*ConstraintsConjunction) ProtoMessage() {}
func (*ConstraintsConjunction) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{3}
}
func (m *ConstraintsConjunction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConstraintsConjunction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ConstraintsConjunction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConstraintsConjunction.Merge(m, src)
}
func (m *ConstraintsConjunction) XXX_Size() int {
	return m.Size()
}
func (m *ConstraintsConjunction) XXX_DiscardUnknown() {
	xxx_messageInfo_ConstraintsConjunction.DiscardUnknown(m)
}

var xxx_messageInfo_ConstraintsConjunction proto.InternalMessageInfo

// LeasePreference specifies a preference about where range leases should be
// located. It parallels the definition found in zonepb/zone.proto.
type LeasePreference struct {
	// Constraints is the set that needs to be satisfied by the store in order for
	// us to prefer placing leases on it.
	Constraints []Constraint `protobuf:"bytes,1,rep,name=constraints,proto3" json:"constraints"`
}

func (m *LeasePreference) Reset()         { *m = LeasePreference{} }
func (m *LeasePreference) String() string { return proto.CompactTextString(m) }
func (*LeasePreference) ProtoMessage()    {}
func (*LeasePreference) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{4}
}
func (m *LeasePreference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeasePreference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LeasePreference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeasePreference.Merge(m, src)
}
func (m *LeasePreference) XXX_Size() int {
	return m.Size()
}
func (m *LeasePreference) XXX_DiscardUnknown() {
	xxx_messageInfo_LeasePreference.DiscardUnknown(m)
}

var xxx_messageInfo_LeasePreference proto.InternalMessageInfo

// SpanConfig holds the configuration that applies to a given keyspan. It is a
// superset of the fields found in zonepb.zone.proto.
type SpanConfig struct {
	// RangeMinBytes is the minimum size, in bytes, a range can have. When a range
	// is less than this size, it'll be merged with an adjacent range.
	RangeMinBytes int64 `protobuf:"varint,1,opt,name=range_min_bytes,json=rangeMinBytes,proto3" json:"range_min_bytes,omitempty"`
	// RangeMaxBytes is the maximum size, in bytes, a range can have. When a range
	// is more than this size, it'll split into two ranges.
	RangeMaxBytes int64 `protobuf:"varint,2,opt,name=range_max_bytes,json=rangeMaxBytes,proto3" json:"range_max_bytes,omitempty"`
	// GCPolicy dictates the the GC policy to apply over a range.
	GCPolicy GCPolicy `protobuf:"bytes,3,opt,name=gc_policy,json=gcPolicy,proto3" json:"gc_policy"`
	// GlobalReads specifies whether transactions operating over the range(s)
	// should be configured to provide non-blocking behavior, meaning that reads
	// can be served consistently from all replicas and do not block on writes. In
	// exchange, writes get pushed into the future and must wait on commit to
	// ensure linearizability. For more, see #52745.
	GlobalReads bool `protobuf:"varint,4,opt,name=global_reads,json=globalReads,proto3" json:"global_reads,omitempty"`
	// NumReplicas specifies the number of replicas, including both voting and
	// non-voting kinds.
	NumReplicas int32 `protobuf:"varint,5,opt,name=num_replicas,json=numReplicas,proto3" json:"num_replicas,omitempty"`
	// NumVoters specifies the number of voter replicas. If set to zero, we'll
	// consider NumReplicas to be the voter replica count instead (i.e. no
	// non-voting replicas).
	NumVoters int32 `protobuf:"varint,6,opt,name=num_voters,json=numVoters,proto3" json:"num_voters,omitempty"`
	// Constraints constrain which stores the both voting and non-voting replicas
	// can be placed on.
	//
	// NB: The NumReplicas fields in Constraints must either:
	// - add up to at most SpanConfig.NumReplicas (pinning the sum of replicas and
	//   having the rest float freely);
	// - all be zero (applying each constraint to all replicas).
	Constraints []ConstraintsConjunction `protobuf:"bytes,7,rep,name=constraints,proto3" json:"constraints"`
	// VoterConstraints constrains which stores the voting replicas can be placed
	// on. This must be compatible with the Constraints field above, but not
	// necessarily a subset. It's compatible as long as there are no prohibitive
	// constraints above that are required here.
	VoterConstraints []ConstraintsConjunction `protobuf:"bytes,8,rep,name=voter_constraints,json=voterConstraints,proto3" json:"voter_constraints"`
	// LeasePreference captures the preference for how range leases are to be
	// placed. They're allowed to be placed elsewhere if needed, but will follow
	// the stated preferences when possible.
	//
	// More than one lease preference is allowed; they're considered as the most
	// preferred option to least. The first preference that an existing replica of
	// a range matches will take priority for the lease.
	LeasePreferences []LeasePreference `protobuf:"bytes,9,rep,name=lease_preferences,json=leasePreferences,proto3" json:"lease_preferences"`
	// RangefeedEnabled determines whether rangefeeds are enabled over the
	// specific range.
	RangefeedEnabled bool `protobuf:"varint,10,opt,name=rangefeed_enabled,json=rangefeedEnabled,proto3" json:"rangefeed_enabled,omitempty"`
}

func (m *SpanConfig) Reset()         { *m = SpanConfig{} }
func (m *SpanConfig) String() string { return proto.CompactTextString(m) }
func (*SpanConfig) ProtoMessage()    {}
func (*SpanConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{5}
}
func (m *SpanConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SpanConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanConfig.Merge(m, src)
}
func (m *SpanConfig) XXX_Size() int {
	return m.Size()
}
func (m *SpanConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SpanConfig proto.InternalMessageInfo

// SpanConfigEntry ties a span to its corresponding config.
type SpanConfigEntry struct {
	// Span is the keyspan the config is said to apply over.
	Span Span `protobuf:"bytes,1,opt,name=span,proto3" json:"span"`
	// Config is the set of attributes that apply over the corresponding keyspan.
	Config SpanConfig `protobuf:"bytes,2,opt,name=config,proto3" json:"config"`
}

func (m *SpanConfigEntry) Reset()         { *m = SpanConfigEntry{} }
func (m *SpanConfigEntry) String() string { return proto.CompactTextString(m) }
func (*SpanConfigEntry) ProtoMessage()    {}
func (*SpanConfigEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{6}
}
func (m *SpanConfigEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanConfigEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SpanConfigEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanConfigEntry.Merge(m, src)
}
func (m *SpanConfigEntry) XXX_Size() int {
	return m.Size()
}
func (m *SpanConfigEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanConfigEntry.DiscardUnknown(m)
}

var xxx_messageInfo_SpanConfigEntry proto.InternalMessageInfo

// GetSpanConfigsRequest is used to fetch the span configurations over the
// specified keyspans.
type GetSpanConfigsRequest struct {
	// Spans to request the configurations for. The spans listed here are not
	// allowed to overlap with one another.
	Spans []Span `protobuf:"bytes,1,rep,name=spans,proto3" json:"spans"`
}

func (m *GetSpanConfigsRequest) Reset()         { *m = GetSpanConfigsRequest{} }
func (m *GetSpanConfigsRequest) String() string { return proto.CompactTextString(m) }
func (*GetSpanConfigsRequest) ProtoMessage()    {}
func (*GetSpanConfigsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{7}
}
func (m *GetSpanConfigsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpanConfigsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpanConfigsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpanConfigsRequest.Merge(m, src)
}
func (m *GetSpanConfigsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetSpanConfigsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpanConfigsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpanConfigsRequest proto.InternalMessageInfo

// GetSpanConfigsResponse lists out the span configurations that overlap with
// the requested spans.
type GetSpanConfigsResponse struct {
	// SpanConfigEntries capture the span configurations over the requested spans.
	// The results for each Span in the matching GetSpanConfigsRequest are
	// flattened out into a single slice, and follow the same ordering. It's
	// possible for there to be no configurations for a given span; there'll
	// simply be no entries for it.
	SpanConfigEntries []SpanConfigEntry `protobuf:"bytes,1,rep,name=span_config_entries,json=spanConfigEntries,proto3" json:"span_config_entries"`
}

func (m *GetSpanConfigsResponse) Reset()         { *m = GetSpanConfigsResponse{} }
func (m *GetSpanConfigsResponse) String() string { return proto.CompactTextString(m) }
func (*GetSpanConfigsResponse) ProtoMessage()    {}
func (*GetSpanConfigsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{8}
}
func (m *GetSpanConfigsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpanConfigsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpanConfigsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpanConfigsResponse.Merge(m, src)
}
func (m *GetSpanConfigsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetSpanConfigsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpanConfigsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpanConfigsResponse proto.InternalMessageInfo

// UpdateSpanConfigsRequest is used to update the span configurations over the
// given spans.
//
// This is a "targeted" API: the spans being deleted are expected to have been
// present with the same bounds (same start/end key); the same is true for spans
// being upserted with new configs. If bounds are mismatched, an error is
// returned. If spans are being added, they're expected to not overlap with any
// existing spans. When divvying up an existing span into multiple others,
// callers are expected to delete the old and upsert the new ones. This can
// happen as part of the same request; we delete the spans marked for deletion
// before upserting whatever was requested.
//
// Spans are not allowed to overlap with other spans in the same list but can
// across lists. This is necessary to support the delete+upsert semantics
// described above.
type UpdateSpanConfigsRequest struct {
	// ToDelete captures the spans we want to delete configs for.
	ToDelete []Span `protobuf:"bytes,1,rep,name=to_delete,json=toDelete,proto3" json:"to_delete"`
	// ToUpsert captures the spans we want to upsert and the configs we want to
	// upsert with.
	ToUpsert []SpanConfigEntry `protobuf:"bytes,2,rep,name=to_upsert,json=toUpsert,proto3" json:"to_upsert"`
}

func (m *UpdateSpanConfigsRequest) Reset()         { *m = UpdateSpanConfigsRequest{} }
func (m *UpdateSpanConfigsRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateSpanConfigsRequest) ProtoMessage()    {}
func (*UpdateSpanConfigsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{9}
}
func (m *UpdateSpanConfigsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateSpanConfigsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UpdateSpanConfigsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateSpanConfigsRequest.Merge(m, src)
}
func (m *UpdateSpanConfigsRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateSpanConfigsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateSpanConfigsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateSpanConfigsRequest proto.InternalMessageInfo

type UpdateSpanConfigsResponse struct {
}

func (m *UpdateSpanConfigsResponse) Reset()         { *m = UpdateSpanConfigsResponse{} }
func (m *UpdateSpanConfigsResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateSpanConfigsResponse) ProtoMessage()    {}
func (*UpdateSpanConfigsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_91c9f1dcea14470a, []int{10}
}
func (m *UpdateSpanConfigsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateSpanConfigsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UpdateSpanConfigsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateSpanConfigsResponse.Merge(m, src)
}
func (m *UpdateSpanConfigsResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateSpanConfigsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateSpanConfigsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateSpanConfigsResponse proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("cockroach.roachpb.Constraint_Type", Constraint_Type_name, Constraint_Type_value)
	proto.RegisterType((*GCPolicy)(nil), "cockroach.roachpb.GCPolicy")
	proto.RegisterType((*ProtectionPolicy)(nil), "cockroach.roachpb.ProtectionPolicy")
	proto.RegisterType((*Constraint)(nil), "cockroach.roachpb.Constraint")
	proto.RegisterType((*ConstraintsConjunction)(nil), "cockroach.roachpb.ConstraintsConjunction")
	proto.RegisterType((*LeasePreference)(nil), "cockroach.roachpb.LeasePreference")
	proto.RegisterType((*SpanConfig)(nil), "cockroach.roachpb.SpanConfig")
	proto.RegisterType((*SpanConfigEntry)(nil), "cockroach.roachpb.SpanConfigEntry")
	proto.RegisterType((*GetSpanConfigsRequest)(nil), "cockroach.roachpb.GetSpanConfigsRequest")
	proto.RegisterType((*GetSpanConfigsResponse)(nil), "cockroach.roachpb.GetSpanConfigsResponse")
	proto.RegisterType((*UpdateSpanConfigsRequest)(nil), "cockroach.roachpb.UpdateSpanConfigsRequest")
	proto.RegisterType((*UpdateSpanConfigsResponse)(nil), "cockroach.roachpb.UpdateSpanConfigsResponse")
}

func init() { proto.RegisterFile("roachpb/span_config.proto", fileDescriptor_91c9f1dcea14470a) }

var fileDescriptor_91c9f1dcea14470a = []byte{
	// 894 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x55, 0x41, 0x6f, 0x1b, 0x45,
	0x14, 0xf6, 0x26, 0x4e, 0xba, 0x7e, 0x0e, 0x89, 0x3d, 0x2d, 0xed, 0xa6, 0x55, 0xec, 0x74, 0x41,
	0x28, 0x15, 0x92, 0x2d, 0x52, 0x89, 0x43, 0xb8, 0x39, 0xb1, 0x4a, 0x50, 0x10, 0xe9, 0xc6, 0x41,
	0xa8, 0x42, 0xac, 0xc6, 0xbb, 0x2f, 0xce, 0xd2, 0xf5, 0xcc, 0x32, 0x33, 0xae, 0xea, 0x23, 0x77,
	0x0e, 0x1c, 0x39, 0x80, 0x94, 0x9f, 0xc1, 0x4f, 0xc8, 0xb1, 0xc7, 0x5e, 0x88, 0xc0, 0xb9, 0xf0,
	0x33, 0xd0, 0xce, 0x8e, 0xed, 0xb5, 0x63, 0x85, 0xaa, 0xb7, 0xd9, 0xf7, 0xbe, 0xf7, 0xde, 0x37,
	0xdf, 0x7c, 0x33, 0x0b, 0x9b, 0x82, 0xd3, 0xe0, 0x3c, 0xe9, 0x36, 0x65, 0x42, 0x99, 0x1f, 0x70,
	0x76, 0x16, 0xf5, 0x1a, 0x89, 0xe0, 0x8a, 0x93, 0x6a, 0xc0, 0x83, 0x97, 0x3a, 0xdd, 0x30, 0xa0,
	0x87, 0x64, 0x8c, 0x0e, 0xa9, 0xa2, 0x19, 0xec, 0xe1, 0xbd, 0x1e, 0xef, 0x71, 0xbd, 0x6c, 0xa6,
	0x2b, 0x13, 0x75, 0x06, 0x2a, 0x8a, 0x9b, 0xe7, 0x71, 0xd0, 0x54, 0x51, 0x1f, 0xa5, 0xa2, 0xfd,
	0x24, 0xcb, 0xb8, 0x7f, 0x59, 0x60, 0x3f, 0xdb, 0x3f, 0xe6, 0x71, 0x14, 0x0c, 0x49, 0x13, 0xca,
	0x4a, 0xc5, 0xbe, 0xc4, 0x80, 0xb3, 0x50, 0x3a, 0xd6, 0xb6, 0xb5, 0xb3, 0xd2, 0x5a, 0x1f, 0x5d,
	0xd5, 0xa1, 0xd3, 0x39, 0x3a, 0xc9, 0xa2, 0x1e, 0x28, 0x15, 0x9b, 0x35, 0x79, 0x01, 0x77, 0xd3,
	0x36, 0x18, 0xa8, 0x88, 0x33, 0x3f, 0x49, 0xbb, 0x44, 0x28, 0x9d, 0xa5, 0xed, 0xe5, 0x9d, 0xf2,
	0xee, 0x47, 0x8d, 0x1b, 0x94, 0x1b, 0xc7, 0x13, 0x74, 0x36, 0xb2, 0x55, 0xbc, 0xbc, 0xaa, 0x17,
	0x3c, 0x92, 0xcc, 0xc6, 0x23, 0x94, 0x64, 0x0f, 0x36, 0xa3, 0x1e, 0xe3, 0x02, 0x7d, 0xa9, 0x44,
	0x14, 0x28, 0x1f, 0xd9, 0x19, 0x17, 0x01, 0xf6, 0x91, 0x29, 0x67, 0x79, 0xdb, 0xda, 0xb1, 0xbd,
	0x07, 0x19, 0xe0, 0x44, 0xe7, 0xdb, 0xd3, 0xf4, 0x9e, 0xfd, 0xe7, 0x45, 0xdd, 0xfa, 0xf7, 0xa2,
	0x6e, 0xb9, 0x02, 0x2a, 0xf3, 0x33, 0x49, 0x67, 0xc2, 0x1a, 0x43, 0x7f, 0x22, 0x88, 0xde, 0x6e,
	0x79, 0x77, 0x2b, 0xc7, 0x3a, 0x55, 0xad, 0x71, 0x1e, 0x07, 0x8d, 0xce, 0x18, 0x34, 0xc7, 0x17,
	0xc3, 0x49, 0x26, 0x37, 0xf3, 0x77, 0x0b, 0x60, 0x9f, 0x33, 0xa9, 0x04, 0x8d, 0x98, 0x22, 0x9f,
	0x43, 0x51, 0x0d, 0x13, 0xd4, 0xfd, 0xd7, 0x77, 0xdd, 0x05, 0xaa, 0x4c, 0xc1, 0x8d, 0xce, 0x30,
	0x41, 0x4f, 0xe3, 0x49, 0x05, 0x96, 0x5f, 0xe2, 0xd0, 0x59, 0xda, 0xb6, 0x76, 0x4a, 0x5e, 0xba,
	0x24, 0xf7, 0x60, 0xe5, 0x15, 0x8d, 0x07, 0xa8, 0xb7, 0x5f, 0xf2, 0xb2, 0x0f, 0xf7, 0x63, 0x28,
	0xa6, 0x55, 0x64, 0x0d, 0x6c, 0xaf, 0xfd, 0xfc, 0xf4, 0xd0, 0x6b, 0x1f, 0x54, 0x0a, 0x64, 0x1d,
	0xe0, 0xd8, 0xfb, 0xe6, 0xcb, 0xc3, 0xd6, 0x61, 0xa7, 0x7d, 0x50, 0xb1, 0xf6, 0xec, 0xdf, 0x2e,
	0xea, 0x05, 0x4d, 0xef, 0x17, 0x0b, 0xee, 0x4f, 0x27, 0xca, 0x7d, 0xce, 0x7e, 0x1c, 0x30, 0xad,
	0x0f, 0x79, 0x0c, 0x6b, 0x6c, 0xd0, 0xf7, 0x05, 0x26, 0x71, 0x14, 0x50, 0xe3, 0x00, 0xaf, 0xcc,
	0x06, 0x7d, 0xcf, 0x84, 0x48, 0x1b, 0xca, 0xc1, 0xb4, 0xd8, 0x1c, 0xf5, 0xd6, 0xad, 0x9b, 0x32,
	0xa2, 0xe5, 0xeb, 0x72, 0x74, 0x7e, 0x80, 0x8d, 0x23, 0xa4, 0x12, 0x8f, 0x05, 0x9e, 0xa1, 0x40,
	0x16, 0xe0, 0xfc, 0x0c, 0xeb, 0x3d, 0x67, 0x14, 0x75, 0xff, 0xcb, 0x22, 0xc0, 0x49, 0x42, 0xd9,
	0xbe, 0xbe, 0x4d, 0xe4, 0x13, 0xd8, 0x10, 0x94, 0xf5, 0xd0, 0xef, 0x47, 0xcc, 0xef, 0x0e, 0x15,
	0x66, 0xbb, 0x5c, 0xf6, 0x3e, 0xd0, 0xe1, 0xaf, 0x23, 0xd6, 0x4a, 0x83, 0x39, 0x1c, 0x7d, 0x6d,
	0x70, 0x4b, 0x79, 0x1c, 0x7d, 0x9d, 0xe1, 0xbe, 0x82, 0x52, 0x2f, 0xc8, 0xac, 0x3f, 0xd4, 0xe7,
	0x52, 0xde, 0x7d, 0xb4, 0x80, 0xe9, 0xf8, 0x8e, 0xb5, 0x2a, 0x29, 0xcf, 0xd1, 0x55, 0x7d, 0x72,
	0xeb, 0x3c, 0xbb, 0x17, 0x18, 0x63, 0x3e, 0x86, 0xb5, 0x5e, 0xcc, 0xbb, 0x34, 0xf6, 0x05, 0xd2,
	0x50, 0x3a, 0x45, 0xed, 0xf2, 0x72, 0x16, 0xf3, 0xd2, 0xd0, 0x8d, 0x13, 0x5a, 0xb9, 0x79, 0x42,
	0x5b, 0x00, 0x29, 0xe4, 0x15, 0x57, 0x28, 0xa4, 0xb3, 0xaa, 0x01, 0x25, 0x36, 0xe8, 0x7f, 0xab,
	0x03, 0xe4, 0xf9, 0xac, 0xb8, 0x77, 0xb4, 0xb8, 0x4f, 0x6e, 0x15, 0x37, 0xef, 0x91, 0x05, 0x42,
	0x93, 0xef, 0xa1, 0xaa, 0xa7, 0xf9, 0xf9, 0xc6, 0xf6, 0xfb, 0x35, 0xae, 0xe8, 0x4e, 0x39, 0x08,
	0x39, 0x85, 0x6a, 0x9c, 0x1a, 0xc4, 0x4f, 0x26, 0x0e, 0x91, 0x4e, 0x49, 0x77, 0x5f, 0x74, 0x99,
	0xe6, 0xcc, 0x34, 0x6e, 0x1b, 0xcf, 0x86, 0x25, 0xf9, 0x14, 0xaa, 0xfa, 0x24, 0xcf, 0x10, 0x43,
	0x1f, 0x19, 0xed, 0xc6, 0x18, 0x3a, 0xa0, 0x15, 0xaf, 0x4c, 0x12, 0xed, 0x2c, 0x6e, 0xac, 0xf4,
	0xb3, 0x05, 0x1b, 0x53, 0x2b, 0xb5, 0x99, 0x12, 0x43, 0xf2, 0x19, 0x14, 0xd3, 0xc7, 0xda, 0xbc,
	0x1e, 0x0f, 0x16, 0x10, 0x4a, 0x2b, 0x0c, 0x0b, 0x0d, 0x25, 0x5f, 0xc0, 0x6a, 0xf6, 0xb4, 0x6b,
	0x47, 0x2d, 0x76, 0xf6, 0x74, 0x8c, 0x29, 0x35, 0x25, 0xee, 0x11, 0x7c, 0xf8, 0x0c, 0xd5, 0x34,
	0x2d, 0x3d, 0xfc, 0x69, 0x80, 0x52, 0x91, 0xa7, 0xb0, 0x92, 0x76, 0x1f, 0x5f, 0x97, 0xff, 0x61,
	0x92, 0x61, 0x5d, 0x01, 0xf7, 0xe7, 0xbb, 0xc9, 0x84, 0x33, 0x89, 0xe4, 0x3b, 0xb8, 0x9b, 0xfb,
	0x09, 0xf9, 0xc8, 0x94, 0x88, 0x70, 0xdc, 0xdc, 0xbd, 0x95, 0xb1, 0x16, 0xc6, 0xcc, 0xa9, 0xca,
	0x99, 0x70, 0x84, 0xd2, 0xfd, 0xc3, 0x02, 0xe7, 0x34, 0x09, 0xa9, 0xc2, 0x05, 0xbb, 0xd8, 0x83,
	0x92, 0xe2, 0x7e, 0x88, 0x31, 0x2a, 0x7c, 0xb7, 0x9d, 0xd8, 0x8a, 0x1f, 0x68, 0x38, 0x69, 0xeb,
	0xda, 0x41, 0x22, 0x51, 0x28, 0xf3, 0x30, 0xbd, 0x3b, 0x51, 0x5b, 0xf1, 0x53, 0x5d, 0xe9, 0x3e,
	0x82, 0xcd, 0x05, 0xf4, 0x32, 0x59, 0x5a, 0x4f, 0x2e, 0xff, 0xa9, 0x15, 0x2e, 0x47, 0x35, 0xeb,
	0xcd, 0xa8, 0x66, 0xbd, 0x1d, 0xd5, 0xac, 0xbf, 0x47, 0x35, 0xeb, 0xd7, 0xeb, 0x5a, 0xe1, 0xcd,
	0x75, 0xad, 0xf0, 0xf6, 0xba, 0x56, 0x78, 0x71, 0xc7, 0xcc, 0xe9, 0xae, 0xea, 0x3f, 0xec, 0xd3,
	0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0x23, 0x54, 0x4e, 0xe6, 0xd5, 0x07, 0x00, 0x00,
}

func (this *GCPolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPolicy)
	if !ok {
		that2, ok := that.(GCPolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TTLSeconds != that1.TTLSeconds {
		return false
	}
	if len(this.ProtectionPolicies) != len(that1.ProtectionPolicies) {
		return false
	}
	for i := range this.ProtectionPolicies {
		if !this.ProtectionPolicies[i].Equal(&that1.ProtectionPolicies[i]) {
			return false
		}
	}
	if this.IgnoreStrictEnforcement != that1.IgnoreStrictEnforcement {
		return false
	}
	return true
}
func (this *ProtectionPolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtectionPolicy)
	if !ok {
		that2, ok := that.(ProtectionPolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ProtectedTimestamp.Equal(&that1.ProtectedTimestamp) {
		return false
	}
	return true
}
func (this *Constraint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Constraint)
	if !ok {
		that2, ok := that.(Constraint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *ConstraintsConjunction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConstraintsConjunction)
	if !ok {
		that2, ok := that.(ConstraintsConjunction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NumReplicas != that1.NumReplicas {
		return false
	}
	if len(this.Constraints) != len(that1.Constraints) {
		return false
	}
	for i := range this.Constraints {
		if !this.Constraints[i].Equal(&that1.Constraints[i]) {
			return false
		}
	}
	return true
}
func (this *LeasePreference) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LeasePreference)
	if !ok {
		that2, ok := that.(LeasePreference)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Constraints) != len(that1.Constraints) {
		return false
	}
	for i := range this.Constraints {
		if !this.Constraints[i].Equal(&that1.Constraints[i]) {
			return false
		}
	}
	return true
}
func (this *SpanConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SpanConfig)
	if !ok {
		that2, ok := that.(SpanConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RangeMinBytes != that1.RangeMinBytes {
		return false
	}
	if this.RangeMaxBytes != that1.RangeMaxBytes {
		return false
	}
	if !this.GCPolicy.Equal(&that1.GCPolicy) {
		return false
	}
	if this.GlobalReads != that1.GlobalReads {
		return false
	}
	if this.NumReplicas != that1.NumReplicas {
		return false
	}
	if this.NumVoters != that1.NumVoters {
		return false
	}
	if len(this.Constraints) != len(that1.Constraints) {
		return false
	}
	for i := range this.Constraints {
		if !this.Constraints[i].Equal(&that1.Constraints[i]) {
			return false
		}
	}
	if len(this.VoterConstraints) != len(that1.VoterConstraints) {
		return false
	}
	for i := range this.VoterConstraints {
		if !this.VoterConstraints[i].Equal(&that1.VoterConstraints[i]) {
			return false
		}
	}
	if len(this.LeasePreferences) != len(that1.LeasePreferences) {
		return false
	}
	for i := range this.LeasePreferences {
		if !this.LeasePreferences[i].Equal(&that1.LeasePreferences[i]) {
			return false
		}
	}
	if this.RangefeedEnabled != that1.RangefeedEnabled {
		return false
	}
	return true
}
func (m *GCPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IgnoreStrictEnforcement {
		i--
		if m.IgnoreStrictEnforcement {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.ProtectionPolicies) > 0 {
		for iNdEx := len(m.ProtectionPolicies) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ProtectionPolicies[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpanConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.TTLSeconds != 0 {
		i = encodeVarintSpanConfig(dAtA, i, uint64(m.TTLSeconds))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProtectionPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtectionPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtectionPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ProtectedTimestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSpanConfig(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Constraint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Constraint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Constraint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintSpanConfig(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintSpanConfig(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintSpanConfig(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ConstraintsConjunction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConstraintsConjunction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConstraintsConjunction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Constraints) > 0 {
		for iNdEx := len(m.Constraints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Constraints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpanConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.NumReplicas != 0 {
		i = encodeVarintSpanConfig(dAtA, i, uint64(m.NumReplicas))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LeasePreference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeasePreference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeasePreference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Constraints) > 0 {
		for iNdEx := len(m.Constraints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Constraints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpanConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SpanConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RangefeedEnabled {
		i--
		if m.RangefeedEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.LeasePreferences) > 0 {
		for iNdEx := len(m.LeasePreferences) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LeasePreferences[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpanConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.VoterConstraints) > 0 {
		for iNdEx := len(m.VoterConstraints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VoterConstraints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpanConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Constraints) > 0 {
		for iNdEx := len(m.Constraints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Constraints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpanConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.NumVoters != 0 {
		i = encodeVarintSpanConfig(dAtA, i, uint64(m.NumVoters))
		i--
		dAtA[i] = 0x30
	}
	if m.NumReplicas != 0 {
		i = encodeVarintSpanConfig(dAtA, i, uint64(m.NumReplicas))
		i--
		dAtA[i] = 0x28
	}
	if m.GlobalReads {
		i--
		if m.GlobalReads {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.GCPolicy.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSpanConfig(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.RangeMaxBytes != 0 {
		i = encodeVarintSpanConfig(dAtA, i, uint64(m.RangeMaxBytes))
		i--
		dAtA[i] = 0x10
	}
	if m.RangeMinBytes != 0 {
		i = encodeVarintSpanConfig(dAtA, i, uint64(m.RangeMinBytes))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SpanConfigEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanConfigEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanConfigEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Config.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSpanConfig(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Span.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSpanConfig(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GetSpanConfigsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpanConfigsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpanConfigsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Spans) > 0 {
		for iNdEx := len(m.Spans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Spans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpanConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetSpanConfigsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpanConfigsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpanConfigsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SpanConfigEntries) > 0 {
		for iNdEx := len(m.SpanConfigEntries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SpanConfigEntries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpanConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UpdateSpanConfigsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateSpanConfigsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateSpanConfigsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ToUpsert) > 0 {
		for iNdEx := len(m.ToUpsert) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ToUpsert[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpanConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ToDelete) > 0 {
		for iNdEx := len(m.ToDelete) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ToDelete[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpanConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UpdateSpanConfigsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateSpanConfigsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateSpanConfigsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintSpanConfig(dAtA []byte, offset int, v uint64) int {
	offset -= sovSpanConfig(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func NewPopulatedGCPolicy(r randySpanConfig, easy bool) *GCPolicy {
	this := &GCPolicy{}
	this.TTLSeconds = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.TTLSeconds *= -1
	}
	if r.Intn(5) != 0 {
		v1 := r.Intn(5)
		this.ProtectionPolicies = make([]ProtectionPolicy, v1)
		for i := 0; i < v1; i++ {
			v2 := NewPopulatedProtectionPolicy(r, easy)
			this.ProtectionPolicies[i] = *v2
		}
	}
	this.IgnoreStrictEnforcement = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedProtectionPolicy(r randySpanConfig, easy bool) *ProtectionPolicy {
	this := &ProtectionPolicy{}
	v3 := hlc.NewPopulatedTimestamp(r, easy)
	this.ProtectedTimestamp = *v3
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randySpanConfig interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneSpanConfig(r randySpanConfig) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringSpanConfig(r randySpanConfig) string {
	v4 := r.Intn(100)
	tmps := make([]rune, v4)
	for i := 0; i < v4; i++ {
		tmps[i] = randUTF8RuneSpanConfig(r)
	}
	return string(tmps)
}
func randUnrecognizedSpanConfig(r randySpanConfig, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldSpanConfig(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldSpanConfig(dAtA []byte, r randySpanConfig, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateSpanConfig(dAtA, uint64(key))
		v5 := r.Int63()
		if r.Intn(2) == 0 {
			v5 *= -1
		}
		dAtA = encodeVarintPopulateSpanConfig(dAtA, uint64(v5))
	case 1:
		dAtA = encodeVarintPopulateSpanConfig(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateSpanConfig(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateSpanConfig(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateSpanConfig(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateSpanConfig(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *GCPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TTLSeconds != 0 {
		n += 1 + sovSpanConfig(uint64(m.TTLSeconds))
	}
	if len(m.ProtectionPolicies) > 0 {
		for _, e := range m.ProtectionPolicies {
			l = e.Size()
			n += 1 + l + sovSpanConfig(uint64(l))
		}
	}
	if m.IgnoreStrictEnforcement {
		n += 2
	}
	return n
}

func (m *ProtectionPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ProtectedTimestamp.Size()
	n += 1 + l + sovSpanConfig(uint64(l))
	return n
}

func (m *Constraint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovSpanConfig(uint64(m.Type))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovSpanConfig(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovSpanConfig(uint64(l))
	}
	return n
}

func (m *ConstraintsConjunction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NumReplicas != 0 {
		n += 1 + sovSpanConfig(uint64(m.NumReplicas))
	}
	if len(m.Constraints) > 0 {
		for _, e := range m.Constraints {
			l = e.Size()
			n += 1 + l + sovSpanConfig(uint64(l))
		}
	}
	return n
}

func (m *LeasePreference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Constraints) > 0 {
		for _, e := range m.Constraints {
			l = e.Size()
			n += 1 + l + sovSpanConfig(uint64(l))
		}
	}
	return n
}

func (m *SpanConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeMinBytes != 0 {
		n += 1 + sovSpanConfig(uint64(m.RangeMinBytes))
	}
	if m.RangeMaxBytes != 0 {
		n += 1 + sovSpanConfig(uint64(m.RangeMaxBytes))
	}
	l = m.GCPolicy.Size()
	n += 1 + l + sovSpanConfig(uint64(l))
	if m.GlobalReads {
		n += 2
	}
	if m.NumReplicas != 0 {
		n += 1 + sovSpanConfig(uint64(m.NumReplicas))
	}
	if m.NumVoters != 0 {
		n += 1 + sovSpanConfig(uint64(m.NumVoters))
	}
	if len(m.Constraints) > 0 {
		for _, e := range m.Constraints {
			l = e.Size()
			n += 1 + l + sovSpanConfig(uint64(l))
		}
	}
	if len(m.VoterConstraints) > 0 {
		for _, e := range m.VoterConstraints {
			l = e.Size()
			n += 1 + l + sovSpanConfig(uint64(l))
		}
	}
	if len(m.LeasePreferences) > 0 {
		for _, e := range m.LeasePreferences {
			l = e.Size()
			n += 1 + l + sovSpanConfig(uint64(l))
		}
	}
	if m.RangefeedEnabled {
		n += 2
	}
	return n
}

func (m *SpanConfigEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Span.Size()
	n += 1 + l + sovSpanConfig(uint64(l))
	l = m.Config.Size()
	n += 1 + l + sovSpanConfig(uint64(l))
	return n
}

func (m *GetSpanConfigsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Spans) > 0 {
		for _, e := range m.Spans {
			l = e.Size()
			n += 1 + l + sovSpanConfig(uint64(l))
		}
	}
	return n
}

func (m *GetSpanConfigsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SpanConfigEntries) > 0 {
		for _, e := range m.SpanConfigEntries {
			l = e.Size()
			n += 1 + l + sovSpanConfig(uint64(l))
		}
	}
	return n
}

func (m *UpdateSpanConfigsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ToDelete) > 0 {
		for _, e := range m.ToDelete {
			l = e.Size()
			n += 1 + l + sovSpanConfig(uint64(l))
		}
	}
	if len(m.ToUpsert) > 0 {
		for _, e := range m.ToUpsert {
			l = e.Size()
			n += 1 + l + sovSpanConfig(uint64(l))
		}
	}
	return n
}

func (m *UpdateSpanConfigsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovSpanConfig(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSpanConfig(x uint64) (n int) {
	return sovSpanConfig(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GCPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTLSeconds", wireType)
			}
			m.TTLSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TTLSeconds |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtectionPolicies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProtectionPolicies = append(m.ProtectionPolicies, ProtectionPolicy{})
			if err := m.ProtectionPolicies[len(m.ProtectionPolicies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreStrictEnforcement", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IgnoreStrictEnforcement = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtectionPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtectionPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtectionPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtectedTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProtectedTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Constraint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Constraint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Constraint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Constraint_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConstraintsConjunction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConstraintsConjunction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConstraintsConjunction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumReplicas", wireType)
			}
			m.NumReplicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumReplicas |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constraints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Constraints = append(m.Constraints, Constraint{})
			if err := m.Constraints[len(m.Constraints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeasePreference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeasePreference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeasePreference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constraints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Constraints = append(m.Constraints, Constraint{})
			if err := m.Constraints[len(m.Constraints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeMinBytes", wireType)
			}
			m.RangeMinBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeMinBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeMaxBytes", wireType)
			}
			m.RangeMaxBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeMaxBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GCPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GCPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalReads", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GlobalReads = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumReplicas", wireType)
			}
			m.NumReplicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumReplicas |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumVoters", wireType)
			}
			m.NumVoters = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumVoters |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constraints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Constraints = append(m.Constraints, ConstraintsConjunction{})
			if err := m.Constraints[len(m.Constraints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoterConstraints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VoterConstraints = append(m.VoterConstraints, ConstraintsConjunction{})
			if err := m.VoterConstraints[len(m.VoterConstraints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeasePreferences", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeasePreferences = append(m.LeasePreferences, LeasePreference{})
			if err := m.LeasePreferences[len(m.LeasePreferences)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangefeedEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RangefeedEnabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanConfigEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanConfigEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanConfigEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Span.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpanConfigsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpanConfigsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpanConfigsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spans = append(m.Spans, Span{})
			if err := m.Spans[len(m.Spans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpanConfigsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpanConfigsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpanConfigsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanConfigEntries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpanConfigEntries = append(m.SpanConfigEntries, SpanConfigEntry{})
			if err := m.SpanConfigEntries[len(m.SpanConfigEntries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateSpanConfigsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateSpanConfigsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateSpanConfigsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToDelete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToDelete = append(m.ToDelete, Span{})
			if err := m.ToDelete[len(m.ToDelete)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToUpsert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToUpsert = append(m.ToUpsert, SpanConfigEntry{})
			if err := m.ToUpsert[len(m.ToUpsert)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateSpanConfigsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateSpanConfigsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateSpanConfigsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSpanConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSpanConfig(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSpanConfig
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSpanConfig
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSpanConfig
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSpanConfig
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSpanConfig
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSpanConfig        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSpanConfig          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSpanConfig = fmt.Errorf("proto: unexpected end of group")
)
