// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: roachpb/span_stats.proto

package roachpb

import (
	fmt "fmt"
	enginepb "github.com/cockroachdb/cockroach/pkg/storage/enginepb"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// SpanStatsRequest is used to request a SpanStatsResponse for the given key
// span and node id. A node_id value of 0 indicates that the server should
// fan-out to all nodes, and the resulting SpanStatsResponse is a cumulative
// result from across the cluster.
type SpanStatsRequest struct {
	NodeID string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// Note: start_key and end_key are legacy fields, safe to deprecate (i.e. reserve) in 23.2.
	// Callers are intended to use the spans field below.
	// Field is not reserved as we use it to detect whether a request is being made from a previous
	// versioned node (i.e. in a mixed-version cluster).
	// TODO(thomas): reserved these fields in 23.2.
	StartKey      RKey   `protobuf:"bytes,2,opt,name=start_key,json=startKey,proto3,casttype=RKey" json:"start_key,omitempty"`
	EndKey        RKey   `protobuf:"bytes,3,opt,name=end_key,json=endKey,proto3,casttype=RKey" json:"end_key,omitempty"`
	Spans         []Span `protobuf:"bytes,4,rep,name=spans,proto3" json:"spans"`
	SkipMvccStats bool   `protobuf:"varint,5,opt,name=skip_mvcc_stats,json=skipMvccStats,proto3" json:"skip_mvcc_stats,omitempty"`
}

func (m *SpanStatsRequest) Reset()         { *m = SpanStatsRequest{} }
func (m *SpanStatsRequest) String() string { return proto.CompactTextString(m) }
func (*SpanStatsRequest) ProtoMessage()    {}
func (*SpanStatsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e33c50b6f7bbce45, []int{0}
}
func (m *SpanStatsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanStatsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SpanStatsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanStatsRequest.Merge(m, src)
}
func (m *SpanStatsRequest) XXX_Size() int {
	return m.Size()
}
func (m *SpanStatsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanStatsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SpanStatsRequest proto.InternalMessageInfo

type SpanStats struct {
	// TotalStats are the logical MVCC stats for the requested span.
	TotalStats enginepb.MVCCStats `protobuf:"bytes,1,opt,name=total_stats,json=totalStats,proto3" json:"total_stats"`
	// range_count measures the number of ranges that the request span falls within.
	// A SpanStatsResponse for a span that lies within a range, and whose start
	// key sorts after the range start, and whose end key sorts before the
	// range end, will have a range_count value of 1.
	RangeCount int32 `protobuf:"varint,2,opt,name=range_count,json=rangeCount,proto3" json:"range_count,omitempty"`
	// ApproximateDiskBytes is the approximate size "on-disk" in all files of the
	// data in the span. NB; this *includes* files stored remotely, not just on
	// _local_ disk; see the RemoteFileBytes field below.
	// It represents a physical value across all replicas.
	// NB: The explicit jsontag prevents 'omitempty` from being added by default.
	ApproximateDiskBytes uint64 `protobuf:"varint,3,opt,name=approximate_disk_bytes,json=approximateDiskBytes,proto3" json:"approximate_disk_bytes"`
	// RemoteFileBytes is the subset of ApproximateDiskBytes which are stored in
	// "remote" files (i.e. shared files and external files). It represents a
	// physical value across all replicas.
	RemoteFileBytes uint64 `protobuf:"varint,5,opt,name=remote_file_bytes,json=remoteFileBytes,proto3" json:"remote_file_bytes,omitempty"`
	// ExternalFileBytes is the subset of RemoteFileBytes that are in "external"
	// files (not written/owned by this cluster, such as in restored backups).
	// It represents a physical value across all replicas.
	ExternalFileBytes uint64 `protobuf:"varint,6,opt,name=external_file_bytes,json=externalFileBytes,proto3" json:"external_file_bytes,omitempty"`
	// ApproximateTotalStats is the approximate, post-replicated MVCC stats for
	// the requested span. This is an approximate value as it is constructed by
	// querying all replicas, which includes followers, and the value can be
	// stale.
	ApproximateTotalStats enginepb.MVCCStats `protobuf:"bytes,7,opt,name=approximate_total_stats,json=approximateTotalStats,proto3" json:"approximate_total_stats"`
}

func (m *SpanStats) Reset()         { *m = SpanStats{} }
func (m *SpanStats) String() string { return proto.CompactTextString(m) }
func (*SpanStats) ProtoMessage()    {}
func (*SpanStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_e33c50b6f7bbce45, []int{1}
}
func (m *SpanStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SpanStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanStats.Merge(m, src)
}
func (m *SpanStats) XXX_Size() int {
	return m.Size()
}
func (m *SpanStats) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanStats.DiscardUnknown(m)
}

var xxx_messageInfo_SpanStats proto.InternalMessageInfo

type SpanStatsResponse struct {
	SpanToStats map[string]*SpanStats `protobuf:"bytes,4,rep,name=span_to_stats,json=spanToStats,proto3" json:"span_to_stats,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Errors      []string              `protobuf:"bytes,5,rep,name=errors,proto3" json:"errors,omitempty"`
}

func (m *SpanStatsResponse) Reset()         { *m = SpanStatsResponse{} }
func (m *SpanStatsResponse) String() string { return proto.CompactTextString(m) }
func (*SpanStatsResponse) ProtoMessage()    {}
func (*SpanStatsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e33c50b6f7bbce45, []int{2}
}
func (m *SpanStatsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanStatsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SpanStatsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanStatsResponse.Merge(m, src)
}
func (m *SpanStatsResponse) XXX_Size() int {
	return m.Size()
}
func (m *SpanStatsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanStatsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SpanStatsResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*SpanStatsRequest)(nil), "cockroach.roachpb.SpanStatsRequest")
	proto.RegisterType((*SpanStats)(nil), "cockroach.roachpb.SpanStats")
	proto.RegisterType((*SpanStatsResponse)(nil), "cockroach.roachpb.SpanStatsResponse")
	proto.RegisterMapType((map[string]*SpanStats)(nil), "cockroach.roachpb.SpanStatsResponse.SpanToStatsEntry")
}

func init() { proto.RegisterFile("roachpb/span_stats.proto", fileDescriptor_e33c50b6f7bbce45) }

var fileDescriptor_e33c50b6f7bbce45 = []byte{
	// 630 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x53, 0x41, 0x6b, 0xdb, 0x4c,
	0x10, 0xb5, 0x2c, 0xd9, 0xb1, 0xd7, 0x5f, 0x88, 0xbd, 0x5f, 0x9a, 0x18, 0x37, 0xc8, 0x6e, 0x4a,
	0x8a, 0x29, 0x45, 0x02, 0x87, 0x42, 0xe9, 0xd1, 0x49, 0x0b, 0x49, 0x9a, 0x50, 0x94, 0x50, 0x68,
	0x29, 0x88, 0xb5, 0x34, 0x55, 0x84, 0xed, 0x5d, 0x75, 0x77, 0x1d, 0xe2, 0x1f, 0x51, 0xe8, 0xcf,
	0xca, 0x31, 0xc7, 0x9c, 0x4c, 0xeb, 0xdc, 0xfa, 0x03, 0x7a, 0xe8, 0xa9, 0xec, 0x4a, 0x89, 0xd5,
	0x96, 0x14, 0x7a, 0x1b, 0xbd, 0x79, 0x33, 0x6f, 0xe6, 0x69, 0x16, 0x35, 0x39, 0x23, 0xc1, 0x69,
	0x32, 0x70, 0x45, 0x42, 0xa8, 0x2f, 0x24, 0x91, 0xc2, 0x49, 0x38, 0x93, 0x0c, 0x37, 0x02, 0x16,
	0x0c, 0x75, 0xd6, 0xc9, 0x38, 0xad, 0xfb, 0x42, 0x32, 0x4e, 0x22, 0x70, 0x81, 0x46, 0x31, 0x85,
	0x64, 0xe0, 0x8e, 0xcf, 0x82, 0x20, 0xe5, 0xb7, 0x56, 0x23, 0x16, 0x31, 0x1d, 0xba, 0x2a, 0xca,
	0xd0, 0x8d, 0x88, 0xb1, 0x68, 0x04, 0x2e, 0x49, 0x62, 0x97, 0x50, 0xca, 0x24, 0x91, 0x31, 0xa3,
	0x99, 0x46, 0x0b, 0xdf, 0xa8, 0x87, 0x44, 0x92, 0x14, 0xdb, 0x9c, 0x19, 0xa8, 0x7e, 0x9c, 0x10,
	0x7a, 0xac, 0x66, 0xf1, 0xe0, 0xe3, 0x04, 0x84, 0xc4, 0x0f, 0xd1, 0x12, 0x65, 0x21, 0xf8, 0x71,
	0xd8, 0x34, 0x3a, 0x46, 0xb7, 0xda, 0x47, 0xf3, 0x59, 0xbb, 0x7c, 0xc4, 0x42, 0xd8, 0xdb, 0xf5,
	0xca, 0x2a, 0xb5, 0x17, 0xe2, 0x2d, 0x54, 0x15, 0x92, 0x70, 0xe9, 0x0f, 0x61, 0xda, 0x2c, 0x76,
	0x8c, 0xee, 0x7f, 0xfd, 0xca, 0x8f, 0x59, 0xdb, 0xf2, 0x0e, 0x60, 0xea, 0x55, 0x74, 0xea, 0x00,
	0xa6, 0xf8, 0x01, 0x5a, 0x02, 0x1a, 0x6a, 0x92, 0xf9, 0x1b, 0xa9, 0x0c, 0x34, 0x54, 0x94, 0x6d,
	0x54, 0x52, 0x7e, 0x88, 0xa6, 0xd5, 0x31, 0xbb, 0xb5, 0xde, 0xba, 0xf3, 0x87, 0x17, 0x8e, 0x1a,
	0xb1, 0x6f, 0x5d, 0xcc, 0xda, 0x05, 0x2f, 0xe5, 0xe2, 0x47, 0x68, 0x45, 0x0c, 0xe3, 0xc4, 0x57,
	0x9e, 0xa4, 0x4e, 0x36, 0x4b, 0x1d, 0xa3, 0x5b, 0xf1, 0x96, 0x15, 0x7c, 0x78, 0x16, 0x04, 0x7a,
	0xa5, 0xcd, 0x4f, 0x26, 0xaa, 0xde, 0x2e, 0x88, 0x5f, 0xa1, 0x9a, 0x64, 0x92, 0x8c, 0xb2, 0x0a,
	0xb5, 0x5d, 0xad, 0xb7, 0x95, 0x13, 0xcc, 0x3c, 0x77, 0x6e, 0x3c, 0x77, 0x0e, 0xdf, 0xec, 0xec,
	0xe8, 0xda, 0x4c, 0x1e, 0xe9, 0xfa, 0xb4, 0x5b, 0x1b, 0xd5, 0x38, 0xa1, 0x11, 0xf8, 0x01, 0x9b,
	0x50, 0xa9, 0x4d, 0x28, 0x79, 0x48, 0x43, 0x3b, 0x0a, 0xc1, 0xaf, 0xd1, 0x1a, 0x49, 0x12, 0xce,
	0xce, 0xe3, 0x31, 0x91, 0xe0, 0x87, 0xb1, 0x18, 0xfa, 0x83, 0xa9, 0x04, 0xa1, 0xbd, 0xb0, 0xfa,
	0xad, 0x6f, 0xb3, 0xf6, 0x1d, 0x0c, 0x6f, 0x35, 0x87, 0xef, 0xc6, 0x62, 0xd8, 0x57, 0x28, 0x7e,
	0x8c, 0x1a, 0x1c, 0xc6, 0x4c, 0x82, 0xff, 0x21, 0x1e, 0x41, 0xd6, 0x4c, 0x2d, 0x6e, 0x79, 0x2b,
	0x69, 0xe2, 0x65, 0x3c, 0x82, 0x94, 0xeb, 0xa0, 0xff, 0xe1, 0x5c, 0x02, 0xa7, 0x64, 0x94, 0x67,
	0x97, 0x35, 0xbb, 0x71, 0x93, 0x5a, 0xf0, 0x03, 0xb4, 0x9e, 0x9f, 0x25, 0x6f, 0xd4, 0xd2, 0xbf,
	0x1b, 0x75, 0x2f, 0xd7, 0xeb, 0xe4, 0xd6, 0xb3, 0xcd, 0xef, 0x06, 0x6a, 0xe4, 0x0e, 0x4e, 0x24,
	0x8c, 0x0a, 0xc0, 0x6f, 0xd1, 0xb2, 0x7e, 0x12, 0x92, 0x65, 0x82, 0xe9, 0x29, 0x3c, 0xbd, 0xe3,
	0x14, 0x7e, 0x29, 0xd6, 0xc8, 0x09, 0xd3, 0xd8, 0x0b, 0x2a, 0xf9, 0xd4, 0xab, 0x89, 0x05, 0x82,
	0xd7, 0x50, 0x19, 0x38, 0x67, 0x5c, 0xd9, 0x64, 0x76, 0xab, 0x5e, 0xf6, 0xd5, 0x7a, 0x9f, 0x1e,
	0x7e, 0xbe, 0x10, 0xd7, 0x91, 0xa9, 0x0e, 0x55, 0x1f, 0xbd, 0xa7, 0x42, 0xdc, 0x43, 0xa5, 0x33,
	0x32, 0x9a, 0x80, 0xfe, 0xb9, 0xb5, 0xde, 0xc6, 0x5f, 0x07, 0x4a, 0xa9, 0xcf, 0x8b, 0xcf, 0x8c,
	0x7d, 0xab, 0x62, 0xd4, 0x8b, 0xfb, 0x56, 0xa5, 0x58, 0x37, 0xf7, 0xad, 0x8a, 0x59, 0xb7, 0xfa,
	0x47, 0x17, 0x5f, 0xed, 0xc2, 0xc5, 0xdc, 0x36, 0x2e, 0xe7, 0xb6, 0x71, 0x35, 0xb7, 0x8d, 0x2f,
	0x73, 0xdb, 0xf8, 0x7c, 0x6d, 0x17, 0x2e, 0xaf, 0xed, 0xc2, 0xd5, 0xb5, 0x5d, 0x78, 0xf7, 0x24,
	0x8a, 0xe5, 0xe9, 0x64, 0xe0, 0x04, 0x6c, 0xec, 0xde, 0xca, 0x84, 0x83, 0x45, 0xec, 0x26, 0xc3,
	0xc8, 0xcd, 0x64, 0x07, 0x65, 0xfd, 0x80, 0xb7, 0x7f, 0x06, 0x00, 0x00, 0xff, 0xff, 0x02, 0x44,
	0x0c, 0xc4, 0x54, 0x04, 0x00, 0x00,
}

func (m *SpanStatsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanStatsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanStatsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SkipMvccStats {
		i--
		if m.SkipMvccStats {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Spans) > 0 {
		for iNdEx := len(m.Spans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Spans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpanStats(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintSpanStats(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintSpanStats(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodeID) > 0 {
		i -= len(m.NodeID)
		copy(dAtA[i:], m.NodeID)
		i = encodeVarintSpanStats(dAtA, i, uint64(len(m.NodeID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpanStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ApproximateTotalStats.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSpanStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if m.ExternalFileBytes != 0 {
		i = encodeVarintSpanStats(dAtA, i, uint64(m.ExternalFileBytes))
		i--
		dAtA[i] = 0x30
	}
	if m.RemoteFileBytes != 0 {
		i = encodeVarintSpanStats(dAtA, i, uint64(m.RemoteFileBytes))
		i--
		dAtA[i] = 0x28
	}
	if m.ApproximateDiskBytes != 0 {
		i = encodeVarintSpanStats(dAtA, i, uint64(m.ApproximateDiskBytes))
		i--
		dAtA[i] = 0x18
	}
	if m.RangeCount != 0 {
		i = encodeVarintSpanStats(dAtA, i, uint64(m.RangeCount))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.TotalStats.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSpanStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SpanStatsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanStatsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpanStatsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Errors) > 0 {
		for iNdEx := len(m.Errors) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Errors[iNdEx])
			copy(dAtA[i:], m.Errors[iNdEx])
			i = encodeVarintSpanStats(dAtA, i, uint64(len(m.Errors[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.SpanToStats) > 0 {
		keysForSpanToStats := make([]string, 0, len(m.SpanToStats))
		for k := range m.SpanToStats {
			keysForSpanToStats = append(keysForSpanToStats, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForSpanToStats)
		for iNdEx := len(keysForSpanToStats) - 1; iNdEx >= 0; iNdEx-- {
			v := m.SpanToStats[string(keysForSpanToStats[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintSpanStats(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForSpanToStats[iNdEx])
			copy(dAtA[i:], keysForSpanToStats[iNdEx])
			i = encodeVarintSpanStats(dAtA, i, uint64(len(keysForSpanToStats[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSpanStats(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintSpanStats(dAtA []byte, offset int, v uint64) int {
	offset -= sovSpanStats(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SpanStatsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeID)
	if l > 0 {
		n += 1 + l + sovSpanStats(uint64(l))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovSpanStats(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovSpanStats(uint64(l))
	}
	if len(m.Spans) > 0 {
		for _, e := range m.Spans {
			l = e.Size()
			n += 1 + l + sovSpanStats(uint64(l))
		}
	}
	if m.SkipMvccStats {
		n += 2
	}
	return n
}

func (m *SpanStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TotalStats.Size()
	n += 1 + l + sovSpanStats(uint64(l))
	if m.RangeCount != 0 {
		n += 1 + sovSpanStats(uint64(m.RangeCount))
	}
	if m.ApproximateDiskBytes != 0 {
		n += 1 + sovSpanStats(uint64(m.ApproximateDiskBytes))
	}
	if m.RemoteFileBytes != 0 {
		n += 1 + sovSpanStats(uint64(m.RemoteFileBytes))
	}
	if m.ExternalFileBytes != 0 {
		n += 1 + sovSpanStats(uint64(m.ExternalFileBytes))
	}
	l = m.ApproximateTotalStats.Size()
	n += 1 + l + sovSpanStats(uint64(l))
	return n
}

func (m *SpanStatsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SpanToStats) > 0 {
		for k, v := range m.SpanToStats {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSpanStats(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSpanStats(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSpanStats(uint64(mapEntrySize))
		}
	}
	if len(m.Errors) > 0 {
		for _, s := range m.Errors {
			l = len(s)
			n += 1 + l + sovSpanStats(uint64(l))
		}
	}
	return n
}

func sovSpanStats(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSpanStats(x uint64) (n int) {
	return sovSpanStats(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SpanStatsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanStatsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanStatsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpanStats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpanStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSpanStats
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSpanStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSpanStats
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSpanStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spans = append(m.Spans, Span{})
			if err := m.Spans[len(m.Spans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipMvccStats", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipMvccStats = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSpanStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeCount", wireType)
			}
			m.RangeCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApproximateDiskBytes", wireType)
			}
			m.ApproximateDiskBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApproximateDiskBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteFileBytes", wireType)
			}
			m.RemoteFileBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemoteFileBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalFileBytes", wireType)
			}
			m.ExternalFileBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExternalFileBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApproximateTotalStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ApproximateTotalStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpanStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanStatsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpanStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanStatsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanStatsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanToStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpanStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpanStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SpanToStats == nil {
				m.SpanToStats = make(map[string]*SpanStats)
			}
			var mapkey string
			var mapvalue *SpanStats
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpanStats
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpanStats
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSpanStats
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSpanStats
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpanStats
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSpanStats
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthSpanStats
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SpanStats{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSpanStats(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSpanStats
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SpanToStats[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpanStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpanStats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpanStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpanStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpanStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSpanStats(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSpanStats
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSpanStats
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSpanStats
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSpanStats
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSpanStats
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSpanStats
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSpanStats        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSpanStats          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSpanStats = fmt.Errorf("proto: unexpected end of group")
)

